\documentclass[a4paper]{article}

%\usepackage{draftcopy}
\usepackage{doxygen}
\usepackage{framed}
\usepackage{color}
\usepackage{xcolor}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{colorkeyword}{rgb}{0.1,0.1,0.6}
\definecolor{colorassert}{rgb}{0.5,0.5,0.5}

\usepackage{tikz}\usetikzlibrary{automata,arrows,snakes,shapes}
\usepackage{amssymb}
\usepackage{amsmath}
% \usepackage{microtype}
\usepackage{fixltx2e}
\usepackage{numprint}
\usepackage{booktabs}
\usepackage{xspace}
\usepackage{mparhack}
\usepackage{moreverb}
\usepackage{listings}

\usepackage{ifthen}

\setlength{\tabcolsep}{5pt}
\setlength{\arraycolsep}{5pt}
\setlength{\cmidrulekern}{4pt}

\newcommand{\secref}[1]{section\xspace\ref{#1}}
\newcommand{\figref}[1]{figure\xspace\ref{#1}}
\newcommand{\listref}[1]{listing\xspace\ref{#1}}

\newsavebox{\riddlebox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newlength{\lw}\setlength{\lw}{0.4pt}
\newlength{\st}\setlength{\st}{0pt}

\tikzstyle{every picture}+=[>=latex']
\tikzstyle{every picture}+=[bend angle=10]
\tikzstyle{every picture}+=[auto]
\tikzstyle{every picture}+=[join=round]
\tikzstyle{every picture}+=[cap=butt]
\tikzstyle{every picture}+=[line width=\lw]
\tikzstyle{every picture}+=[double distance=2\lw]
\tikzstyle{every picture}+=[shorten >=\st]
\tikzstyle{every picture}+=[node distance=4em]
\tikzstyle{every loop}=[->,shorten >=\st]
\tikzstyle{tight}=[inner sep=0pt,outer sep=0pt]
\tikzstyle{zero}=[draw=none,coordinate]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\zerowsep}{\hskip 0pt plus 0.1pt minus 0.1pt}

\makeatletter
\newcommand{\ZSEP}[1]{\ifx#1\@@@EOZ@@@\let\next\relax\else\ifx#1\_#1\zerowsep\else#1\fi\let\next\ZSEP\fi\next}
\newcommand{\zsep}[1]{\ZSEP{}#1\@@@EOZ@@@}
\makeatother

\newcommand{\sol}[1]{\emph{\zsep{#1}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\gaspiprefix}{gaspi}
\newcommand{\GASPI}{{\sc Gaspi}}

\newcommand{\type}[1]{{\tt #1}}
\newcommand{\function}[1]{{\tt #1}}
\newcommand{\parameter}[1]{{\it #1}}

\newcommand{\gaspitype}[1]{\type{\protect\zsep{\gaspiprefix\_#1\_t}}}
\newcommand{\gaspifunction}[1]{\function{\protect\zsep{\gaspiprefix\_#1}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\finalsymb}[1]{\leavevmode\unskip\penalty9999\hbox{}\nobreak\hfill\hskip 1em minus 0.5em\hbox{#1}}

\newenvironment{cbox}[1]
{\newcommand\colboxcolor{#1}\begin{lrbox}{\riddlebox}\begin{minipage}{\dimexpr\columnwidth-2\fboxsep\relax}}
{\end{minipage}\end{lrbox}\begin{center}\colorbox[HTML]{\colboxcolor}{\usebox{\riddlebox}}\end{center}}

\newcounter{counttodo}
\newlength{\savetabcolsep}
\newlength{\savearrayrulewidth}
\newenvironment{todo}
{\stepcounter{counttodo}
 \typeout{Environment TODO call \thecounttodo}
 \setlength{\savetabcolsep}{\tabcolsep}
 \setlength{\savearrayrulewidth}{\arrayrulewidth}
 \renewcommand{\tabcolsep}{0pt}
 \renewcommand{\arrayrulewidth}{2pt}
 \begin{center}
 \begin{tabular}{c|l@{\hspace*{2em}}|@{\hspace*{2em}}c}
 &
 \begin{minipage}{0.66\textwidth}
 \begin{itemize}
}
{\end{itemize}
 \end{minipage}
 &  todo \#\thecounttodo
 \end{tabular} \marginpar{$\Longleftarrow$}
 \end{center}
 \renewcommand{\tabcolsep}{\savetabcolsep}
 \renewcommand{\arrayrulewidth}{\savearrayrulewidth}
}

\newcommand{\todooverviewtext}
{***
 Counted {\thecounttodo} calls to environment TODO.
 EDIT THIS!
 ***
}
\newcommand{\todooverview}
{\newpage
 {\Large\bf \todooverviewtext}
 \typeout{\todooverviewtext}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%               Function definition                                     %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\shortlistbegin}[1]{\begin{trivlist}\setlength{\itemsep}{0pt}\item[]\emph{#1:}}
\newcommand{\shortlistitem}[1]{\item[]#1}
\newcommand{\shortlistend}{\end{trivlist}}

\newenvironment{FDef}{\begin{trivlist}\item[]}{\end{trivlist}}
\newenvironment{FDefSign}{\begin{cbox}{EEEEEE}}{\end{cbox}}

\newcommand{\parameterlistbegin}{\shortlistbegin{Parameter}}
\newcommand{\parameterlistend}{\shortlistend}
\newcommand{\parameterlistitem}[3]{\shortlistitem{\parameter{(#1) #2:} {#3}}}

\newcommand{\executionphase}[1]{\shortlistbegin{Execution phase}\shortlistitem{#1}\shortlistend}
\newcommand{\executionphasesetup}{\executionphase{Setup}}
\newcommand{\executionphaseinit}{\executionphase{Initialization}}
\newcommand{\executionphasework}{\executionphase{Working}}
\newcommand{\executionphaseshutdown}{\executionphase{Shutdown}}
\newcommand{\executionphaseany}{\executionphase{Any}}

\newcommand{\returnlistbegin}{\shortlistbegin{Return values}}
\newcommand{\returnlistend}{\shortlistend}
\newcommand{\returnlistitem}[2]{\item[]#1: #2}

\newcommand{\fdeffinal}{\finalsymb{$\lrcorner$}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\GASPISUCC}{{\tt\protect\zsep{GASPI\_SUCCESS}}}
\newcommand{\GASPISUCCTXT}{operation has returned successfully}
\newcommand{\GASPITIME}{{\tt\protect\zsep{GASPI\_TIMEOUT}}}
\newcommand{\GASPITIMETXT}{operation has run into timeout}
\newcommand{\GASPIGERR}{{\tt\protect\zsep{GASPI\_ERROR}}}
\newcommand{\GASPIGERRTXT}{operation has finished with an error}
\newcommand{\GASPIGROUPALL}{{\tt\protect\zsep{GASPI\_GROUP\_ALL}}}

\newcommand{\GASPITEST}{{\tt\protect\zsep{GASPI\_TEST}}}
\newcommand{\GASPIBLOCK}{{\tt\protect\zsep{GASPI\_BLOCK}}}

\newcommand{\FStdRetDesc}
{
  \returnlistbegin
  \returnlistitem{\GASPISUCC}{\GASPISUCCTXT}
  \returnlistitem{\GASPITIME}{\GASPITIMETXT}
  \returnlistitem{\GASPIGERR}{\GASPIGERRTXT}
  \fdeffinal\returnlistend
}

\newcommand{\FStdRetDescNOTimeout}
{
  \returnlistbegin
  \returnlistitem{\GASPISUCC}{\GASPISUCCTXT}
  \returnlistitem{\GASPIGERR}{\GASPIGERRTXT}
  \fdeffinal\returnlistend
}

\newcommand{\gaspisemantic}[1]{{\emph{#1}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%                          Type definition                              %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newenvironment{TDef}{\begin{trivlist}\item[]}{\finalsymb{$\lrcorner$}\end{trivlist}}
\newcommand{\TDefDefn}[2]{\begin{cbox}{EEEEEE}typedef {#1} {#2}\end{cbox}}
\newcommand{\TDefDesc}[1]{\item[]{\itshape{#1}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%          User / Implementor advice                                    %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newenvironment{implementoradvice}{\begin{flushright}\begin{minipage}[t]{0.9\linewidth}\emph{Implementor advice:}}{\finalsymb{$\lrcorner$}\end{minipage}\end{flushright}}
\newenvironment{useradvice}{\begin{flushright}\begin{minipage}[t]{0.9\linewidth}\emph{User advice:}}{\finalsymb{$\lrcorner$}\end{minipage}\end{flushright}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%                            Enums                                      %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\enum}[1]{ {\it #1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%                          Listings                                     %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\insertlisting}[2]{\lstset{
basicstyle=\ttfamily
, caption={#2}
, frame=single
, numbers=left
, numberstyle=\tiny
, stepnumber=1
, showstringspaces=true
, keepspaces=true
, columns=fullflexible
, classoffset=0
, morekeywords={gaspi_rank_t,gaspi_barrier,gaspi_timeout_t,gaspi_return_t,gaspi_configuration_t,gaspi_proc_init,gaspi_proc_term,gaspi_proc_kill
  ,gaspi_group_commit,gaspi_group_create,gaspi_group_add,gaspi_group_size,gaspi_group_ranks
  ,gaspi_segment_id_t,gaspi_segment_alloc,gaspi_segment_register,gaspi_segment_create
  ,gaspi_segment_ptr,gaspi_queue_id_t,gaspi_offset_t,gaspi_socket_id_t,gaspi_size_t,gaspi_pointer_t
  ,gaspi_write,gaspi_read,gaspi_wait
  ,gaspi_notify,gaspi_notify_reset,gaspi_notify_wait ,gaspi_counter_t
  ,gaspi_counter_value_t,gaspi_counter_id_t,gaspi_proc_num,gaspi_proc_rank
  ,gaspi_number_t,gaspi_notification_t,gaspi_notification_id_t, gaspi_time_t
  ,gaspi_counter_compare_swap,gaspi_counter_set
  ,GASPI_SUCCESS,GASPI_TIMEOUT,GASPI_ERROR,GASPI_GROUP_ALL
  ,GASPI_BLOCK,GASPI_TEST,GASPI_CONFIGURATION_DEFAULT,GASPI_NORANK,GASPI_NOSTRING
  ,gaspi_notify_waitsome,gaspi_notify_size,gaspi_error_message
  ,gaspi_queue_size_max,gaspi_queue_size,gaspi_time_get
  }
, commentstyle=\color{dkgreen}
, keywordstyle=\color{colorkeyword}
, classoffset=1
, morekeywords={ASSERT}
, keywordstyle=\color{colorassert}
, classoffset=0
}\lstinputlisting{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%                              Document                                 %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{\GASPI{}: Global Address Space Programming Interface\\
~\\
Specification of a general purpose API for communication\\
~\\
draft, version 0.91
}

\author{Daniel Gr\"unewald et al.\\
Fraunhofer ITWM, Fraunhofer Platz 1, 67663 Kaiserslautern
}

\begin{document}

\begin{titlepage}
\maketitle
\end{titlepage}

\tableofcontents


\newpage

% \begin{todo}
% \item Describe calculations of memory locations (and bounds checks)
%   once and not again and again.
% \end{todo}

\section{About the document}

This is a draft version for comment only. There are parts of a
complete specification missing, for example you will find (nearly)
nothing about language bindings. However, most of the ideas for a new
PGAS API are included in this draft version and it should give you a
good impression of how it will look like.

\section{Introduction to \GASPI{}}
\label{sec::Intro}

\subsection{Overview and Goals}
\label{subsec::Overview}

\GASPI{} is a Partitioned Global Address Space (PGAS) API. It aims at
scalable, flexible and failure tolerant computing in parallel
computing environments.  \GASPI{} targets extreme scalability and aims
to initiate a paradigm shift from bulk-synchronous two-sided
communication patterns towards an asynchronous communication and
execution model. To that end \GASPI{} leverages one-sided RDMA driven
communication in a Partitioned Global Address Space. In contrast to
other efforts in the PGAS community, \GASPI{} is neither a new
language (like e.\,g.\ Chapel from Cray), nor an extension to a
langauge (like e.\,g.\ Co-Array Fortran). Instead---very much in the
spirit of MPI---it complements existing languages like C/C++ or
Fortran with a PGAS API which enables the application to leverage the
concept of the Partitioned Global Adress Space.  In contrast to
e.\,g.\ OpenShmem or Global Arrays, \GASPI{} is not limited to a
single memory model, but rather provides configurable RDMA pinnend
PGAS memory segments.  By means of these segments GASPI does not
merely support a single Partitioned Global Address Space, but rather a
multitude of Partitioned Global Address Spaces. In GASPI it is hence
quite possible for different memory management systems---or indeed
different PGAS applications---to co-exist in the same single global
address space. \GASPI{} is failure tolerant in the sense that it
provides timeout mechanisms for all non-local procedures, failure
detection and the possibility to adapt to shrinking or growing node
sets.

\subsection{History}
The \GASPI{} specification originates from the PGAS API of the Fraunhofer
ITWM (Fraunhofer Virtual Machine, FVM), which has been developed since
2005. Starting from 2007 this PGAS API has evolved into a robust
commercial product (called GPI) which is used in the industry projects
of the Fraunhofer ITWM. GPI offers a highly efficient and scalable
programming model for Partitioned Global Address Spaces and has
replaced MPI completely at Fraunhofer ITWM. In 2011 the partners of
Fraunhofer ITWM, Fraunhofer SCAI, TUD, T-Systems SfR, DLR, KIT, FZJ,
DWD and Scapos have initiated and launched the \GASPI{} project to
define a novel specification for a PGAS API (\GASPI{}, based on GPI) and to
make this novel \GASPI{} specification a reliable, scalable and universal
tool for the HPC community.

\subsubsection{Application requirements}

The following application requirements have been identified

\begin{itemize}
\item one-sided asynchronous remote read/write operations
\item allreduce (also for subgroups)
\item barrier (also for subgroups)
\item broadcast (also for subgroups)
\item passive communication
\item atomic counters
\end{itemize}


\subsubsection{Design goals}

From the application requirements the following design goals have been deduced:

\begin{itemize}
\item Extreme Scalability
\item Multi-segment support (heterogeneous systems, NUMA-pinning)
\item Dynamic allocation of segments
\item Timeout mechanisms and failure tolerance
\item Group support for collectives
\item Large flexibility in the number of queues, queue sizes,
  atomic counters etc.
\item A maximum freedom to implementors, where details are left to
  implementation
\item A strong standard library which takes care of convenience
  procedures and cosmetics. The specification should be simple and solid.
\item GPI is the base and we should improve from there where necessary
\end{itemize}

%\subsection{Organization of this document}

\section{\GASPI{} terms and conventions}

This section describes notational terms and conventions used throughout the \GASPI{}
document.

%\subsection{Document Notation}

\subsection{Naming Conventions}

All procedures are named in accordance with the following convention.
The procedures have \gaspifunction{} as a prefix. The prefix
is followed by the operation name.


\subsection{Procedure specification}

\subsection{Semantic terms}

The following semantic terms are used throughout the document:

\newcommand{\septext}{0.5em}
\newcommand{\gentextwithline}[6]{
\draw (#2,#3) node[left] {#1};
\draw[#6] (#2+\septext+#4,#3) -- +(#5,0);
}
\newcommand{\timeline}[1]{\gentextwithline{Time}{0}{#1}{0}{25em}{->,dashed}}
\newcommand{\operation}[2]{\gentextwithline{Operation}{0}{#1}{1em}{#2}{|-|}}
\newcommand{\gencall}[3]{\gentextwithline{#1}{0}{#2}{0}{#3}{|-|}}
\newcommand{\call}[2]{\gencall{Call}{#1}{#2}}
\newcommand{\calls}[2]{\gencall{Calls}{#1}{#2-10em};
\draw[|-|] (#2-8em,#1) -- +(8em,0);
}
\newcommand{\wait}[3]{\gentextwithline{Wait}{#1}{#2}{0}{#3}{|-|}}
\newcommand{\progress}[2]{\gentextwithline{Progress}{0}{#1}{1em}{#2}{|-|}}

\begin{description}
\item[nonblocking] A procedure is nonblocking if the procedure may
  return before the operation completes.
\begin{center}
\begin{tikzpicture}
\timeline{\baselineskip};
\call{-\baselineskip}{10em};
\wait{15em}{-\baselineskip}{6em};
\operation{0}{19em};
\draw[->,dotted] (\septext,-\baselineskip) -- (\septext+1em,0em);
\draw[->,dotted] (19em+\septext+1em,0) -- (\septext+21em,-\baselineskip);
\end{tikzpicture}
\end{center}
\item[blocking] A procedure is blocking if the procedure only returns
  after the operation has completed.
\begin{center}
\begin{tikzpicture}
\timeline{\baselineskip};
\call{-\baselineskip}{21em};
\operation{0}{19em};
\draw[->,dotted] (\septext,-\baselineskip) -- (\septext+1em,0em);
\draw[->,dotted] (19em+\septext+1em,0) -- (\septext+21em,-\baselineskip);
\end{tikzpicture}
\end{center}
\item[time-based blocking] A procedure is time-based blocking if the
  procedure may return after the operation completes or after a given
  timeout has been reached. A corresponding return value is used to
  distinguish between the two cases.
\begin{center}
\begin{tikzpicture}
\timeline{\baselineskip};
\call{-\baselineskip}{16em};
\call{-2\baselineskip}{21em};
\operation{0}{19em};
\draw[->,dotted] (\septext,-\baselineskip) -- (\septext+1em,0em);
\draw[->,dotted] (19em+\septext+1em,0) -- (\septext+21em,-2\baselineskip);
\draw[->,dotted] (16em+\septext,\baselineskip) -- (16em+\septext,-\baselineskip);
\end{tikzpicture}
\end{center}
\item[local] A procedure is local if completion of the procedure depends
  only on the local executing \GASPI{} process.
\item[non-local] A procedure is non-local if completion of the
  operation may depend on the existence (and execution) of a remote \GASPI{} process
\item[collective] A procedure is collective if all processes in a
  process group need to invoke the procedure. A collective call may or
  may not be synchronizing.
\item[predefined] A predefined type is a datatype with a predefined
  constant name.
\item[timeout]  A timeout is a mechanism required by procedures that
  might block (see blocking above). Timeout here is defined as the maximum
  time (in milliseconds) a called procedure will wait for outstanding communication
  from other processes. The special value \numprint{0}  (defined as \GASPITEST{}) indicates
  that the procedure will complete all local operations. The procedure subsequently returns
  the current status without waiting for data from other processes (non-blocking). On the other hand the
  special value \numprint{-1} (defined as \GASPIBLOCK{}) instructs the procedure to wait indefinitely (blocking).
  A number greater than \numprint{0} indicates the maximum time the procedure will wait for
  data from other ranks (time-based blocking).  The timeouts hence are soft: The timeout value $n$ does
  not imply that the called procedure will return after $n$  milliseconds. It just means that the procedure should wait for at
  most $n$ milliseconds for data from other processes.
\item[synchronous]
  A procedure is called synchronous if progress towards
  completion only is achieved as long as  the application is inside (executing) the procedure.
\begin{center}
\begin{tikzpicture}
\timeline{\baselineskip};
\progress{0}{10em};
\draw[|-|] (14em,0) -- (19em,0);
\calls{-\baselineskip}{21em};
\draw[->,dotted] (\septext,-\baselineskip) -- (\septext+1em,0em);
\draw[->,dotted] (19em,0) -- (21em,-\baselineskip);
\draw[->,dotted] (\septext+11em,\baselineskip) -- (\septext+11em,-\baselineskip);
\draw[<-,dotted] (14em,0) -- (13em,-\baselineskip);
\end{tikzpicture}
\end{center}
\item[asynchronous]
  A procedure is called asynchronous if progress towards
  completion may be achieved after the procedure exits.
\begin{center}
\begin{tikzpicture}
\timeline{\baselineskip};
\progress{0}{15em};
\calls{-\baselineskip}{21em};
\draw[->,dotted] (\septext,-\baselineskip) -- (\septext+1em,0em);
\draw[->,dotted] (15em+\septext+1em,0) -- (21em,-\baselineskip);
\draw[->,dotted] (\septext+11em,\baselineskip) -- (\septext+11em,-\baselineskip);
\draw[<-,dotted] (14em,0) -- (13em,-\baselineskip);
\end{tikzpicture}
\end{center}

\end{description}

Please note that some of the semantic terms are not exclusive. Some of
them do overlap. According to the definition, a collective procedure
may also be a local procedure. Furthermore, a blocking procedure is
per definition also a synchronous procedure; the reverse statement is
not true.

%\subsection{Implementation issues}

%\subsection{Independence of basic runtime routines}

\subsection{Examples}

The examples in this document are for illustration purposes only. They are not intended
to specify the semantics.


\section{\GASPI{} concepts}

\subsection{Introduction and overview}

In this section, the basic \GASPI{} concepts are introduced. A more detailed
description with the corresponding procedure specifications can be found
in the subsequent topic-specific sections.

\GASPI{} is a communication API.  It implements a Partitioned Global
Address Space (\emph{PGAS}) model. Each \GASPI{} process hosts some
part, zero or one or more segments, of the global address space. This
partition is local to the process and can be accessed locally just as
ordinary allocated memory. In addition to that, every thread on every
other \GASPI{} process can also have access to these segments by read
and write operations.

\GASPI{} was designed with remote direct memory access (RDMA) in mind.
A network infrastructure that supports RDMA guarantees asynchronous and
one-sided communication operations without involving the CPU. This is
one of the main requirements for high scalability which results from
interference free communication, e.\,g.\ from overlapping communication
with computation.

\subsection{\GASPI{} processes}

%\GASPI{} has a high flexibility in the configuration of the runtime
%parameters.

\GASPI{} provides the concept of ranks. Each \GASPI{} process receives
a unique rank that identifies it during runtime.

\subsection{\GASPI{} groups}

Groups are sub-sets of the set of processes. The group members
have common collective operations. A collective operation is then
restricted to the processes forming the group.

\subsection{\GASPI{} segments}

Modern hardware typically involves a hierarchy of memory with respect to the
bandwidth and latencies of read and write accesses. Within that hierarchy are
non-uniform memory access (\emph{NUMA}) partitions, solid state
devices (\emph{SSD}s), graphical processing unit (\emph{GPU}) memory
or many integrated cores (\emph{MIC}) memory.  The \GASPI{} memory
segments are supposed to map this variety of hardware layers to the software
layer. In the spirit of the PGAS approach, these \GASPI{} segments
may be globally accessible from every thread of every \GASPI{} process.
\GASPI{} segments can also be used to leverage different memory models within
a single application or to even run different applications in a single partitioned global
address space.

\subsection{\GASPI{} one-sided communication}

One-sided asynchronous communication is the basic communication
mechanism provided by \GASPI{}. The one-sided communication comes
in two flavors.  There are read and write operations from and into the
partitioned global address space from arbitrary locations. These
operations are non-blocking and asynchronous, allowing the program to continue
its execution along the data transfer. The actual data transfer is managed
by the underlying network infrastructure.

%From the application point of view, a transfer can be considered to be
%completed if a corresponding wait operation has successfully returned.
%In this respect, an entire communication request is splitted into two
%calls. The actual invocation and the check for completion.

\GASPI{} offers the possibility to use different queues to handle the requests. Each
communication request can be submitted to one of the supported
queues. These queues allow more scalability and can be used as
channels for different types of requests where similar types of
requests are queued and then get synchronized together but
independently from the other ones (separation of concerns).
The specification guarantees fairness of transfers posted to
different queues, i.\,e.\ no queue should see its
communication requests delayed indefinitely.

Furthermore, the order of communication request addressing the same remote \GASPI{}
process posted to a given queue are preserved, both on the local as
well as on the remote side.

\insertlisting{ex.one_sided.pseudo}{Alltoall with one-sided writes.}

\subsection{\GASPI{} passive communication}

Passive communication has a two-sided semantics, where there is a
matching receiver to a send request. Passive communication aims at
communication patterns where the sender is unknown (i.\,e.\ it can be any
process from the receiver perspective) but there is potentially the
need for synchronization between different processes.

The receive operation is a blocking call that has as low interference
as possible (e.\,g.\ consumes no CPU cycles) and should be woken up
directly by the network layer. This passive communication allows for
fair distributed updates of globally shared parts of data.

\insertlisting{ex.passive.pseudo}{Single consumer and multiple
  producers using passive communication. The producer transfers a data
  packet while producing the next data packet, thus overlapping
  computation and communication.}

\subsection{\GASPI{} global atomics}

\GASPI{} provides atomic counters, i.\,e. integral types that can be
manipulated through atomic procedures. These atomic procedures are
guaranteed to execute from start to end without fear of preemption
causing corruption.  There are two basic operations on atomic
counters: \function{fetch\_and\_add} and
\function{compare\_and\_swap}. The counters can be used as global
shared variables used to synchronize processes or events.

Atomic counters are predestined for the implementation of dynamic load balancing
schemes for example.

The specification guarantees fairness, i.\,e.\ no process should see
its atomic operation delayed indefinitely.

\insertlisting{ex.atomic1.pseudo}{Dynamic work distribution: Clients
  atomically fetch a packet id and increment the value.}

\subsection{\GASPI{} collective communication}

Collective operations are operations which involve a whole set of
\GASPI{} processes. That means that collective operations are
collective with respect to a group of processes. They are also exclusive
per group, i.\,e.\ only one collective operation of a specific type can
run at a given time. For example, two allreduce for one group can not run at the same
time; however, an allreduce operation and a barrier can run at the
same time.

Collective operations can be either synchronous or asnychronous.
Synchronous implies that progress is achieved only as long as
the application is inside of the call. The call itself, however, may
be interrupted by a timeout. The operation is then continued in the
next call of the procedure. This implies that a collective operation
may involve several procedure calls until completion.

Please note that collective operations can internally also be handled asynchronously,
i.\,e.\ with progress being achieved outside of the call.

\begin{implementoradvice}
\GASPI{} does not regulate
whether individual collective operations should internally being handled synchronously
or asynchronously, however: \GASPI{} aims at an efficient, low-overhead programming model.
If asynchronous operation is supported, it should leverage external network-resources, rather than
consuming CPU cycles.
\end{implementoradvice}

Beside barriers and reductions with predefined operations,
reductions with user defined operations are also supported via callback
functions.

Collective operations have their own queue and hence typically will be synchronized
independently from the operations on other queues (separation of concerns).

\subsection{\GASPI{} timeouts}
\label{SubSec::Timeout}

Failure tolerant parallel programs necessitate non-blocking
communication calls.  Hence, \GASPI{} provides a timeout mechanism for
all potentially blocking procedures.

The timeout for a given procedure is specified in milliseconds.
\GASPIBLOCK{} is a special predefined timeout value which blocks the
invoked procedure until the procedure is completed. This special value
shall not be used in a failure tolerant program, because in a
situation in which the procedure cannot complete due to a failure on a
remote process, the procedure will not return at all.

\GASPITEST{} is yet another predefined special timeout value which
represents a timeout equal to zero. Timeout equal to zero means that
the invoked procedure processes an atomic portion of the work and
returns after that work has finished. It does not mean that the
invoked procedure is doing nothing. It does not mean that the invoked
procedure returns immediately.

Example:
\begin{listing}{1}
const gaspi_return_t err = WAIT (..., GASPI_BLOCK);
\end{listing}
Blocks until the communication queue is empty. No chance to handle
failures.
\begin{listing}{1}
const gaspi_return_t err = WAIT (..., GASPI_TEST);
\end{listing}
Just check for the operation to be complete and return as soon as possible.
\begin{listing}{1}
const gaspi_return_t err = WAIT (..., 10);
\end{listing}
Blocks until the queue is empty or more than $10$ milliseconds have
passed since the wait call has been initiated.

\subsection{\GASPI{} return values}

\GASPI{} procedures have three general return values:

\begin{listing}[99]{2}
GASPI_SUCCESS = 0
GASPI_ERROR   = -1
GASPI_TIMEOUT = 1
\end{listing}

\GASPISUCC{} corresponds to return value equal to zero and implies
 that the procedure has completed successfully.

\GASPITIME{} corresponds to return value equal to one and implies
that the procedure could not complete in the given period of time.
This does not necessarily mean that an error has occurred.
The procedure has to be invoked subsequently in order to fully complete
the operation.

\GASPIGERR{} corresponds to a return value less than zero and implies
that the procedure has terminated due to an error.  There are no
predefined error values specifying the detailed cause of error in the
\GASPI{} specification. This is implementation dependent. However,
\gaspifunction{error\_message} translates the error code into a human
readable format. Moreover, all error codes in the range
$(-2,\ldots,-999)$ are reserved for future extensions and
must not be used for implementation specific error codes.
\begin{implementoradvice}
If there are predefined error codes, each of the return codes must
have a corresponding error message.
\end{implementoradvice}

Additionally, there is a state vector that contains health states for
individual processes. The state vector is set after non-local operations
and can be used to detect failures on remote processes.


\section{\GASPI{} definitions}

\subsection{Types}

\begin{TDef}
\TDefDefn{unsigned int}{\gaspitype{rank}}
\TDefDesc{The \GASPI{} rank type.}
\end{TDef}

\begin{TDef}
\TDefDefn{unsigned short}{\gaspitype{segment\_id}}
\TDefDesc{The \GASPI{} memory segment ID type.}
\end{TDef}

\begin{TDef}
\TDefDefn{unsigned long}{\gaspitype{offset}}
\TDefDesc{The \GASPI{} offset type. Offsets are measured relative to
  the beginning of a memory segment in units of bytes.}
\end{TDef}

\begin{TDef}
\TDefDefn{unsigned long}{\gaspitype{size}}
\TDefDesc{The \GASPI{} size type. Sizes are measured in units of bytes.}
\end{TDef}

\begin{TDef}
\TDefDefn{unsigned short}{\gaspitype{queue\_id}}
\TDefDesc{ The \GASPI{} queue ID type.}
\end{TDef}

\begin{TDef}
\TDefDefn{int}{\gaspitype{notification}}
\TDefDesc{The \GASPI{} notification type.}
\end{TDef}

\begin{TDef}
\TDefDefn{unsigned short}{\gaspitype{notification\_id}}
\TDefDesc{The \GASPI{} notification ID type.}
\end{TDef}

\begin{TDef}
\TDefDefn{int}{\gaspitype{tag}}
\TDefDesc{The \GASPI{} Tag type. Tag are used to discriminate
  different messages in the passive communication channel.}
\end{TDef}

Note! The sum of the sizes of \gaspitype{notification} and
\gaspitype{tag} should be at most 8 bytes.

\begin{TDef}
\TDefDefn{unsigned short}{\gaspitype{counter\_id}}
\TDefDesc{The \GASPI{} global atomic counter ID type.}
\end{TDef}

\begin{TDef}
\TDefDefn{long}{\gaspitype{counter\_value}}
\TDefDesc{The \GASPI{} global atomic counter value type.}
\end{TDef}

\begin{TDef}
\TDefDefn{int}{\gaspitype{return}}
\TDefDesc{The \GASPI{} return value type.}
\end{TDef}

\begin{TDef}
\TDefDefn{{\tt vector<\gaspitype{return}>}}{\gaspitype{returns}}
\TDefDesc{The vector with return codes for individual processes. The
  length of the vector equals the number of processes in the \GASPI{}
  program.}
\end{TDef}

\begin{TDef}
\TDefDefn{int}{\gaspitype{timeout}}
\TDefDesc{The \GASPI{} timeout type.}
\end{TDef}

\begin{TDef}
\TDefDefn{unsigned int}{\gaspitype{number}}
\TDefDesc{A type that is used to count elements. That could be numbers
  of queues as well as the size of individual queues.}
\end{TDef}

\begin{TDef}
\TDefDefn{unsigned short}{\gaspitype{group}}
\TDefDesc{the \GASPI{} group type}
\end{TDef}

\begin{TDef}
\TDefDefn{pointer}{\gaspitype{pointer}}
\TDefDesc{A type that can point to some (area of) memory.}
\end{TDef}

\begin{TDef}
\TDefDefn{unsigned int}{\gaspitype{alloc}}
\TDefDesc{the \GASPI{} allocation policy type}
\end{TDef}

\begin{TDef}
\TDefDefn{unsigned int}{\gaspitype{network}}
\TDefDesc{the \GASPI{} network infrastructure type}
\end{TDef}

\begin{TDef}
\TDefDefn{bool}{\gaspitype{bool}}
\TDefDesc{the \GASPI{} boolean type}
\end{TDef}

\begin{TDef}
\TDefDefn{string}{\gaspitype{string}}
\TDefDesc{the \GASPI{} string type}
\end{TDef}

\subsection{Constants}

\begin{listing}{1}
\enum gaspi_timeout_value_t
\brief special GASPI timeout values

typedef enum { GASPI_BLOCK = -1
             , GASPI_TEST = 0
             } gaspi_timeout_value_t;
\end{listing}

\begin{listing}{1}
\enum gaspi_return_t
\brief return values

typedef enum { GASPI_SUCCESS = 0
             , GASPI_TIMEOUT = 1
             , GASPI_ERROR   = -1
             } gaspi_return_t;
\end{listing}




\section{Execution model}

\subsection{Introduction and overview}
\label{SubSec:ExecPhases}

\GASPI{} does not fix a SPMD (Single Program, Multiple Data) or MPMD
(Multiple Program, Multiple Data) style in its approach to
parallelism.  Hence, either a single program or different programs are
started and initialized on the desired target computational units. How
the \GASPI{} application is started and initialized is not specified
and is implementation specific.

The concept of rank is attributed to each created process. Ranks are a
central aspect which allows applications to identify processes and
therefore make processing elements act on different tasks or data,
even if only a single program is started.

There is also the concept of segments. Segments are memory regions
that may be globally available, to be written to or read from. In general,
the execution of a \GASPI{} process can be considered to be split
into several consecutive phases:

\begin{itemize}
\item \textbf{Setup}
  \begin{description}
  \item Setting up configuration parameters
  \item Performing environment checks
  \end{description}
\item \textbf{Initialization}
  \begin{description}
%   \item Initialization communication infrastructure
  \item Initialization of the runtime environment
%   \item Creation of the communication infrastructure
%   \item Creation of the groups (optional)
%   \item Creation of the segments (optional).
  \end{description}
\item \textbf{Working}
  \begin{description}
  \item Body of the application
  \begin{description}
    \item Communication calls (optional)
    \item Collective operations (optional)
    \item Atomic operations (optional)
  \end{description}
  \end{description}
\item \textbf{Shutdown}
  \begin{description}
  \item Cleanup of communication infrastructure
  \end{description}
\end{itemize}


In the \textbf{setup} phase, the application may retrieve and modify
the \GASPI{} configuration structure (see section~\ref{subsubsec:confstruct})
determining the \GASPI{} runtime behaviour. Optionally (but
advisable), the application can perform environment checks (see
Section~\ref{sec:envcheck}) to make sure the application can be
started safely and correctly.

In the \textbf{initialization} phase, the \GASPI{} runtime environment
is set up in accordance with the parameters of the configuration structure
by invocation of the initialization procedure.
The initialization procedure is called before any other functionality, with the
exception of pre-initialization routines for environment checking and
declaration and retrieval of configuration parameters.  After the
initialization routine has been called, an
optional step to perform is the creation of one or more segments and the creation of
one or more groups.
Segments are contiguous blocks of memory that may be accessed
globally by all processes and where global data should be placed.

After the initialization, the application can proceed with its real
\textbf{working} phase and use the functionality of \GASPI{} (communication,
collectives, atomic counters, etc.).

Before terminating, the application should call the
\textbf{shutdown} procedure (see Section~\ref{sec:shutdown}) so that the
resources and communication infrastructure is cleaned up.

The entire set of execution phases beginning from the setup phase
and ending with the shutdown phase defines a \GASPI{} life cycle.
In principle, several life cycles can be invoked in one \GASPI{}
program.

\begin{useradvice}
Calling a routine in a given execution phase which is not supposed
to be executed in that execution phase results in undefined behavior.
\end{useradvice}

\subsection{Process configuration}

\subsubsection{\GASPI{} configuration structure}
\label{subsubsec:confstruct}

The \GASPI{} configuration structure describes the configuration parameters which
influence the \GASPI{} runtime behavior.

\begin{listing}[99]{2}
typedef struct {

  // number of groups
  gaspi_number_t     group_max;

  // number of segments
  gaspi_segment_id_t segment_max

  // one-sided comm parameter
  gaspi_number_t     queue_num;
  gaspi_number_t     queue_size_max;
  gaspi_size_t       transfer_size_max;

  // notification parameter
  gaspi_number_t     notification_num;

  // passive comm parameter
  gaspi_number_t     passive_queue_size_max;
  gaspi_size_t       passive_transfer_size_max;

  // atomic counter parameter
  gaspi_number_t     counter_num;

  // collective comm parameter
  gaspi_number_t     allreduce_buf_size;
  gaspi_number_t     allreduce_elem_max;

  // network selection parameter
  gaspi_network_t    network_type;

  // communication infrastructure build up notification
  gaspi_bool_t       build_infrastructure

  void *             user_defined;

} gaspi_configuration_t;
\end{listing}

Please note, that for simplicity of notation this is a C-style
definition. In bindings to other languages corresponding definitions
will be used.

% \begin{todo}
% \item check how this works in fortran
% \end{todo}

The definition of each of the configuration structure fields is as follows:

\begin{description}
\item[group\_max] the desired number of maximally permissible groups. There is a hardware/implementation dependent maximum.
\item[segment\_max] the desired number of maximally permissible segments per \GASPI{} process.
There is a hardware/implementation dependent maximum.
\item[queue\_num] the desired number of one-sided communication queues to be created. There is a hardware/implementation
dependent maximum.
\item[queue\_size\_max] the desired number of simultaneously allowed on-going requests on a one-sided communication queue.
There is a hardware/implementation dependent maximum.
\item[transfer\_size\_max] the desired maximum size of a single data
  transfer in the one-sided communication channel.
There is a hardware/implementation dependent maximum.
\item[notification\_num] the desired number of internal notification buffers for weak synchronization to be created.
There is a hardware/implementation dependent maximum.
\item[passive\_queue\_size\_max] the desired number of simultaneously allowed on-going requests on the
passive communication queue. There is a hardware/implementation dependent maximum.
\item[passive\_transfer\_size\_max] the desired maximum size of a
  single data transfer in the passive communication channel.
There is a hardware/implementation dependent maximum.
\item[counter\_num] the desired number of atomic counters to be created.
There is a hardware/implementation dependent maximum.
\item[allreduce\_elem\_max] the maximum number of elements in \gaspifunction{allreduce}
There is a hardware/implementation dependent maximum.
\item[allreduce\_buf\_size] the size of the internal buffer of \gaspifunction{allreduce\_user}.
There is a hardware/implementation dependent maximum.
\item[network\_type] the network type to be used
\item[build\_infrastructure] boolean to set whether the communication infrastructure should
be build up at startup time. The default value is true.
%\item[param\_check] boolean to set whether a parameter check of the \GASPI{} routines is done
\item[user\_defined] some user defined information that is application / implementation dependent.
\end{description}

The default configuration structure can be retrieved by \gaspifunction{config\_get}.
% All fields of the default configuration structure are optional and do not need
% to be explicitly initialized.
Its default values are implementation dependent. If
some of the parameters are externally set by the program and committed with \gaspifunction{config\_set},
the requested values are just proposals.
Depending on the underlying hardware capabilities,
the implementation is allowed to overrule these proposals.
\gaspifunction{config\_set} has to be used in order to commit modifications
of the configuration structure before the initialization routine is invoked.
The actual values of the parameters can be retrieved by the corresponding \GASPI{}
getter routines (see section \ref{sec:getterfn}) after the successful program initialization. The values of the configuration
structure parameters need to be the same on all \GASPI{} processes.

The user has the possibility to set the values on her own or leave the
default values. Each field (where applicable) has also a maximum value
to avoid user errors that might lead to too much instability or
scalability problems (for example, the number of queues). The maximum
values applied will be the current GPI values.

\subsubsection{\gaspifunction{config\_get}}

The \gaspifunction{config\_get} procedure
is a \gaspisemantic{synchronous} \gaspisemantic{local}
\gaspisemantic{blocking} procedure which retrieves the
default configuration structure.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_config_get (gaspi_config_t config)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{config}{the default configuration}
\parameterlistend
\executionphasesetup
\FStdRetDescNOTimeout
\end{FDef}

After successful procedure completion, i.\,e.\ return value \GASPISUCC{},
\parameter{config} represents the default configuration.

In case of error, the return value is \GASPIGERR{}.

\subsubsection{\gaspifunction{config\_set}}

The \gaspifunction{config\_set} procedure
is a \gaspisemantic{synchronous} \gaspisemantic{local}
\gaspisemantic{blocking} procedure which sets the configuration
structure for process initialization.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_config_set (gaspi_config_t config)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{config}{the configuration structure to be set}
\parameterlistend
\executionphasesetup
\FStdRetDescNOTimeout
\end{FDef}

After successful procedure completion, i.\,e.\ return value \GASPISUCC{},
the runtime parameters for the \GASPI{} process initialization are set
in accordance with parameters of \parameter{config}

In case of error, the return value is \GASPIGERR{}.

\subsection{Process management calls}

\subsubsection{\gaspifunction{proc\_init}}

\gaspifunction{proc\_init} implements the \GASPI{} initialization
of the application. It is a \gaspisemantic{non-local} \gaspisemantic{synchronous}
\gaspisemantic{time-based blocking} procedure.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_proc_init (gaspi_timeout_t timeout)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{timeout}{the timeout.}
\parameterlistend
\executionphaseinit
\FStdRetDesc
\end{FDef}

The explicit start of a \GASPI{} process or launch from command line is
not specified. This is implementation dependent.

However, it is anticipated, that \gaspifunction{proc\_init} has information about the
list of hosts on which the entire \GASPI{} application is running either by environment
variables, a command line argument, a daemon or some other mechanism.
The actual transfer of knowledge is implementation dependent.

\gaspifunction{proc\_init} registers a given process at the other
remote \GASPI{} processes and sets the corresponding entry in the
state vector to a healthy state.
If the parameter \parameter{build\_infrastructure} in the configuration structure is set,
also the communication infrastructure for passive and one-sided communication to all
of the other processes is set up. Otherwise, there is no set up of communication infrastructure
during the initialization.
A rank is assigned to the given \GASPI{} process in accordance with the position of the host
in the list. The \GASPI{} process running on the first host in the list has rank zero. The
\GASPI{} process running on the second host in the list has rank one and so on.

In case of a node failure, a \GASPI{} process can be started on a new host, freshly allocated
or selected from a set of pre-allocated spare hosts,
by providing the list of machines in which the failed node is substituted by the new host.
The newly \GASPI{} process then has the rank of the \GASPI{} process which
has been running on the failed node.

In case of the subsequent start of additional \GASPI{} processes, the newly started
\GASPI{} process registers with the other remote \GASPI{} processes.
Note, that a subsequent change of the number of running
\GASPI{} processes invalidates \GASPIGROUPALL{} for the old running processes.
Also the return value of \gaspifunction{proc\_num} is changed.

%\begin{itemize}
%\item \GASPIGROUPALL{} is invalidated
%\item \gaspifunction{proc\_num} returns the new total number of ranks
%\end{itemize}

% The way how to specify the set of given hosts is implementation dependent.
% It follows the model of starting one process per host
% or one process per \emph{NUMA} socket. This choice can be configured by the
% application through the configuration structure that is passed to
% \gaspifunction{proc\_init}. There should be exactly one start call per \GASPI{}
% process and per \GASPI{} life cycle (c.\,f.\ \secref{SubSec:ExecPhases}).
% Otherwise, the behavior is undefined.

The configuration structure should be created by the application before passing
it to the \gaspifunction{proc\_init} procedure.

After successful procedure completion, \gaspifunction{proc\_init} returns
\GASPISUCC{} and it guarantees that the application has been started
on all hosts. In case that the \parameter{build\_infrastructure}
is set, return value \GASPISUCC{} also implies that the infrastructure is up and ready to be used.

% The parameters \parameter{argc} and \parameter{argv} are not
% forwarded to the remote binaries. In order to forwarded them the \parameter{command\_line}
% has to be set accordingly.

In case the operation could not be initialized in line with the timeout
parameter, the return value is \GASPITIME{}. The application is not initialized
yet. A subsequent invocation is required in order to completely initialize the application.

In case of error, the return value is \GASPIGERR{}. The application is not initialized.

In case of the return value \GASPITIME{} or \GASPIGERR{}, a check of the state vector
by invocation of \gaspifunction{state\_vec\_get} gives information about
whether the involved remote \GASPI{} processes are healthy or whether they
are corrupted.

% Because the
% initialization can fail for several causes....
% \color{red}\emph{ VIP (very important point): We
%   need to define this better so that is possible for the user to know
%   what was wrong!  Some possibilities
% \begin{itemize}
% \item one node is down
% \item network problem
% \begin{itemize}
% \item port occupied
% \item problem with Infiniband (as we've seen, wrong kernel, wrong version)
% \item external problem (filesystem)
% \end{itemize}
% \item whatever starts the application (daemon, implementation specific script) failed
% \item user-defined parameters
% \item wrong parameter (e.\,g.\ num queues = 0) but not check enabled
% \end{itemize}}
% \color{black}

\begin{implementoradvice}
Calling \gaspifunction{proc\_init} with an enabled parameter \parameter{build\_infrastructure} is semantically equivalent to
calling \gaspifunction{proc\_init} with a disabled parameter \parameter{build\_infrastructure} and subsequent calls to
\gaspifunction{connect} in which an all-to-all connection is established.
\end{implementoradvice}

\begin{useradvice}
For resource critical applications, it is recommended
to disable the parameter \parameter{build\_infrastructure} in the configuration structure.
\end{useradvice}

\begin{useradvice}
Adjusting the passed list of hosts yields the possibility to take into account the topology of
the network.
\end{useradvice}

\begin{useradvice}
A successful procedure completion does not mean that any communication or collective
operation can already be used. Connections might be needed to be established.
A segment has to be allocated for passive communication
capabilities. If one-sided communication is supposed to be used, than the segment has to
registered in addition. If collective operations are needed,  a group has to be created and
committed. Only global atomic operations are feasible right from the beginning.
\end{useradvice}


% \begin{implementoradvice}
% The start routine is a good point to establish the passive communication infrastructure.
% \end{implementoradvice}

% \subsubsection{\gaspifunction{substitute\_node}}
%
% Substitute node is a operation that starts a given \GASPI{} program on
% a given host and assigns the rank(s) which were running on the old host to that program.
% It is intended to be used in the recovery phase of a fault tolerant programs.
% It is a \gaspisemantic{synchronous} \gaspisemantic{non-local}
% \gaspisemantic{time-based blocking} procedure.
%
% \begin{FDef}
% \begin{FDefSign}
% \begin{verbatim}
% gaspi_return_t
% gaspi_substitute_node ( gaspi_configuration_t configuration
%                       , gaspi_hostname_t hostname_old
%                       , gaspi_hostname_t hostname_new
%                       , gaspi_timeout_t timeout
%                       )
% \end{verbatim}
% \end{FDefSign}
% \parameterlistbegin
% \parameterlistitem{in}{configuration}{configuration object with the desired
%   configuration options}
% \parameterlistitem{in}{hostname\_old}{the name of the host to be substituted}
% \parameterlistitem{in}{hostname\_new}{the name of the host which is going to substitute}
% \parameterlistitem{in}{timeout}{the timeout}
% \parameterlistend
% \executionphasework
% \FStdRetDesc
% \end{FDef}
%
% \gaspifunction{substitute\_node} invokes the startup of a \GASPI{} program
% in accordance with the \parameter{command\_line} of the \parameter{configuration}
% structure on the host \parameter{hostname\_new}.
%
% If the \parameter{numa\_splitting} is set, \gaspifunction{substitute\_node} starts
% one process per \NUMA{} socket. The affinity mask of the correspondent
% \GASPI{} process is restricted to the CPU set attached to this socket
% such that the eventually forked threads are automatically pinned to this
% socket. If the underlying hardware is not a \NUMA{} system, the \parameter{numa\_splitting}
% is ignored.
%
% If the \parameter{numa\_splitting} is not set, \gaspifunction{substitute\_node}
% starts only one process per node. The affinity mask of the correspondent \GASPI{}
% process is not restricted.
%
% The ranks which are assigned to the newly started \GASPI{} processes
% are the same as the ranks which were running on host \parameter{hostname\_old}.
% Therefore, it yields undefined behavior, if the hardware capabilites of node \parameter{hostname\_old}
% concerning \NUMA{} are different than the hardware capabilities of node \parameter{hostname\_new} or
% if the \parameter{numa\_splitting} passed to \gaspifunction{substitute\_node} differs from the one
% passed to \gaspifunction{proc\_init}.
%
% All \GASPI{} programs that were previously running on the node
% \parameter{hostname\_new} are terminated. It yields undefined behavior
% when \gaspifunction{substitute\_node} is called more than once with the
% same hostname on a global cluster wide level.
%
% After calling \gaspifunction{substitute\_node}, all groups which
% contained the substituted rank(s) are invalid and must be
% re-constructed. The same is true for the memory registrations
% which where committed to the substituted ranks.
%
% %%
%
% After a successful completion, \gaspifunction{substitute\_node} returns
% \GASPISUCC{} and it guarantees that the application has been started
% on the given node and that the infrastructure is up and ready to be used.
%
% All fields of the configuration structure are optional and do not need
% to be explicitly initialized. The default values are implementation dependent. If
% some of the parameters are externally set by the program, the requested
% values have to be considered as proposals.
% Depending on the underlying hardware capabilities,
% the implementation is allowed to overrule these proposals.
% The actual values of the parameters can be retrieved by the corresponding \GASPI{}
% routines after the successful program startup.
%
% In case the operation could not be initialized according to the timeout
% parameter, the return value is \GASPITIME{}.
%
% In case of error, the return value is \GASPIGERR{}.
%
% % In case of the return value \GASPITIME{} or \GASPIGERR{}, a check of the state vector
% % by invocation of \gaspifunction{state\_vec\_get} gives information
% % whether the involved remote \GASPI{} processes are healthy or whether they
% % are corrupted.
%

\subsubsection{\gaspifunction{proc\_num}}

The total number of \GASPI{} processes started, $P$ (c.\,f.\ \secref{sec::getrank}),
can be retrieved by \gaspifunction{proc\_num}.
This is a \gaspisemantic{local} \gaspisemantic{synchronous}
\gaspisemantic{blocking} procedure.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_proc_num (gaspi_rank_t proc_num)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{proc\_num}{the total number of \GASPI{} processes}
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}

If successful, the return value is \GASPISUCC{} and
\gaspifunction{proc\_num} retrieves the total number
of processes that have been initialized and places it in
the \parameter{rank\_num}.

In case of error, the return value is \GASPIGERR{} and the value of
\parameter{proc\_num} is undefined.

\subsubsection{\gaspifunction{proc\_rank}}
\label{sec::getrank}

A rank identifies a \GASPI{} process. The rank of a process is in the
interval $\left[0,P\right)$ where $P$ corresponds to the number
of started \GASPI{} processes. Each process has a unique rank associated with it.
The rank of the invoking \GASPI{} process can be
retrieved by \gaspifunction{proc\_rank}. It is a \gaspisemantic{local} \gaspisemantic{synchronous}
\gaspisemantic{blocking} procedure.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_proc_rank (gaspi_rank_t rank)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{rank}{the rank of the calling \GASPI{} process.}
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}

\gaspifunction{proc\_rank} retrieves, if successful, the rank of the calling
process, placing it in the parameter \parameter{rank} and
returning \GASPISUCC{}.

In case of error, the return value is \GASPIGERR{} and the value of
the \parameter{rank} is undefined.


\subsubsection{\gaspifunction{proc\_term}}
\label{sec:shutdown}
The shutdown procedure is a \gaspisemantic{synchronous} \gaspisemantic{local}
\gaspisemantic{time-based blocking} operation that releases resources
and performs the required clean\-up. There is no definition in the
specification of a verification of a healthy global state (i.\,e.\ all
processes terminated correctly).

After a shutdown call on a given \GASPI{} process, it is an undefined
behavior if another \GASPI{} process tries to use any non-local \GASPI{}
functionality involving that process{}.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_proc_term (gaspi_timeout_t timeout)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\FStdRetDesc
\end{FDef}

In case of successful procedure completion, i.\,e.\ return value
\GASPISUCC{}, the allocated \GASPI{} specific resources of the
invoking \GASPI{} process have been released. That means in particular,
that the communication infrastructure is shut down, all committed
groups are released and all allocated segments are freed.


In case of timeout, i.\,e.\ return value \GASPITIME{}, the local resources
of the invoking \GASPI{} process could not be completely released in the
given period of time. A subsequent invocation is required in order to
completely release all of the resources.

In case of error, i.\,e.\ return value \GASPIGERR{}, the resources of the
local \GASPI{} process could not be released. The process is in
an undefined state.


\subsubsection{\gaspifunction{proc\_kill}}

\gaspifunction{proc\_kill} sends a interrupt signal to a
given \GASPI{} process.
It is a \gaspisemantic{synchronous} \gaspisemantic{non-local}
\gaspisemantic{time-based blocking} procedure.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_proc_kill ( gaspi_rank_t rank
                , gaspi_timeout_t timeout
                )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{rank}{the rank of the process to be killed}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\executionphasework
\FStdRetDesc
\end{FDef}

\gaspifunction{proc\_kill} sends an interrupt signal to the \GASPI{} process
incorporating the rank given by parameter \parameter{rank}. This can be
used, for example, to realise the registration of a user defined signal handler
function which ensures the controlled shut down of an entire \GASPI{} application
at the global level
if the application receives an interrupt signal (\emph{STRG + C}) in the interactive master
process. Every \GASPI{} application should register such or a
similar signal handler (c.\,f.\ \listref{lst:signal}).

In case of successful procedure completion, i.\,e.\ return value \GASPISUCC,
the remote \GASPI{} process has been terminated.

In case of timeout, i.\,e.\ return value \GASPITIME, the remote \GASPI{}
process could not be terminated in the given time. A subsequent invocation
of the procedure is needed in order to complete the operation.

In case of error, i.\,e.\ return value \GASPIGERR, the state of the remote
\GASPI{} process is undefined.

\begin{useradvice}
The kill signal terminates a \GASPI{} process in an uncontrolled way.
In order to provide a clean shutdown in this case, it is advisable
to register a user defined signal callback function which guarantees
a clean shutdown.
\end{useradvice}

\subsubsection{Example}

\listref{lst:hello_world} shows a \GASPI{} "Hello world"
example. Please note that this program does not include any code that
is needed to deal with failures.

\insertlisting{../examples/hello_world.c}{\GASPI{} hello world example. \label{lst:hello_world}}

\listref{lst:signal} shows the registration of a user defined signal handler
function which ensures the controlled shut down of an entire \GASPI{} application
at the global level
if the application receives an interrupt signal (\emph{STRG + C}) in the interactive master
process. Every \GASPI{} application should register such or a
similar signal handler.

\insertlisting{../examples/signal_handler/signal.c}{Signal handling.\label{lst:signal}}



\subsection{Connection management utilities}

\subsubsection{\gaspifunction{connect}}

In order be able to communicate between two \GASPI{} processes, the communication
infrastructure has to be established. This is
achieved with the \gaspisemantic{synchronous} \gaspisemantic{non-local}
\gaspisemantic{time-based blocking} procedure \gaspifunction{connect}.
It is bound to the working phase of the \GASPI{} life cycle.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}

gaspi_return_t
gaspi_connect ( gaspi_rank_t rank
              , gaspi_timeout_t timeout
              )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{rank}{ the remote rank with which the communication infrastructure is established}
\parameterlistitem{in}{timeout}{The timeout for the operation}
\parameterlistend
\FStdRetDesc
\end{FDef}

\gaspifunction{connect} builds up the communication infrastructure, passive as well as
one-sided, between the local and the remote \GASPI{} process representing rank
\parameter{rank}. The connection is bi-directional, i.\,e.\ it is sufficient
if \gaspifunction{connect} is invoked by only one of the connection partners.
% The operation is a \gaspisemantic{collective} operation between
% the local \GASPI{} process and the remote \GASPI{} process, i.\,e.\ also the remote
% rank has to invoke a correspondent \gaspifunction{connect} call.

In case of successful procedure completion, i.\,e.\ return value \GASPISUCC,
the communication infrastructure is established. If there is
an allocated segment, the segment can be used as a destination for passive
communication between the two nodes. In case that the connection has been established already,
e.\,g.\ by the connection partner, the return value is \GASPISUCC{}.

In case of return value \GASPITIME, the communication infrastructure could not
be established between the local \GASPI{} process and the remote \GASPI{} process
in the given period of time.

In case of return value \GASPIGERR, the communication infrastructure could not
be established between the local \GASPI{} process and the remote \GASPI{} process.

In case of the latter two return values, a check of the state vector
by invocation of \gaspifunction{state\_vec\_get} gives information
whether the remote \GASPI{} process is still healthy.

% It is a failure, if the remote rank is in the connect with another
% rank. This might produce deadlocks. That means that subsequent connect
% requests have to be in the correct order on a clusterwide level.

\begin{useradvice}
Under the assumption that the \GASPI{} process is initialized with parameter
\parameter{build\_infrastructure} set to \emph{true}, all the
connections are set up at initialization time. Hence, a subsequent
call to \gaspifunction{connect} is superfluous in this case.
\end{useradvice}


\subsubsection{\gaspifunction{disconnect}}

The \gaspifunction{disconnect} procedure
is a \gaspisemantic{synchronous} \gaspisemantic{local}
\gaspisemantic{blocking} procedure which disconnects a given
a given group and frees all associated ressources.

It is bound to the working phase of the \GASPI{} life cycle.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_disconnect ( gaspi_rank_t rank
                 , gaspi_timeout_t timeout
                 )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{rank}{ the remote rank from which the communication infrastructure is disconnected}
\parameterlistitem{in}{timeout}{The timeout for the operation}
\parameterlistend
\FStdRetDesc
\end{FDef}

\gaspifunction{disconnect} disconnects the communication infrastructure, passive as well as
one-sided, between the local and the remote \GASPI{} process representing rank
\parameter{rank}. The connection is bi-directional, i.\,e.\ it is sufficient
if \gaspifunction{disconnect} is invoked by only one of the connection partners.

In case of successful procedure completion, i.\,e.\ return value \GASPISUCC,
the communication infrastructure is disconnected. Associated resources are freed.
In case that the connection has been disconnected already,
e.\,g.\ by the connection partner, the return value is \GASPISUCC{}.

In case of error the return value is \GASPIGERR{}.

In case of return value \GASPITIME, the connection between the local \GASPI{} process and
the remote \GASPI{} process could not be disconnected in the given period of time.

In case of the latter two return values local resources are freed and a check of the state vector
by invocation of \gaspifunction{state\_vec\_get} gives information
whether the remote \GASPI{} process is still healthy.

After successful procedure completion, i.\,e.\ return value \GASPISUCC{},
the connection is disconnected and can no longer be used.


\subsection{State vector for individual processes}

\subsubsection{Introduction}

A necessary pre-condition for realising a failure tolerant code is a detailed
knowledge about the state of the communication partners of each local
\GASPI{} process.

\GASPI{} provides a predefined type to describe the state of a remote \GASPI{} process,
which is the \gaspitype{state} type

\begin{listing}[99]{2}
typedef enum { GASPI_STATE_HEALTHY = 0
             , GASPI_STATE_CORRUPT = 1
             } gaspi_state_t;
\end{listing}

GASPI\_STATE\_HEALTHY implies that the remote \GASPI{} process is healthy, i.\,e.\
communication is possible. GASPI\_STATE\_CORRUPT means that the remote \GASPI{}
process is corrupted, i.\,e.\ there is no communication possible.

\begin{TDef}
\TDefDefn{{\tt vector<\gaspitype{state}>}}{\gaspitype{state\_vector}}
\TDefDesc{The vector with state information for individual processes. The
  length of the vector equals the number of processes in the \GASPI{}
  program.}
\end{TDef}

There are procedures to inquire about the state of the communication partners
after a given communication request and also to reset the state after
successful recovery. These are described in the following sub sections.

\subsubsection{\gaspifunction{state\_vec\_get}}

The state vector is obtained by the \gaspisemantic{local} \gaspisemantic{synchronous}
\gaspisemantic{blocking} function \gaspifunction{state\_vec\_get}.

The state vector represents the states of all \GASPI{} processes.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_state_vec_get (gaspi_state_vector_t state_vector)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{returns}{the vector with individual return codes}
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}

The state vector has one entry for each rank. It is initialized during
\gaspifunction{proc\_init}. It is updated after each of the following operations

\begin{itemize}
 \item process management
   \begin{itemize}
     \item \gaspifunction{proc\_init}
   \end{itemize}
\item group creation
  \begin{itemize}
    \item \gaspifunction{group\_commit}
  \end{itemize}
\item segment creation
  \begin{itemize}
    \item \gaspifunction{segment\_register}
  \end{itemize}
\item one-sided communication
  \begin{itemize}
    \item \gaspifunction{wait}
  \end{itemize}
\item passive communication
  \begin{itemize}
    \item \gaspifunction{passive\_wait}
  \end{itemize}
\item collective operations
  \begin{itemize}
    \item \gaspifunction{barrier}
    \item \gaspifunction{allreduce}
    \item \gaspifunction{allreduce\_user}
  \end{itemize}
\item global atomic counters
  \begin{itemize}
    \item \gaspifunction{counter\_set}
    \item \gaspifunction{counter\_fetch\_and\_add}
    \item \gaspifunction{counter\_compare\_swap}
  \end{itemize}
\end{itemize}

\gaspifunction{state\_vec\_get} retrieves in case of successful completion, i.\,e.\ return
value \GASPISUCC, the state vector.
It contains the states of the \GASPI{} processes with which the local process has been
communicating. All other entries are unmodified.

The internal operation to update the state vector is a logic "or".

In case of error, the return value is \GASPIGERR{} and the value of
the state vector is undefined.

\begin{useradvice}
For failure tolerant code, the state vector should be checked after each of the above
procedure calls in case that they return with return value \GASPIGERR{} or \GASPITIME{}.
\end{useradvice}

%\subsubsection{\gaspifunction{state\_vec\_reset}}
%
%After successful state recovery, it is desirable to reset the
%state vector to a global healthy state. This is achieved by the
%\gaspisemantic{local} \gaspisemantic{synchronous}
%\gaspisemantic{blocking} function \gaspifunction{state\_vec\_get}.
%
%\begin{FDef}
%\begin{FDefSign}
%\begin{verbatim}
%gaspi_return_t
%gaspi_state_vec_reset ()
%\end{verbatim}
%\end{FDefSign}
%\executionphasework
%\FStdRetDescNOTimeout
%\end{FDef}
%
%In case of successful completion, i.\,e.\ return
%value \GASPISUCC, the state vector is reset to GASPI\_STATE\_HEALTHY for all of the processes.
%
%In case of error, the return value is \GASPIGERR{} and the state vector is undefined.

%\subsubsection{Example}

%\subsection{Interaction with signals}

\subsection{MPI Interoperability}

\GASPI{} aims at providing interoperability with MPI in order to allow
for incremental porting of such applications.

The Start-up of mixed MPI and \GASPI{} code is achieved by invoking
\gaspifunction{proc\_init} in an existing MPI program.
This way, MPI takes care of distributing and starting the binary and
\GASPI{} just takes care of setting up its internal infrastructure.

%\begin{todo}
%\item There might be conflicts with on-the-fly-pinning of MPI. This
%  needs to be tested
%\end{todo}

\GASPI{} and MPI communication should not occur at the same time, i.\,e.\
only the program layout given in listing \ref{lst:embedded_gaspi} is supported

\insertlisting{../examples/mpi.interop.c}{Embedded \GASPI{} program\label{lst:embedded_gaspi}}

\subsection{Argument checks and performance}

\GASPI{} aims at high performance and does not provide any argument checks
at procedure invocation per default.

\begin{implementoradvice}
The implementation should provide a specific library which includes
argument checks. The \GASPI{} procedures should include out of bounds
checks, there.
\end{implementoradvice}


% \begin{useradvice}
% During production runs, the checking library should not be utilized.
% Otherwise, performance impacts have to be accepted. This parameter should
% only be set in debugging mode.
% \end{useradvice}

\section{Groups}

\subsection{Introduction}

Groups are sub-sets of the total number of \GASPI{} processes. The group members
have common collective operations.  Each \GASPI{} process may participate in more
than one group.

The use-cases are the collective operations provided in \secref{sec:collectives}
that make sense to be performed only for a subset of \GASPI{} processes
in order to avoid a complete (all processes) collective synchronization
point.

A group has to be defined and declared in each of the participating
\GASPI{} processes. Defining a group is a two step procedure.
An empty group has to be created first. Then the participating \GASPI{}
processes, represented by their ranks, have to be attached. The group
definition is a local operation.  In order to activate the group, the
group has to be committed by each of the participating \GASPI{}
processes. This is a collective operation for the group. Only after
successful group commitment, the group can be used for collective
operations.

The maximum number of groups allowed per \GASPI{} process is restricted by the
implementation. A desired value can be passed to \gaspifunction{proc\_init} by
the configuration structure.

In case of a failure in which one of the \GASPI{} processes
included within a given group disappears, the group has to be
reestablished. If there is a new process replacing the failed one, the
group has to be defined and declared on the newly started \GASPI{}
process(es).  Reestablishment of the group is then achieved by
recommitment of the group by the \GASPI{} processes which were still
'alive' (functioning) and by the commitment of the group by the newly started \GASPI{}
process.

\subsection{\GASPI{} group generics}

\subsubsection{\GASPI{} group type}

Groups are specified with a special group type \verb|gaspi_group_t|.

\subsubsection{\GASPIGROUPALL{}}

\GASPIGROUPALL{} is a predefined default group that corresponds
to the whole set of \GASPI{} processes. This is to be used for collective
operations that work for the whole system.

\begin{listing}[99]{2}
gaspi_group_t GASPI_GROUP_ALL;
\end{listing}

\begin{useradvice}
Note that \GASPIGROUPALL{} is a group definition like any other
sub group. In order to be used, \GASPIGROUPALL{} also has to be committed
by \gaspifunction{group\_commit}.
\end{useradvice}

\subsection{Group creation}

\subsubsection{\gaspifunction{group\_create}}

The \gaspifunction{group\_create} procedure
is a \gaspisemantic{synchronous} \gaspisemantic{local}
\gaspisemantic{blocking} procedure which creates
an empty group.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_group_create (gaspi_group_t group)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{group}{the created empty group}
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}

After successful procedure completion, i.\,e.\ return value \GASPISUCC{},
\parameter{group} represents an empty group without any members.

In case of error, the return value is \GASPIGERR{}.

\subsubsection{\gaspifunction{group\_add}}

The \gaspifunction{group\_add} procedure
is a \gaspisemantic{synchronous} \gaspisemantic{local}
\gaspisemantic{blocking} procedure which adds
a given rank to an existing group.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_group_add ( gaspi_group_t group
                , gaspi_rank_t rank
                )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{inout}{group}{the group to which the rank is added}
\parameterlistitem{in}{rank}{the absolute rank to add to the group}
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}

After successful procedure completion, i.\,e.\ return value \GASPISUCC{},
the \GASPI{} process with \parameter{rank} is added to \parameter{group}.

In case of error, the return value is \GASPIGERR{}.

\subsubsection{\gaspifunction{group\_commit}}

The \gaspifunction{group\_commit} procedure is a
\gaspisemantic{synchronous} \gaspisemantic{collective}
\gaspisemantic{time-based blocking} procedure which establishes a
group.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_group_commit ( gaspi_group_t group
                   , gaspi_timeout_t timeout
                   )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{group}{the group to commit}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\executionphasework
\FStdRetDesc
\end{FDef}

After successful procedure completion, i.\,e.\ return value \GASPISUCC{},
the group given by the parameter \parameter{group} is
established. Collective operations invoked by the members of the group
are allowed from this moment on.

In case of timeout, i.\,e.\ return value \GASPITIME{}, the group could not be
established on all ranks forming the group in the given period of time.
The group is in an undefined state and collective operations  on
the group yield undefined behavior. A subsequent invocation is
required in order to completely establish the group.

In case of error, i.\,e.\ return value \GASPIGERR{}, the group could not be
established. The group is in an undefined state and collective operations
defined on the given group yield undefined behavior.

In both cases, \GASPITIME{} and \GASPIGERR{}, the \GASPI{} state vector
should be checked in order to eliminate the possibility of a failure.

\begin{useradvice}
A specific group commit should be performed only by a single thread of a process.
If two \GASPI{} processes are members of two groups, then the
order of the group commits should be the same on both processes in
order to avoid deadlocks.
\end{useradvice}

\begin{implementoradvice}
If the parameter  \parameter{build\_infrastructure} is not set, the procedure \gaspifunction{group\_commit} must set up
the infrastructure for all possible operations of the group.
\end{implementoradvice}

\subsection{Group deletion}

\subsubsection{\gaspifunction{group\_delete}}

The \gaspifunction{group\_delete} procedure
is a \gaspisemantic{synchronous} \gaspisemantic{local}
\gaspisemantic{blocking} procedure which deletes
a given group.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_group_delete (gaspi_group_t group)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{group}{the group to be deleted}
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}

After successful procedure completion, i.\,e.\ return value \GASPISUCC{},
\parameter{group} is deleted and cannot be used further.

In case of error, the return value is \GASPIGERR{}.

\begin{implementoradvice}
If the parameter \parameter{build\_infrastructure} is not set, the procedure \gaspifunction{group\_delete} must disconnect
all connections which have been set up in the call to \gaspifunction{group\_commit} and free all
associated resources.
\end{implementoradvice}


\subsection{Group utilities}

\subsubsection{\gaspifunction{group\_num}}

The \gaspifunction{group\_num} procedure
is a \gaspisemantic{synchronous} \gaspisemantic{local}
\gaspisemantic{blocking} procedure which returns
the current number of allocated groups.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_group_num (gaspi_number_t group_num)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
  \parameterlistitem{out}{group\_num}{the current number of groups}
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}

After successful procedure completion, i.\,e.\ return value \GASPISUCC{},
\parameter{group\_num} contains the current number of allocated groups. The value of \parameter{group\_num} is related to the parameter
\parameter{group\_max} in the configuration structure and cannot exceed that value. The value can be implementation specific.


\subsubsection{\gaspifunction{group\_size}}

The \gaspifunction{group\_size} procedure
is a \gaspisemantic{synchronous} \gaspisemantic{local}
\gaspisemantic{blocking} procedure which returns
the number of ranks of a given group.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_group_size ( gaspi_group_t group
                 , gaspi_rank_t group_size
                 )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
  \parameterlistitem{out}{group}{the group to be examined}
  \parameterlistitem{out}{group\_size}{the number of ranks in a given group}
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}

After successful procedure completion, i.\,e.\ return value \GASPISUCC{},
\parameter{group\_size} contains the number of \GASPI{} processes forming
the \parameter{group}.

In case of error, the return value is \GASPIGERR{}. The parameter
\parameter{group\_size} has an undefined value.

\subsubsection{\gaspifunction{group\_ranks}}

The \gaspifunction{group\_ranks} procedure
is a \gaspisemantic{synchronous} \gaspisemantic{local}
\gaspisemantic{blocking} procedure which returns
a list of ranks of \GASPI{} processes forming the group.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_group_ranks ( gaspi_group_t group
                  , gaspi_rank_t  group_ranks[group_size]
                  )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
  \parameterlistitem{in}{group}{the group to be examined}
  \parameterlistitem{out}{group\_ranks}{the list of ranks forming the group}
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}

After successful procedure completion, i.\,e.\ return value \GASPISUCC{},
the list \parameter{group\_ranks} contains the list of ranks forming the
\parameter{group}. The list is not allocated by the procedure. The
list allocation is supposed to be done outside of the procedure.
The size of the list can be inquired by \gaspifunction{group\_size}.

In case of error, the return value is \GASPIGERR{}. The list
\parameter{group\_ranks} has an undefined value.

\section{\GASPI{} segments}

\subsection{Introduction and overview}

Modern hardware has an entire memory hierarchy concerning the
bandwidth and latencies of read and write accesses. Among them are
non-uniform memory access (\emph{NUMA}) partitions, solid state
devices (\emph{SSD}s), graphical processing unit (\emph{GPU}) memory
or many integrated cores (\emph{MIC}) memory.

The \GASPI{} memory segments are thus an abstraction that represents
any kind of memory level, mapping the variety of hardware layers to the
software layer. A segment is a contiguous block of virtual memory.
In the spirit of the PGAS approach, these \GASPI{}
segments may be globally accessible from every thread of every \GASPI{}
process and represent the partitions of the global address space.

By means of the \GASPI{} memory segments it is also possible for multiple
memory models or indeed multiple applications to share a single Partitioned Global
Address Space.

Since segment allocation is expensive and the total number of supported
segments is limited due to hardware constraints, the \GASPI{} memory
management paradigm is the following.
\GASPI{} provides only a few relatively large segments.
Allocations inside of the pre-allocated segment memory are managed
by the application.

Every \GASPI{} process may possess a certain number of segments (not necessarily equal to the number in the other ranks) that may be accessed as common memory,
whether is local---with normal memory operations---or remote---with
the communication routines of \GASPI{}.

In order to use a segment for communication between two processes,
some setup steps are required in general.

A memory segment has to be allocated in each of the processes
by the \gaspisemantic{local} procedure \gaspifunction{segment\_alloc}.
In order to also use the segments for one-sided communication, the memory segment
has to be registered on the remote process which will
access the memory segment at some point. This is achieved by the
\gaspisemantic{non-local} procedure \gaspifunction{segment\_register}.

\begin{useradvice}
  If the parameter \parameter{build\_infrastructure} is not set, a
  connection has to be established between the processes before the
  segment can be registered at the remote process. This is
  accomplished by calling the procedure \gaspifunction{connect}.
\end{useradvice}

\gaspifunction{segment\_create} unites these steps into a single
\gaspisemantic{collective} procedure for an entire group. After successful
procedure completion, a common segment is created on each \GASPI{}
process forming the group which can be immediately used for communication
among the group members.

During the lifetime of an application there is no segment available
unless it is explicitly created with \gaspifunction{segment\_alloc}
or \gaspifunction{segment\_create} after the \GASPI{} start-up.

\subsection{Segment creation}

\subsubsection{\gaspifunction{segment\_alloc}}

The \gaspisemantic{synchronous} \gaspisemantic{local}
\gaspisemantic{blocking} procedure \gaspifunction{segment\_alloc}
allocates a memory segment and optionally maps it in accordance with a
given allocation policy.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_segment_alloc ( gaspi_segment_id_t segment_id
                    , gaspi_size_t size
                    , gaspi_alloc_t alloc_policy
                    )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{segment\_id}{ The segment ID to be created. The segment ID's need to be
                                     unique for each \GASPI{} process}
\parameterlistitem{in}{size}{The size of the segment in bytes}
\parameterlistitem{opt}{alloc\_policy}{optional parameter characterizing the allocation policy}
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}

\gaspifunction{segment\_alloc} allocates a segment of
size \parameter{size} that will be referenced by
the \parameter{segment\_id} identifier. This identifier parameter has
to be unique in the local \GASPI{} process. Creating a new segment
with an existing segment ID results in undefined behavior. Note that
the total number of segments is restricted by the underlying hardware
capabilities. The maximum number of supported segments can be
retrieved by invoking \gaspifunction{segment\_max}.  The procedure has
an optional parameter which might be used to pass an allocation
policy. This is left to the implementation.

After successful procedure completion, i.\,e.\ return value \GASPISUCC{},
the segment can be accessed locally.
In case that there is a connection established to a remote \GASPI{} process,
it can also be used for passive communication between the two \GASPI{} processes.
(Note that this is always the case if the process has been initialized
with the parameter \parameter{build\_infrastructure} set to \emph{true}),
it can also be used for passive communication between the two \GASPI{} processes;
either as a source segment for \gaspifunction{passive\_send} or as a
destination segment for \gaspifunction{passive\_receive}.

A return value \GASPIGERR{} indicates that the segment allocation failed.
The segment cannot be used locally or for passive communication.

\begin{implementoradvice}
In case of non-uniform memory access architectures, the memory should be allocated
close to the calling process. The allocation policy of the calling process should
not be modified.
\end{implementoradvice}

\subsubsection{\gaspifunction{segment\_register}}

In order to be used in a one-sided communication request on an existing connection,
a segment allocated by \gaspifunction{segment\_alloc} needs to be made visible and
accessible for the other \GASPI{} processes.
This is accomplished by the procedure \gaspifunction{segment\_register}.
It is a \gaspisemantic{synchronous} \gaspisemantic{non-local}
\gaspisemantic{time-based blocking} procedure.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_segment_register ( gaspi_segment_id_t segment_id
                       , gaspi_rank_t rank
                       , gaspi_timeout_t timeout
                       )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{segment\_id}{ The segment ID to be registered. The segment ID's need to be
                                     unique for each \GASPI{} process}
\parameterlistitem{in}{rank}{The rank of the \GASPI{} process which should register the new segment}
\parameterlistitem{in}{timeout}{The timeout for the operation}
\parameterlistend
\executionphasework
\FStdRetDesc
\end{FDef}

\gaspifunction{segment\_register} makes the segment referenced by
the \parameter{segment\_id} identifier visible and accessible to
the \GASPI{} process with the associated \parameter{rank}.


\begin{useradvice}
If the parameter \parameter{build\_infrastructure} is not set, a connection has to be established between the processes before the segment can be registered at the remote process. This is accomplished calling the procedure \gaspifunction{connect}.
\end{useradvice}


In case of successful procedure completion, i.\,e.\ return value \GASPISUCC,
the local segment can be used for one-sided communication requests which are
invoked by the given remote process.

% \begin{todo}
% \item Registering a segment without having
% established a connection between
% the local \GASPI{} process and the remote \GASPI{} process owning
% rank \parameter{rank}
% allocated the segment before
% yields undefined behavior. \emph{Daniel: I think this paragraph is not necessary}
% \end{todo}

In case of return value \GASPITIME{}, the segment could not be registered
in the given period of time. The segment cannot be used for one-sided
communication requests which are invoked by the given remote process.
A subsequent call of \gaspifunction{segment\_register} has to be
invoked in order to complete the registration request.

In case of return value \GASPIGERR{}, the segment could not be registered
on the remote side. The segment cannot be used for one-sided communication
requests which are invoked by the given remote process.

In case of the latter two return values, a check of the state vector
by invocation of \gaspifunction{state\_vec\_get} gives information as to
whether or not the remote \GASPI{} process is still healthy.

\begin{useradvice}
Note that a local return value \GASPISUCC{} does not imply that the remote process
is informed explicitly that the segment is accessible. This can be achieved through an explicit
synchronization, either by one of the collective operations or by an explicit notification.
\end{useradvice}

\subsubsection{\gaspifunction{segment\_create}}

\gaspifunction{segment\_create} is a \gaspisemantic{synchronous} \gaspisemantic{collective}
\gaspisemantic{time-based blocking} procedure. It is semantically equivalent to a collective
aggregation of
\gaspifunction{segment\_alloc}, \gaspifunction{segment\_register} and \gaspifunction{barrier}
involving all of the members of a
given group.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_segment_create ( gaspi_segment_id_t segment_id
                     , gaspi_size_t size
                     , gaspi_group_t group
                     , gaspi_timeout_t timeout
                     , gaspi_number_t alloc_policy
                     )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{segment\_id}{The segment ID to be created. The segment ID's need to be
      unique for each \GASPI{} process}
\parameterlistitem{in}{size}{The size of the segment in bytes}
\parameterlistitem{in}{group}{The group which should create the segment}
\parameterlistitem{in}{timeout}{The timeout for the operation}
\parameterlistitem{opt}{alloc\_policy}{optional parameter characterizing the allocation policy}
\parameterlistend
\executionphasework
\FStdRetDesc
\end{FDef}


\gaspifunction{segment\_create} allocates a segment of
size \parameter{size} that will be referenced by
the \parameter{segment\_id} identifier. This identifier parameter has
to be unique on the local \GASPI{} process. Creating a new segment with
an existing segment ID results in undefined behavior.
\gaspifunction{segment\_create} makes the segment
referenced by the \parameter{segment\_id} identifier visible and accessible to
all of the \GASPI{} processes forming the group \parameter{group}.
The maximum number of supported segments can be retrieved
by invoking \gaspifunction{segment\_max}.
The procedure has an optional parameter which might be used to
pass an allocation policy. This is left to the implementation.

After successful procedure completion, i.\,e.\ \GASPISUCC{}, the segment can be accessed locally
and it can be used as a destination for the passive communication channel. Either as a source
segment for \gaspifunction{passive\_send} or as a
destination segment for \gaspifunction{passive\_receive}.
Furthermore, it can be used for one-sided communication requests, which are
invoked by the remote processes forming the group \parameter{group}.
The segment \parameter{segment\_id} is ready to be used.

For consistency and programs with hard failure tolerance requirements,
the operation must be performed within \parameter{timeout}
milliseconds.
In case of return value \GASPITIME{}, progress has been achieved, however the operation
could not be completed in the given timeout.
%
%Progress is achieved along the following steps
%\begin{itemize}
%\item establishing the connection
%\item local allocation
%\item \emph{RDMA} pinning
%\item registration of the segment on all the remote ranks of the group
%\item synchronization by a barrier
%\end{itemize}
The segment cannot be used locally or for passive communication. Furthermore,
the segment cannot be used for one-sided
communication requests which are invoked by the other remote processes forming the group.
A subsequent call of \gaspifunction{segment\_create} has to be
invoked in order to complete the segment creation.

In case of return value \GASPIGERR{}, the segment creation failed in one of the above progress
steps on at least one of the involved \GASPI{} processes. The segment cannot be used locally or
for passive communication. Furthermore, the segment cannot be used for one-sided
communication requests which are invoked by the other remote processes forming the group.

In case of the latter two return values, a check of the state vector
by invocation of \gaspifunction{state\_vec\_get} gives information
whether the involved remote \GASPI{} processes are still healthy.

\begin{implementoradvice}
In case of non-uniform memory access architectures, the memory should be allocated
close to the calling process. The allocation policy of the calling process should
not be modified.
\end{implementoradvice}

\subsection{Segment deletion}

\subsubsection{\gaspifunction{segment\_delete}}

The \gaspisemantic{synchronous} \gaspisemantic{local}
\gaspisemantic{blocking} procedure \gaspifunction{segment\_delete}
releases the resources of a previously allocated memory segment.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_segment_delete (gaspi_segment_id_t segment_id)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{segment\_id}{ The segment ID to be deleted. }
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}

\gaspifunction{segment\_delete} releases the resources of the segment
which is referenced by the \parameter{segment\_id} identifier.

After successful procedure completion, i.\,e.\ return value \GASPISUCC{},
the segment is deleted and the resources are released. It would be an
application error to use the segment for communication
between two \GASPI{} processes after \gaspifunction{delete} has been called.

In case of return value \GASPIGERR{}, the segment deletion failed. The segment
is in an undefined state. It cannot be used locally or
for passive communication. Furthermore, the segment cannot be used for one-sided
communication requests which are invoked by other remote processes.

% \subsubsection{\gaspifunction{segment\_deregister}}
%
% In order to be used in a one-sided communication request, a segment allocated
% by \gaspifunction{segment\_alloc} needs to be made visible and accessible for
% the other \GASPI{} processes after a connection has been established with \gaspifunction{connect}.
% This is accomplished by the procedure \gaspifunction{segment\_deregister}.
% It is a \gaspisemantic{synchronous} \gaspisemantic{non-local}
% \gaspisemantic{time-based blocking} procedure.
%
% \begin{FDef}
% \begin{FDefSign}
% \begin{verbatim}
% gaspi_return_t
% gaspi_segment_deregister ( gaspi_segment_id_t segment_id
%                          , gaspi_rank_t rank
%                          , gaspi_timeout_t timeout
%                          )
% \end{verbatim}
% \end{FDefSign}
% \parameterlistbegin
% \parameterlistitem{in}{segment\_id}{ The segment ID to be de-registered.}
% \parameterlistitem{in}{rank}{The rank of the \GASPI{} process which should deregister the segment}
% \parameterlistitem{in}{timeout}{The timeout for the operation}
% \parameterlistend
% \executionphasework
% \FStdRetDesc
% \end{FDef}
%
% \gaspifunction{segment\_deregister} makes the segment referenced by
% the \parameter{segment\_id} identifier visible and accessible to
% the \GASPI{} process with the associated \parameter{rank} after a connection
% has been established with \gaspifunction{connect}.
%
% In case of successful procedure completion, i.\,e.\ return value \GASPISUCC,
% the local segment can be used for one-sided communication requests, which are
% invoked by the given remote process.
%
% Registering a segment without having established a connection between
% the local \GASPI{} process and the remote \GASPI{} process owning
% rank \parameter{rank} yields undefined behavior.
%
% In case of return value \GASPITIME, the segment could not be registered
% in the given period of time.
%
% In case of return value \GASPIGERR, the segment could not be registered
% on the remote side.
%
% In case of the latter two return values, a check of the state vector
% by invocation of \gaspifunction{state\_vec\_get} gives information
% whether the remote \GASPI{} process is still healthy.
%
% \begin{useradvice}
% Note that a local return value \GASPISUCC{} does not imply that the remote process
% is informed explicitly that the segment is accessible. This can be achieved through an explicit
% synchronization, either by one of the collective operations or by an explicit notification.
% \end{useradvice}
%
% \subsubsection{\gaspifunction{segment\_delete}}
%
% \gaspifunction{segment\_delete} is a \gaspisemantic{synchronous} \gaspisemantic{collective}
% \gaspisemantic{time-based blocking} procedure. It is collective shortcut to \gaspifunction{connect},
% \gaspifunction{segment\_alloc}, \gaspifunction{segment\_register} and \gaspifunction{barrier}
% involving all of the members of a
% given group.
%
% \begin{FDef}
% \begin{FDefSign}
% \begin{verbatim}
% gaspi_return_t
% gaspi_segment_delete ( gaspi_segment_id_t segment_id
%                      , gaspi_group_t group
%                      , gaspi_timeout_t timeout
%                      )
% \end{verbatim}
% \end{FDefSign}
% \parameterlistbegin
% \parameterlistitem{in}{segment\_id}{The segment ID to be deleted.}
% \parameterlistitem{in}{group}{The group which should create the segment}
% \parameterlistitem{in}{timeout}{The timeout for the operation}
% \parameterlistend
% \executionphasework
% \FStdRetDesc
% \end{FDef}
%
%
% \gaspifunction{segment\_delete} deletes and deregister the segment that is referenced by
% the \parameter{segment\_id} identifier. \gaspifunction{segment\_delete} makes the segment
% referenced by the \parameter{segment\_id} identifier visible and accessible to
% all of the \GASPI{} processes forming the group \parameter{group}.
%
% Creating a new segment with an existing segment ID results in
% undefined behavior.
%
% After successful procedure completion, i.\,e.\ \GASPISUCC{}, the segment can be accessed locally
% and it can be used as a destination for the passive communicatie channel
% (\gaspifunction{passive\_receive}). Furthermore, it can be used for one-sided communication requests, which are
% invoked by the remote processes forming the group \parameter{group}.
% The segment \parameter{segment\_id} is ready to be used.
%
% For consistency and programs with hard failure tolerance requirements,
% the operation must be performed within \parameter{timeout}
% milliseconds.
%
% In case of return value \GASPITIME, progress has been achieved, however the operation
% could not be completed in the given timeout.
%
% Progress is achieved along the following steps
%
% \begin{itemize}
% \item local deallocation
% \item de-registration of the segment on all the remote ranks of the group
% \item synchronization by a barrier
% \end{itemize}
%
% In case of return value \GASPIGERR, the segment deletion failed in one of the above progress
% steps.
%
% In case of the latter two return values, a check of the state vector
% by invocation of \gaspifunction{state\_vec\_get} gives information
% whether the involved remote \GASPI{} processes are still healthy.

\subsection{Segment utilities}

\subsubsection{\gaspifunction{segment\_num}}

The \gaspifunction{segment\_num} procedure
is a \gaspisemantic{synchronous} \gaspisemantic{local}
\gaspisemantic{blocking} procedure which returns
the current number of allocated segments.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_segment_num (gaspi_segment_id_t segment_num)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
  \parameterlistitem{out}{segment\_num}{the current number of allocated segments}
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}

After successful procedure completion, i.\,e.\ return value \GASPISUCC{},
\parameter{segment\_num} contains the current number of allocated segments provided
by \GASPI{}. The value of \parameter{segment\_num} is related to the parameter
\parameter{segment\_max} in the configuration structure which is retrieved by \gaspifunction{proc\_init} at
startup and cannot exceed that value. The value might be implementation
specific.

In case of error, the return value is \GASPIGERR{}. The parameter
\parameter{segment\_num} has an undefined value.

\subsubsection{\gaspifunction{segment\_ptr}}

Segments are identified by a unique ID. This ID can be used to obtain
the virtual address of that local segment of memory. The procedure
\gaspifunction{segment\_ptr} returns the pointer to the segment
represented by a given segment ID. It is a \gaspisemantic{synchronous}
\gaspisemantic{local} \gaspisemantic{blocking} procedure.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_segment_ptr ( gaspi_segment_id_t segment_id
                  , gaspi_pointer_t pointer
                  )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{segment\_id}{The segment ID.}
\parameterlistitem{out}{pointer}{The pointer to the memory segment.}
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}

After successful procedure completion, i.\,e.\ \GASPISUCC{}, the output parameter
\parameter{pointer} contains the virtual address pointer of the memory
identified by \parameter{segment\_id}. This \gaspitype{pointer} can
then be used to reference the segment and perform memory operations.

In case of return value \GASPIGERR{}, the translation of the segment ID
to a pointer to a virtual memory address failed. The pointer contains
an undefined value and cannot be used to reference the segment.

\subsection{Segment memory management}

Each thread of a process may have global read or write access to all of
the segments provided by remote \GASPI{} processes if there
is a connection established between the processes and if the
respective segments have been registered on the local process.

% \subsubsection{Introduction and overview}
Since a segment is an entire contiguous block of virtual memory,
allocations inside of the pre-allocated segment memory need to be
managed.

\GASPI{} does not provide dedicated memory management functionality
for the local segments. This is left to the application.
High performance is the guiding principle of \GASPI{}.
A good problem-related implementation of a memory management is always better
than any predefined implementation. A default implementation cannot
include knowledge about the specific problem.

\gaspisemantic{Local} and \gaspisemantic{non-local} \GASPI{} procedures
specify in general memory addresses within the global partitioned address space by
the triple consisting of a rank, a segment identifier and
an offset.  This prevents a global all-to-all distribution of memory
addresses, since memory addresses of memory segments could be and
normally are different on different \GASPI{} processes.

A local buffer is specified by the pair \parameter{segment\_id}, \parameter{offset}.
The rank parameter is superfluous since it can be derived from the rank of the local \GASPI{} process.
The buffer  is located at address
\begin{equation}
\mbox{buffer\_address} = \mbox{base\_addr}\left(\, \mbox{segment\_id} \,\right) + \mbox{offset} \nonumber
\end{equation}
where $\mbox{base\_addr}(\, \mbox{segment\_id} \,)$ is the base address of the segment with identifier
\parameter{segment\_id}.
It can be obtained by applying \gaspifunction{segment\_ptr} on the local process.

A remote buffer is specified by the triple \parameter{remote\_rank}, \parameter{remote\_segment\_id},
\parameter{remote\_offset}.
The address of the remote  buffer can be calculated analogously to the local buffer. The only
difference is the determination of the base address. Here, it is the address
which would be obtained by invoking \gaspifunction{segment\_ptr}
on the remote \GASPI{} process with \parameter{remote\_segment\_id} as input parameter.

\section{One-sided communication}

\subsection{Introduction and overview}

One-sided asynchronous communication is the basic communication
mechanism provided by \GASPI{}. Hereby, one \GASPI{} process specifies
all communication parameters, both for the local and the remote
side. Due to the asynchronicity, a complete communication
involves two procedure calls. First, one call to initiate the
communication. This call posts a communication request to the
underlying network infrastructure. The second call waits for the
completion of the communication request.

For one-sided communication, \GASPI{} provides the concept of communication
queues.  All operations placed on a certain queue $q$ by one or
several threads are finished after a single wait call on the queue $q$ has
returned successfully. Separation of concerns is possible by using different queues
for different tasks, e.\,g.\ one queue for operations on data and
another queue for operations on meta-data.

The several communication queues guarantee fair communication, i.\,e.\ no queue
should see its communication requests delayed indefinitely. Furthermore,
a single queue preserves the order of the communication requests on the local and the
remote side if the remote rank of two requests is the same.

Communication calls are basically of two types: read and write.
The read operations transfer data from a remote segment
to a local segment.
For the write operation, it is vice versa.

The number of communication queues and their size can be configured at initialization
time, otherwise default values will be used. The default values are implementation
dependent. Maximum values are also defined.

Memory addresses within the global partitioned address space are
specified uniquely by the triple consisting of the rank, segment identifier and
the offset. This prevents a global all to all distribution of memory
addresses, since the memory addresses of memory segments could be and
normally are different on different \GASPI{} processes.

For the write operation there are four different variants that allow different
communication patterns:

\begin{itemize}
\item \gaspifunction{write}
\item \gaspifunction{write\_notify}
\item \gaspifunction{write\_list}
\item \gaspifunction{write\_list\_notify}
\end{itemize}

The read operations have two different variants that allow different
communication patterns:

\begin{itemize}
\item \gaspifunction{read}
\item \gaspifunction{read\_list}
\end{itemize}

The read operations do not support notification calls. This is due to
the fact that a notification can only be transferred after ensuring
that the communication request has been processed. This would imply
that a subsequent wait call has to be invoked directly after invoking
read. However, this can be managed more effectively by the
application.

A valid one-sided communication request requires that the local and
the remote segment are allocated, that there is a connection between
the local and the remote \GASPI{} process and that the remote segment
has been registered on the local \GASPI{} process.

\subsection{Basic communication calls}

\subsubsection{\gaspifunction{write}}

The simplest form of a write operation is \gaspifunction{write} which
is a single communication call to write data to a remote location.
It is \gaspisemantic{asynchronous} \gaspisemantic{non-local}
\gaspisemantic{time-based blocking} procedure.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_write ( gaspi_segment_id_t segment_id_local
            , gaspi_offset_t offset_local
            , gaspi_rank_t rank
            , gaspi_segment_id_t segment_id_remote
            , gaspi_offset_t offset_remote
            , gaspi_size_t size
            , gaspi_queue_id_t queue
            , gaspi_timeout_t timeout
            )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{segment\_id\_local}{the local segment ID to read from}
\parameterlistitem{in}{offset\_local}{the local offset in bytes to read from}
\parameterlistitem{in}{rank}{the remote rank to write to}
\parameterlistitem{in}{segment\_id\_remote}{the remote segment to write to}
\parameterlistitem{in}{offset\_remote}{the remote offset to write to}
\parameterlistitem{in}{size}{the size of the data to write}
\parameterlistitem{in}{queue}{the queue to use}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\executionphasework
\FStdRetDesc
\end{FDef}

\gaspifunction{write} posts a communication request which asynchronously transfers a contiguous block
of \parameter{size} bytes from a source location of the local \GASPI{} process to a target location of a
remote \GASPI{} process. This communication request is posted to the communication queue \parameter{queue}.
The source location is specified by the pair \parameter{segment\_id\_local}, \parameter{offset\_local}. The
target location is specified by the triple \parameter{rank}, \parameter{segment\_id\_remote},
\parameter{offset\_remote}.
% The source location is located at address \emph{source\_buffer = segment\_base\_addr + offset\_local},
% where \emph{segment\_base\_addr} is the base address of the segment with the identifier \parameter{segment\_id\_local}.
% It is the address which is obtained by applying \gaspifunction{segment\_ptr}.
% The target location is located at address \emph{target\_buffer = segment\_base + offset\_remote} where
% \emph{segment\_base} is the base address of the segment represented by \parameter{segment\_id\_remote}
% on the remote \GASPI{} process.

% \begin{todo}
% \item bounds check
% \end{todo}

A valid \gaspifunction{write} communication request requires that the local and the
remote segment are allocated, that there is a connection between the local
and the remote \GASPI{} process and that the remote segment has been registered
on the local \GASPI{} process. Otherwise, the communication request is invalid
and the procedure returns with \GASPIGERR{}.

After successful procedure completion, i.\,e.\ return value \GASPISUCC{}, the communication request has
been posted to the underlying network infrastructure. One new entry is
inserted into the given queue.

Successive \gaspifunction{write} calls posted to the same queue and
the same destination rank are non-overtaking. Non-overtaking means
that the order of communication requests is preserved on the remote
side. In particular, one can assume, that if the data from the later
request has arrived on the remote process, also the data from the
earlier posted request have arrived on the remote side.

\gaspifunction{write} calls may be posted from every thread of the \GASPI{} process.

If the procedure returns with \GASPITIME{}, the communication request could not be posted
to the hardware during the given timeout. This can happen, if another thread is in a \gaspifunction{wait}
for the same queue. A subsequent call of \gaspifunction{write} has to be
invoked in order to complete the write call.

A communication request posted to a given queue can be considered to be completed, if
the correspondent \gaspifunction{wait} returns with \GASPISUCC{}.

If the queue to which the communication request is posted is full, i.\,e.\ if the number of
posted communication requests has already reached the queue size of a given queue, the communication
request fails and the procedure returns with return value \GASPIGERR{}.
If a saturated queue is detected, there are the following two options:
Either one invokes a \gaspifunction{wait} on the given queue in order to wait for all the
posted requests to be finished. Or one tries to use another queue.

\begin{useradvice}\label{useradvice:gaspi_write}
  Return value \GASPISUCC{} does not mean, that the data has been transferred
  or buffered or that the data has arrived at the remote side.

  It is allowed to write data to the source location while the
  communication is ongoing. However, the result on the remote side
  would be some undefined interleaving of the data that was present
  when the call was issued and the data that was written later.

  It is also allowed to read from the source location while the
  communcation is ongoing and such a read would retrieve the data
  written by the application.

  Use \gaspifunction{notify} to synchronize the communication.
\end{useradvice}

\subsubsection{\gaspifunction{read}}

The simplest form of a read operation is \gaspifunction{read} which
is a single communication call to read data from a remote location.
It is a \gaspisemantic{asynchronous} \gaspisemantic{non-local}
\gaspisemantic{time-based blocking} procedure.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_read ( gaspi_segment_id_t segment_id_local
           , gaspi_offset_t offset_local
           , gaspi_rank_t rank
           , gaspi_segment_id_t segment_id_remote
           , gaspi_offset_t offset_remote
           , gaspi_size_t size
           , gaspi_queue_id_t queue
           , gaspi_timeout_t timeout
           )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{segment\_id\_local}{the local segment ID to write to}
\parameterlistitem{in}{offset\_local}{the local offset in bytes to write to}
\parameterlistitem{in}{rank}{the remote rank to read from}
\parameterlistitem{in}{segment\_id\_remote}{the remote segment to read from}
\parameterlistitem{in}{offset\_remote}{the remote offset to read from}
\parameterlistitem{in}{size}{the size of the data to read}
\parameterlistitem{in}{queue}{the queue to use}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\executionphasework
\FStdRetDesc
\end{FDef}

\gaspifunction{read} posts a communication request which asynchronously transfers a contiguous block
of \parameter{size} bytes from a source location of a remote \GASPI{} process to a target location of the
local \GASPI{} process. This communication request is posted to the communication queue \parameter{queue}.
The target location is specified by the pair \parameter{segment\_id\_local}, \parameter{offset\_local}. The
source location is specified by the triple \parameter{rank}, \parameter{segment\_id\_remote},
\parameter{offset\_remote}.
% The target location is located at address \emph{target\_buffer = segment\_base\_addr + offset\_local},
% where \emph{segment\_base\_addr} is the base address of the segment with the identifier \parameter{segment\_id\_local}.
% It is the address which is obtained by applying \gaspifunction{segment\_ptr}.
% The source location is located at address \emph{source\_buffer = segment\_base + offset\_remote} where
% \emph{segment\_base} is the base address of the segment represented by \parameter{segment\_id\_remote}
% on the remote \GASPI{} process.

% \begin{todo}
% \item bounds check
% \end{todo}

A valid \gaspifunction{read} communication request requires that the local and the
remote segment are allocated, that there is a connection between the local
and the remote \GASPI{} process and that the remote segment has been registered
on the local \GASPI{} process. Otherwise, the communication request is invalid
and the procedure returns with \GASPIGERR{}

After successful procedure completion, i.\,e.\ return value \GASPISUCC{}, the communication request has
been posted to the underlying network infrastructure. One new entry is
inserted into the given queue.

Successive \gaspifunction{read} calls posted to the same queue and the
same destination rank are non-overtaking. Non-overtaking means that
the order of communication requests is preserved. In particular, one
can assume, that if the data from the later request has arrived, also
the data from the earlier posted request have arrived.

\gaspifunction{read} calls may be posted from every thread of the \GASPI{} process.

If the procedure returns with \GASPITIME{}, the communication request could not be posted
to the hardware during the given timeout. This can happen, if another thread is in a \gaspifunction{wait}
for the same queue. A subsequent call of \gaspifunction{read} has to be
invoked in order to complete the read call.

A communication request posted to a given queue can be considered to be completed, if the
the correspondent \gaspifunction{wait} returns with \GASPISUCC{}.

If the queue to which the communication request is posted is full, i.\,e.\ that the number of
posted communication requests has already reached the queue size of a given queue, the communication
request fails and the procedure returns with return value \GASPIGERR{}. If a saturated queue
is detected, there are the following two options:
Either one invokes a \gaspifunction{wait} on the given queue in order to wait for all the
posted requests to be finished. Or one tries to use another queue.


\begin{useradvice}
  Return value \GASPISUCC{} does not mean, that the data transfer has
  started or that the data has been received at the local
  side.

  It is allowed to write data to the local target location while the
  communication is ongoing. However, the content of the memory would
  be some undefined interleaving of the data transferred from remote
  side and the data written locally.

  Also, it is allowed to read from the local target location while the
  communication is ongoing. Such a read would retrieve some undefined
  interleaving of the data that was present when the call was issued
  and the data that was transferred from the remote side.

  Use \gaspifunction{notify} to synchronize the communication.
\end{useradvice}

%%%%%%%%%%%%%%% wait

\subsubsection{\gaspifunction{wait}}

The \gaspifunction{wait} procedure is a time-based blocking local
procedure which waits until all one-sided communication requests posted
to a given queue are processed by the network infrastructure.
It is a \gaspisemantic{asynchronous} \gaspisemantic{non-local}
\gaspisemantic{time-based blocking} procedure.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_wait ( gaspi_queue_id_t queue
           , gaspi_timeout_t timeout
           )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{queue}{the queue ID to wait for}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\executionphasework
\FStdRetDesc
\end{FDef}

After successful procedure completion, i.\,e.\ return value \GASPISUCC{}, the hitherto posted communication
requests have been processed by the network infrastructure and the queue is cleaned up.
After that, any communication request which
has been posted to the given queue can be considered to be completed on the local side.

\gaspifunction{wait} procedure calls may be posted from every thread
of the local \GASPI{} process.  However, the wait operation is a
thread exclusive operation and therefore needs privileged access to
the queue which means that if a write/read is done while a wait is in
operation, the write/read operation blocks to ensure
correctness.
Enforcing this provides correctness and safety to the user while being
easier for the implementor and still
allows for a high performance implementation. As a consequence, successive \gaspifunction{wait} calls invoked for the same queue
by different threads are processed in some sequence one after another.

If the procedure returns with \GASPITIME{}, the wait request could not be completed
during the given timeout. This can happen, if there is another thread in a \gaspifunction{wait}
for the same queue. A subsequent call of \gaspifunction{wait} has to be
invoked in order to complete the call.

If the procedure returns with \GASPIGERR{}, the wait request aborted abnormally.

In both cases, \GASPITIME{} and \GASPIGERR{}, the \GASPI{} state
vector should be checked in order to eliminate the possibility of a
failure.  If a failure is detected, all of the communication requests
which have been posted to the given queue since the last
\gaspifunction{wait} are in an undefined state. Here, undefined state
means that the local \GASPI{} process does not know which requests
have been processed and which requests are still outstanding. A call
to \gaspifunction{queue\_purge} has to be invoked in order to reset
the queue.

\begin{useradvice}\label{useradvice:gaspi_wait}
  Return value \GASPISUCC{} means, that the data of all posted write
  requests has been transferred to the remote side. It does not mean,
  that the data has arrived at the remote side. However, write
  accesses to the local source location will not affect the data that is
  placed in the remote target location.
\end{useradvice}

\begin{useradvice}
  Return value \GASPISUCC{} means, that the data of all posted read
  requests has been arrived at the local side.
\end{useradvice}

\subsubsection{Examples}

Listing \ref{lst:alltoall_write} shows a matrix transpose of a
distributed square matrix implemented with the function \gaspifunction{write}.

\insertlisting{../examples/all_to_all/alltoall_write.c}{\GASPI{} all to all communication (matrix transpose) implemented with \gaspifunction{write}\label{lst:alltoall_write}}

Listing \ref{lst:alltoall_read} shows a matrix transpose of a
distributed square matrix implemented with the function
\gaspifunction{read}. Please note the differences between the
transpose implemented with write and the transpose implemented with
read: The implementation using write can initialize the matrix
on-the-fly, right before the data is transferred while the
implementation using read has to synchronize all processes after the
local initialization in order to be sure to read valid data. On the
other hand, in the implementation using write one has to synchronize
after the local wait whereas the implementation using read can
directly use the data after the local wait returns.

\insertlisting{../examples/all_to_all/alltoall_read.c}{\GASPI{} all-to-all communication (matrix transpose) implemented with \gaspifunction{read}\label{lst:alltoall_read}}

The definition of the macro \verb|ASSERT| is given in the listings
\ref{lst:success_or_die_h} and \ref{lst:success_or_die_c} starting on
page \pageref{lst:success_or_die_h}. The definition of the function
\verb|wait_if_queue_full| is given in the listings
\ref{lst:wait_if_queue_full_h} and \ref{lst:wait_if_queue_full_c}
starting on page \pageref{lst:wait_if_queue_full_h}.

\subsection{Weak synchronization primitives}


\subsubsection{Introduction}

The one-sided communication procedures have the characteristics that the
entire communication is managed by the local process only. The
remote process is not involved. This has the advantage that there
is no inherent synchronization between the local and the remote
process in every communication request. However, at some point,
the remote process needs the information as to whether the data
which has been sent to that process has arrived and is valid.

Therefore, \GASPI{} provides so-called weak synchronization
primitives which allows the application to inform the remote side that
the data has been transferred by updating a notification on the remote
side. These notifications are supposed to be attached
to the same queue to which the data payload has been
attached. Otherwise, causality is not guaranteed.

As counterpart, there are
routines which wait for an update of a single or even an entire set of
notifications. This is not thread save. There is a thread safe atomic function
to reset the local notification with a given ID which returns the value
of the notification before it is reset.

These notification procedures are also one-sided and do
involve only the local process.

%%%%%%%%%%%%%%%  notify

\subsubsection{\gaspifunction{notify}}

\gaspifunction{notify} is an \gaspisemantic{asynchronous} \gaspisemantic{non-local}
\gaspisemantic{time-based blocking} procedure.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_notify ( gaspi_rank_t rank
             , gaspi_notification_id_t notification_id
             , gaspi_notification_t notification_value
             , gaspi_queue_id_t queue
             , gaspi_timeout_t timeout
             )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{rank}{the remote rank to notify}
\parameterlistitem{in}{notification\_id}{the remote notification ID}
\parameterlistitem{in}{notification\_val}{the notification value ($>0$) to write}
\parameterlistitem{in}{queue}{the queue to use}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\executionphasework
\FStdRetDesc
\end{FDef}

\gaspifunction{notify} posts a notification request which asynchronously transfers the notification
\parameter{notification} of the local \GASPI{} process to an internal notification buffer of a
remote \GASPI{} process. This notification request is posted to the communication queue \parameter{queue}.
The remote notification buffer is specified by the pair \parameter{rank}, \parameter{notification\_id}.
% The remote notification buffer is located at address \emph{notification\_buffer = segment\_base + offset\_notification} where
% \emph{segment\_base} is the base address of the segment represented by \parameter{segment\_id\_notification}.

A valid \gaspifunction{notify} communication request requires that there is a
connection between the local and the remote \GASPI{} process. Otherwise, the
communication request is invalid
and the procedure returns with \GASPIGERR{}.

After successful procedure completion, i.\,e.\ return value \GASPISUCC{}, the notification request has
been posted to the underlying network infrastructure. One new entry is
inserted into the given queue.

Successive \gaspifunction{write} and \gaspifunction{notify} calls
posted to the same queue and the same destination rank are
non-overtaking. Non-overtaking means that the order of communication
requests is preserved on the remote side. In particular, one can
assume, that if the data from the later request has arrived on the
remote process, also the data from the earlier posted request have
arrived on the remote side.

\gaspifunction{notify} calls may be posted from every thread of the \GASPI{} process.

If the procedure returns with \GASPITIME{}, the notification request could not be posted
to the hardware during the given timeout. This can happen if another thread is in a \gaspifunction{wait}
for the same queue. A subsequent call of \gaspifunction{notify} has to be
invoked in order to complete the call.

A notification request posted to a given queue can be considered to be completed, if the
the correspondent \gaspifunction{wait} returns with \GASPISUCC{}.

If the queue to which the communication request is posted is full, i.\,e.\ that the number of
posted communication requests has already reached the queue size of a given queue, the communication
request fails.


\begin{useradvice}
  Return value \GASPISUCC{} does not mean, that the notification has
  been transferred or that the notification has arrived at the remote
  side.
\end{useradvice}

\begin{implementoradvice}
\gaspifunction{notify} is semantically equivalent to an update of a local internally managed notification buffer
with a subsequent \gaspifunction{write}. However, it should be implemented
more efficiently, if supported by the network infrastructure.
\end{implementoradvice}

%%%%%%%%%%%%% wait notification

% \subsubsection{\gaspifunction{notify\_wait}}
%
% \begin{todo}
% \item delete \gaspifunction{notify\_wait}
% \item perhaps just keep example
% \end{todo}
%
% For the procedures with notification, \gaspifunction{write\_notify}
% and \gaspifunction{write\_list\_notify}, there are correspondent wait
% procedures for the receiver (notified) side. It is a
% \gaspisemantic{synchronous} \gaspisemantic{non-local}
% \gaspisemantic{time-based blocking} procedure.
%
% \begin{FDef}
% \begin{FDefSign}
% \begin{verbatim}
% gaspi_return_t
% gaspi_notify_wait ( gaspi_segment_id_t segment_id
%                   , gaspi_offset_t offset
%                   , gaspi_timeout_t timeout
%                   )
% \end{verbatim}
% \end{FDefSign}
% \parameterlistbegin
% \parameterlistitem{in}{segment\_id}{the local segment ID where the notification resides}
% \parameterlistitem{in}{offset}{the local offset where the notification resides}
% \parameterlistitem{in}{timeout}{the timeout}
% \parameterlistend
% \executionphasework
% \FStdRetDesc
% \end{FDef}
%
% The \gaspifunction{notify\_wait} procedure is a time-based blocking
% non-local procedure which waits until a notification which resides in the local
% partition of the global address space has a value that is not zero.
%
% The notification buffer on the local side is specified by the
% pair \parameter{segment\_id} and \parameter{offset}.
% % It is located at
% % the address \emph{segment\_base\_addr + offset}, where
% % \emph{segment\_base\_addr} is the base address of the segment with the
% % identifier \parameter{segment\_id}.
%
% After successful procedure completion, i.\,e.\ return value
% \GASPISUCC{}, the value of the notification buffer has changed to a value that
% is not zero. All threads that are waiting for a single notification are
% notified.
%
% If the procedure returns with \GASPITIME{}, the notification has not
% changed during the given period of time.
%
% In case of error, i.\,e.\ return value \GASPIGERR, the value of the
% notification is undefined.
%
% \begin{useradvice}
%   One scenario for the usage of \gaspifunction{notify\_wait}
%   is the following: The remote side uses a \gaspifunction{write} call
%   followed by a subsequent call of \gaspifunction{notify} posted to
%   the same queue and the same destination rank. Since the specification
%   preserves the order of communication requests on the remote side, one can
%   assume, that if the notification has arrived on the remote
%   process, also the previously posted request carrying the work load
%   have arrived.
% \end{useradvice}
%
% \begin{useradvice}
%   If in a multi-threaded application more than one thread calls
%   \gaspifunction{notify\_wait} for the same notification, then all waiting
%   threads are notified about the change of the value. By using
%   \gaspifunction{notify\_reset} only one thread receives a value
%   different from zero.
% \end{useradvice}
%
% \begin{implementoradvice}
%   Listing \ref{lst:notify_wait.impl} shows a generic implementation of
%   \gaspifunction{notify\_wait}.
% \end{implementoradvice}
%
% \insertlisting{notify_wait.c}{Generic implementation of \gaspifunction{notify\_wait}.\label{lst:notify_wait.impl}}

\subsubsection{\gaspifunction{notify\_waitsome}}

For the procedures with notification, \gaspifunction{notify}
and \gaspifunction{write\_notify}, \gaspifunction{write\_waitsome}
is the correspondent wait procedure for the receiver (notified) side.
% Sometimes an applications needs to be notified about the change of one
% out of a number of notifications. This could be achieved by busy iterating
% over the list of notifications and call \gaspifunction{notify\_wait} with the
% timeout value \GASPITEST{}. However, it is more clear to use
% \gaspifunction{notify\_waitsome}.
\gaspifunction{notify\_waitsome} is a \gaspisemantic{synchronous},
\gaspisemantic{non-local} \gaspisemantic{time-based blocking}
procedure.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_notify_waitsome ( gaspi_notification_id_t notification_begin
                      , gaspi_number_t notification_num
                      , gaspi_timeout_t timeout
                      )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{notification\_begin}{the local notification ID for the first notification to wait for}
\parameterlistitem{in}{notification\_num}{the number of notification ID's to wait for}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\executionphasework
\FStdRetDesc
\end{FDef}

\gaspifunction{notify\_waitsome} waits that at least one of a number
of consecutive notifications residing in the local
internal buffer has a value that is not zero.

The notification buffer is specified by the
pair \parameter{notification\_begin}, \parameter{notification\_num}.
It contains $\mbox{\it notification\_num}$ many consecutive
notifications beginning at the notification with ID $\mbox{\it notification\_begin}$.

If $\mbox{\it notification\_num}==0$ then \gaspifunction{notify\_waitsome} returns immediately with \GASPISUCC{}.
% The first
% notification is located at the address \emph{segment\_base\_addr +
%   offset\_begin}, where \emph{segment\_base\_addr} is the base address
% of the segment with the identifier \parameter{segment\_id}.

% \begin{todo}
% \item what happens when offset\_begin == offset\_end
% \end{todo}

After successful procedure completion, i.\,e.\ return value
\GASPISUCC{}, the value of at least one of the notifications in the notification
buffer has changed to a value that is not zero. All threads that are
waiting for the notifications are notified.

If the procedure returns with \GASPITIME{}, no notification has changed during
the given period of time.

In case of an error, i.\,e.\ \GASPIGERR{}, the values of the notifications are
undefined.

\begin{useradvice}
  One scenario for the usage of \gaspifunction{notify\_waitsome}
  inspecting only one notification is the following: The remote side
  uses a \gaspifunction{write} call followed by a subsequent call of
  \gaspifunction{notify} posted to the same queue and the same
  destination rank. Since the order of communication requests on the remote side
  is preserved, one can assume, that if the notification has arrived
  on the remote process, then the previously posted request carrying
  the work load have arrived.
\end{useradvice}

\begin{useradvice}
  If in a multi-threaded application more than one thread calls
  \gaspifunction{notify\_waitsome} for the range of notifications, then all waiting
  threads are notified about the change of at least one of the notifications. By
  inspecting the actual values of each of the notifications with
  \gaspifunction{notify\_reset}, only one thread per changed notification receives a value
  different from zero.
\end{useradvice}

\begin{useradvice}
  In a multi-threaded application the code in listing
  \ref{lst:waitsome_select.c} selects one thread to act on the change
  of a single notification. The code waits in a blocking manner and thus
  cannot be used in fault tolerant applications.
\end{useradvice}

\insertlisting{waitsome_select.c}{Blocking waitsome in a multi-threaded application\label{lst:waitsome_select.c}}

% \begin{implementoradvice}
%   Listing \ref{lst:notify_wait.impl} shows a generic implementation of
%   \gaspifunction{notify\_wait}.
% \end{implementoradvice}

% \insertlisting{notify_wait.c}{Generic implementation of \gaspifunction{notify\_wait}.\label{lst:notify_wait.impl}
% waiting for a single notification.}

%%%%%%%%%%%%% reset notification

\subsubsection{\gaspifunction{notify\_reset}}

For the \gaspifunction{notify\_waitsome} procedure, there is a notification
initialization procedure which resets the given notification to zero. It is a
\gaspisemantic{synchronous} \gaspisemantic{local}
\gaspisemantic{blocking} procedure.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_notify_reset ( gaspi_notification_id_t notification_id
                   , gaspi_notification_t old_notification_val
                   )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{notification\_id}{the local notification ID to reset}
\parameterlistitem{out}{old\_notification\_val}{notification value before reset}
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}

\gaspifunction{notify\_reset} resets the notification with ID \parameter{notification\_id} to
zero. The function \gaspifunction{notify\_reset} is an atomic
operation: Threads can use \gaspifunction{notify\_reset} to safely
extract the value of a specific notification.

The notification buffer on the local side is specified by the notification ID \parameter{notification\_id}.
% It is located at address \emph{notification\_buffer = segment\_base\_addr + offset},
% where \emph{segment\_base\_addr} is the base address of the segment with the identifier \parameter{segment\_id}.
% It is the address which is obtained by applying \gaspifunction{segment\_ptr}.

After successful procedure completion, i.\,e.\ return value
\GASPISUCC{}, the value of the notification buffer was set to zero and
the \parameter{old\_notification\_val} contains the content of the notification buffer
before it was set to zero. To read the old value and to set to value
to zero is a single atomic operation.

\gaspifunction{notify\_waitsome} calls may be posted from every thread of
the \GASPI{} process.

In case of error, i.\,e.\ return value \GASPIGERR, the value of the
notification is undefined.

%%%%%%%%%%%%% size notification


%\subsubsection{Examples}

%The following example presents a typical pattern where communication
%happens between neighbors.

%\begin{todo}
%\item the example with the halo exchange
%\end{todo}
%\begin{listing}{1}
%forall iterations:
%    calculate inner points;
%    SEND_HALO (buf1);
%    while (!all neighbour data in buf0 received)
%    {
%      foreach n in unfinished_neighbours
%      {
%        /* test for halo */
%        const gaspi_return_t err
%          = WAIT_NOTIFICATION (notification_offset[n],0,TEST);
%
%        if (err == SUCCESS)
%        {
%          handle data from n;
%
%          /* reset notification */
%          notification_offset[n] = 0;
%        }
%      }
%    }
%    swap (buf0, buf1);
%end forall;
%\end{listing}

\subsection{Extended communication calls}

%%%%%%%%% gaspi write notify

\subsubsection{\gaspifunction{write\_notify}}

The \gaspifunction{write\_notify} variant extends the simple
\gaspifunction{write} with a notification on the remote
side. This applies to communication patterns that require tighter
synchronization on data movement. The remote receiver of the data is
notified when the write is finished and can verify this through the
respective wait procedure. It is an \gaspisemantic{asynchronous}
\gaspisemantic{non-local} \gaspisemantic{time-based blocking}
procedure.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_write_notify ( gaspi_segment_id_t segment_id_local
                   , gaspi_offset_t offset_local
                   , gaspi_rank_t rank
                   , gaspi_segment_id_t segment_id_remote
                   , gaspi_offset_t offset_remote
                   , gaspi_size_t size
                   , gaspi_notification_id_t notification_id
                   , gaspi_notification_t notification_value
                   , gaspi_queue_id_t queue
                   , gaspi_timeout_t timeout
                   )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{segment\_id\_local}{the local segment ID to read from}
\parameterlistitem{in}{offset\_local}{the local offset in bytes to read from}
\parameterlistitem{in}{rank}{the remote rank to write to}
\parameterlistitem{in}{segment\_id\_remote}{the remote segment to write to}
\parameterlistitem{in}{offset\_remote}{the remote offset to write to}
\parameterlistitem{in}{size}{the size of the data to write}
\parameterlistitem{in}{notification\_id}{the remote notification ID}
\parameterlistitem{in}{notification\_value}{the value of the notification to write}
\parameterlistitem{in}{queue}{the queue to use}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\executionphasework
\FStdRetDesc
\end{FDef}

Two new entries are inserted into the given queue.

\begin{implementoradvice}
The procedure is semantically equivalent to a call to \gaspifunction{write}
and a subsequent call of \gaspifunction{notify}. However, it should be implemented
more efficiently, if supported by the network infrastructure.
\end{implementoradvice}

%%%%%%%%% gaspi write list

\subsubsection{\gaspifunction{write\_list}}

The \gaspifunction{write\_list} variant allows strided communication
where a list of different data locations are processed at
once. Semantically, it is equivalent to a sequence of calls to
\gaspifunction{write} but it should (if possible) be more efficient.
It is an \gaspisemantic{asynchronous}
\gaspisemantic{non-local} \gaspisemantic{time-based blocking}
procedure.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_write_list ( gaspi_number_t num
                 , gaspi_segment_id_t segment_id_local[num]
                 , gaspi_offset_t offset_local[num]
                 , gaspi_rank_t rank
                 , gaspi_segment_id_t segment_id_remote[num]
                 , gaspi_offset_t offset_remote[num]
                 , gaspi_size_t size[num]
                 , gaspi_queue_id_t queue
                 , gaspi_timeout_t timeout
                 )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{num}{the number of elements to write}
\parameterlistitem{in}{segment\_id\_local[num]}{list of local segment ID's to read from}
\parameterlistitem{in}{offset\_local[num]}{list of local offsets in bytes to read from}
\parameterlistitem{in}{rank}{the remote rank to write to}
\parameterlistitem{in}{segment\_id\_remote[num]}{list of remote segments to write to}
\parameterlistitem{in}{offset\_remote[num]}{list of remote offsets to write to}
\parameterlistitem{in}{size[num]}{list of sizes of the data to write}
\parameterlistitem{in}{queue}{the queue to use}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\executionphasework
\FStdRetDesc
\end{FDef}

\parameter{num} new entries are inserted in the given queue.

\begin{implementoradvice}
The procedure is semantically equivalent to \parameter{num} subsequent calls
of \gaspifunction{write} with the given local and remote location specification, provided
that the destination rank and the used queue are invariant. However, it should be implemented
more efficiently, if supported by the network infrastructure.
\end{implementoradvice}

%%%%%%%%% gaspi write list notify

\subsubsection{\gaspifunction{write\_list\_notify}}

The \gaspifunction{write\_list\_notify} operation performs strided
communication as \gaspifunction{write\_list} but also includes a
notification that the remote receiver can use to ensure that the
communication step is completed.
It is an \gaspisemantic{asynchronous}
\gaspisemantic{non-local} \gaspisemantic{time-based blocking}
procedure.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_write_list_notify
                ( gaspi_number_t num
                , gaspi_segment_id_t segment_id_local[num]
                , gaspi_offset_t offset_local[num]
                , gaspi_rank_t rank
                , gaspi_segment_id_t segment_id_remote[num]
                , gaspi_offset_t offset_remote[num]
                , gaspi_size_t size[num]
                , gaspi_notification_id_t notification_id
                , gaspi_notification_t notification_value
                , gaspi_queue_id_t queue
                , gaspi_timeout_t timeout
                )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{num}{the number of elements to write}
\parameterlistitem{in}{segment\_id\_local[num]}{list of local segment ID's to read from}
\parameterlistitem{in}{offset\_local[num]}{list of local offsets in bytes to read from}
\parameterlistitem{in}{rank}{the remote rank to be write to}
\parameterlistitem{in}{segment\_id\_remote[num]}{list of remote segments to write to}
\parameterlistitem{in}{offset\_remote[num]}{list of remote offsets to write to}
\parameterlistitem{in}{size[num]}{list of sizes of the data to write}
\parameterlistitem{in}{notification\_id}{the remote notification ID}
\parameterlistitem{in}{notification\_value}{the value of the notification to write}
\parameterlistitem{in}{queue}{the queue to use}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\executionphasework
\FStdRetDesc
\end{FDef}

\parameter{num+1} new entries are inserted into the given queue.

\begin{implementoradvice}
The procedure is semantically equivalent to a call to \gaspifunction{write\_list}
and a subsequent call of \gaspifunction{notify}. However, it should be implemented
more efficiently, if supported by the network infrastructure.
\end{implementoradvice}

%%%%%%%%% gaspi read list

\subsubsection{\gaspifunction{read\_list}}

The \gaspifunction{read\_list} variant allows strided communication
where a list of different data locations are processed at
once. Semantically, it is equivalent to a sequence of calls to
\gaspifunction{read} but it should (if possible) be more efficient.
It is an \gaspisemantic{asynchronous}
\gaspisemantic{non-local} \gaspisemantic{time-based blocking}
procedure.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_read_list ( gaspi_number_t num
                , gaspi_segment_id_t segment_id_local[num]
                , gaspi_offset_t offset_local[num]
                , gaspi_rank_t rank
                , gaspi_segment_id_t segment_id_remote[num]
                , gaspi_offset_t offset_remote[num]
                , gaspi_size_t size[num]
                , gaspi_queue_id_t queue
                , gaspi_timeout_t timeout
                )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{num}{the number of elements to read}
\parameterlistitem{in}{segment\_id\_local[num]}{list of local segment ID's to write to}
\parameterlistitem{in}{offset\_local[num]}{list of local offsets in bytes to write to}
\parameterlistitem{in}{rank}{the remote rank to read from}
\parameterlistitem{in}{segment\_id\_remote[num]}{list of remote segments to read from}
\parameterlistitem{in}{offset\_remote[num]}{list of remote offsets to read from}
\parameterlistitem{in}{size[num]}{list of sizes of the data to read}
\parameterlistitem{in}{queue}{the queue to use}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\executionphasework
\FStdRetDesc
\end{FDef}

\parameter{num} new entries are inserted into the given queue.

%\subsubsection{Examples}

\subsection{Communication utilities}

\subsubsection{\gaspifunction{queue\_size}}

The \gaspifunction{queue\_size} procedure
is a \gaspisemantic{synchronous}
\gaspisemantic{local} \gaspisemantic{blocking} procedure which determines the number
of communication requests posted to a given queue.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_queue_size ( gaspi_queue_id_t queue
                 , gaspi_number_t queue_size
                 )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{queue}{the queue to probe}
\parameterlistitem{out}{queue\_size}{the number of requests posted to the queue}
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}


After successful procedure completion, i.\,e.\ return value \GASPISUCC{}, the parameter
\parameter{queue\_size} contains the number of requests posted to the queue \parameter{queue}.
In a threaded program this result is uncertain, since another thread may have
posted an additional request in the meantime or issued a wait call.

The queue is reset after a call to \gaspifunction{wait}.

In case of error, the return value is \GASPIGERR{}. The parameter \parameter{queue\_size}
has an undefined value.

 \subsubsection{\gaspifunction{queue\_purge}}

 The \gaspifunction{queue\_purge} procedure is a
 \gaspisemantic{synchronous} \gaspisemantic{local}
 \gaspisemantic{time-based blocking} procedure which purges a given
 queue.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_queue_purge ( gaspi_queue_id_t queue
                  , gaspi_timeout_t timeout
                  )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{queue}{the queue to purge}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\executionphasework
\FStdRetDesc
\end{FDef}

This procedure should only be invoked in the situation in which a node failure is detected
by inspecting the global health state with \gaspifunction{state\_vec\_get}.

After successful procedure completion, i.\,e.\ return value \GASPISUCC{}, the communication
\parameter{queue} is purged. All communication requests posted to the queue \parameter{queue} are
eliminated from the queue. The local \GASPI{} process has no information about the
completion of communication requests posted to the given queue since the last invocation
of \gaspifunction{wait}.

If the procedure returns with \GASPITIME{}, the purge request could not be completed
during the given timeout. This might happen if there is another thread in a \gaspifunction{wait}
for the same queue. A subsequent call of \gaspifunction{queue\_purge} has to be
invoked in order to complete the call.

If the procedure returns with \GASPIGERR{}, the purge request aborted abnormally.

\section{Passive communication}

\subsection{Introduction and overview}

Passive communication has a two-sided semantic, where there is a
matching receiver to a send request. Passive communication aims at
communication patterns where the sender is unknown (i.\,e.\ it can be any
process from the receiver perspective) but there is potentially the need
for synchronization between processes. Typical example uses cases are:

\begin{itemize}
\item Distributed update where many processes contribute to the data of
  one process.
\item Pass arguments and results.
\item Global error handling.
\end{itemize}

The implementation should try to enforce fairness in communication
that is, no sender should see its communication request delayed indefinitely.

The passive keyword means that the communication calls should avoid
busy-waiting and consume no CPU cycles, freeing the system for
computation.

The send request is asynchronous, whereas the matching receive is
\gaspisemantic{time-based blocking}. Due to the asynchronous nature of the
send request, a complete send involves two procedure calls. First, one
call which initiates the communication. This call posts a
communication request to the underlying network infrastructure.  The
second call waits for the completion of the communication request.

A valid passive communication request requires that the local and the
remote segment are allocated and that there is a connection between the local
and the remote \GASPI{} process. Otherwise, the communication request is invalid
and the procedure returns with \GASPIGERR{}.

\subsection{Passive communication calls}

%%%%%%%%% Passive wait

\subsubsection{\gaspifunction{passive\_send}}

The non-blocking \gaspifunction{passive\_send} is one of the routines
called by the sender side to engage in passive communication.
%To make sure the requests are processed the \gaspifunction{passive\_wait} is used.
It is an \gaspisemantic{asynchronous}
\gaspisemantic{non-local} \gaspisemantic{time-based blocking} procedure.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_passive_send ( gaspi_segment_id_t segment_id_local
                   , gaspi_offset_t offset_local
                   , gaspi_rank_t rank
                   , gaspi_size_t size
                   , gaspi_tag_t tag
                   , gaspi_timeout_t timeout
                   )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{segment\_id\_local}{the local segment ID from which the data is sent}
\parameterlistitem{in}{offset\_local}{the local offset from which the data is sent}
\parameterlistitem{in}{rank}{the remote Rank to which the data is sent}
\parameterlistitem{in}{size}{the size of the data to be sent}
\parameterlistitem{in}{tag}{the tag to be sent with the data}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\executionphasework
\FStdRetDesc
\end{FDef}

\gaspifunction{passive\_send} posts a passive communication request
which asynchronously transfers a contiguous block of \parameter{size}
bytes from a source location of the local \GASPI{} process to the remote
\GASPI{} process with the indicated rank \parameter{rank}.  On the
remote side, a corresponding \gaspifunction{passive\_receive} has to
be posted. The source location is specified by the
pair \parameter{segment\_id\_local}, \parameter{offset\_local}.
% The
% source location is located at address \emph{source\_buffer =
%   segment\_base\_addr + offset\_local}, where
% \emph{segment\_base\_addr} is the base address of the segment with the
% identifier \parameter{segment\_id\_local}.  It is the address which is
% obtained by applying \gaspifunction{segment\_ptr} on the given local
% segment identifier.

There is a size limit for the data send with
\gaspifunction{passive\_send}. The maximum size is returned by the function
\gaspifunction{passive\_transfer\_size\_max}.

The passive data \parameter{tag} can be used to discriminate different
types of data.

A valid \gaspifunction{send} communication request requires that the local and the
remote segment are allocated and that there is a connection between the local
and the remote \GASPI{} process. Otherwise, the communication request is invalid
and the procedure returns with \GASPIGERR{}.

After successful procedure completion, i.\,e.\ return value \GASPISUCC{}, the passive communication request has
been posted to the underlying network infrastructure. One new entry is
inserted into the passive queue.

Successive \gaspifunction{passive\_send} calls posted to the same
destination rank are non-overtaking. Non-overtaking means that the
order of communication requests is preserved on the remote side. In
particular, one can assume, that if the data from the later request
has arrived on the remote process, also the data from the earlier
posted request have arrived on the remote side.

\gaspifunction{passive\_send} calls may be posted from every thread of the \GASPI{} process.

If the procedure returns with \GASPITIME{}, the communication request could not be posted
to the hardware during the given timeout. This can happen, if another thread is in a \gaspifunction{passive\_wait}.
A subsequent call of \gaspifunction{passive\_send} needs to be invoked in order to complete
the procedure call.

A passive communication request can be considered to be completed, if the
the correspondent \gaspifunction{passive\_wait} returns with \GASPISUCC{}.

% If the passive communication queue is full, i.\,e.\ the number of
% posted communication requests has already reached the queue size, and another communication
% request is posted, this results in an error and the procedure returns with return value \GASPIGERR{}.
If the passive communication queue is full at the time when a new passive communication request is
posted, i.\,e.\ the number of
posted communication requests has already reached the queue size, the communication
request fails and the procedure returns with return value \GASPIGERR{}. If a saturated passive
communication queue
is detected one has to invoke a \gaspifunction{passive\_wait} in order to wait for all the
posted requests to be finished.


\begin{useradvice}\emph{[identical to the advice in \ref{useradvice:gaspi_write} on page \pageref{useradvice:gaspi_write}]}
  Return value \GASPISUCC{} does not mean, that the data has been transferred
  or buffered or that the data has arrived at the remote side.

  It is allowed to write data to the source location while the
  communication is ongoing. However, the result on the remote side
  would be some undefined interleaving of the data that was present
  when the call was issued and the data that was written later.

  It is also allowed to read from the source location while the
  communcation is ongoing and such a read would retrieve the data
  written by the application.

  Use \gaspifunction{notify} to synchronize the communication.
\end{useradvice}


\begin{useradvice}
  If the parameter \parameter{build\_infrastructure} is not set, a
  connection has to be established between the processes before the
  \gaspifunction{passive\_send} can be be used. This is accomplished
  calling the procedure \gaspifunction{connect}.
\end{useradvice}


%%%%%% Passive wait

\subsubsection{\gaspifunction{passive\_wait}}

The \gaspifunction{passive\_wait} procedure is an \gaspisemantic{asynchronous}
\gaspisemantic{non-local} \gaspisemantic{time-based blocking}
procedure which waits until all posted passive send requests are processed
by the network infrastructure.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_passive_wait (gaspi_timeout_t timeout)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{Timeout}{the timeout}
\parameterlistend
\executionphasework
\FStdRetDesc
\end{FDef}

The passive wait operation makes sure all passive send requests are
finished.

After successful procedure completion, i.\,e.\ return value \GASPISUCC{}, the hitherto posted
passive communication
requests have been processed by the network infrastructure. After that, any passive communication
request which has been posted can be considered to be completed on the local side.

\gaspifunction{passive\_wait} procedure calls may be posted from every
thread of the local \GASPI{} process.  However, the wait operation is
a thread exclusive operation and therefore needs privileged access to
the queue which means that if a passive send is done while a wait is
in operation, the passive send blocks to ensure correctness.
Enforcing this provides correctness and safety to the user while being
easier for the implementor and still
allows for a high performance implementation. As a consequence, successive \gaspifunction{passive\_wait} calls invoked for the same queue
by different threads are processed in some sequence one after another.

If the procedure returns with \GASPITIME{}, the wait request could not be completed
during the given timeout. This can happen, if there are still some passive communication requests
to be completed or if there is another thread in a \gaspifunction{passive\_wait} for the same queue.

If the procedure returns with \GASPIGERR{}, the wait request aborted abnormally.

In both cases, \GASPITIME{} and \GASPIGERR{}, the \GASPI{} state
vector should be checked in order to eliminate the possibility of a
failure.  If a failure is detected, all of the
\gaspifunction{passive\_send} requests which have been posted to the
given queue since the last \gaspifunction{passive\_wait} are in an
undefined state.  Here, undefined state means that the local \GASPI{}
process does not know which requests have been processed and which
requests are still outstanding. A call to
\gaspifunction{passive\_queue\_purge} has to be invoked in order to
reset the passive queue.

\begin{useradvice}\emph{[identical to the advice in \ref{useradvice:gaspi_wait} on page \pageref{useradvice:gaspi_wait}]}
  Return value \GASPISUCC{} means, that the data of all posted passive
  communication requests has been transferred to the remote side. It does not
  mean, that the data has arrived at the remote side. However, write
  accesses to the local source location will not affect the data that is
  placed in the remote target location.
\end{useradvice}

%%%%%%%%%%%% passive receive

\subsubsection{\gaspifunction{passive\_receive}}

The \gaspisemantic{synchronous}
\gaspisemantic{non-local} \gaspisemantic{time-based blocking} \gaspifunction{passive\_receive} is one of the routines
called by the receiver side to engage in passive communication.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_passive_receive ( gaspi_segment_id_t segment_id_local
                      , gaspi_offset_t offset_local
                      , gaspi_rank_t rank
                      , gaspi_tag_t tag
                      , gaspi_timeout_t timeout
                      )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{segment\_id\_local}{the local segment ID where to write the data}
\parameterlistitem{in}{offset\_local}{the local offset where to write the data}
\parameterlistitem{out}{rank}{the remote rank from which the data is transferred}
\parameterlistitem{out}{tag}{the tag which has been sent with the data}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\executionphasework
\FStdRetDesc
\end{FDef}

\gaspifunction{passive\_receive} receives a contiguous block of data into a target location from some unspecified
remote \GASPI{} process. The target location is specified by the pair \parameter{segment\_id\_local},
\parameter{offset\_local}.
% It is located at address \emph{source\_buffer = segment\_base\_addr + offset\_local},
% where \emph{segment\_base\_addr} is the base address of the segment with the identifier \parameter{segment\_id\_local}.
% It is the address which is obtained by applying \gaspifunction{segment\_ptr} on the given segment specifier.

There is no need for the \gaspifunction{passive\_receive} procedure to
be active before a corresponding \gaspifunction{passive\_send}
procedure is invoked. However, as long as there is no matching
receive, the \gaspifunction{passive\_send} cannot achieve any progress
and a \gaspifunction{passive\_wait} that includes such a
\gaspifunction{passive\_send} cannot return \GASPISUCC{}.

The target location needs to have enough space to hold the maximum
passive transfer size that could be sent be any other
process. Otherwise, the received data might overwrite memory regions
outside of the allocated memory and the application will be in an undefined state.

A valid \gaspifunction{passive\_receive} communication request
requires that the local destination segment is allocated and that
there is a connection between the local and the remote \GASPI{}
process from which a data transfer originates. Otherwise, the communication
request is invalid and the procedure returns with \GASPIGERR{}.

After successful procedure completion, i.\,e.\ return value
\GASPISUCC{}, the data has been received and is available at the
target location. Further \parameter{rank} contains the rank of the
sending process and \parameter{tag} contains the tag associated to the
communication request.

Successive \gaspifunction{passive\_receive} calls posted by two
different threads using two different target locations are
allowed. However, either the first incoming data is received by the
first thread or the by the second. That means that the
\gaspifunction{passive\_receive} should be posted only from a single
thread of a \GASPI{} process.

If the procedure returns with \GASPITIME{}, there was no pending
communication request in the queue. The output
parameters \parameter{rank} and \parameter{tag} have no defined value.

\begin{useradvice}
  It is allowed to write data to the local target location while the
  passive communication is ongoing. However, the content of the memory
  would be some undefined interleaving of the data transferred from
  remote side and the data written locally.

  Also, it is allowed to read from the local target location while the
  passive communication is ongoing. Such a read would retrieve some
  undefined interleaving of the data that was present when the call
  was issued and the data that was transferred from the remote side.
\end{useradvice}

\begin{implementoradvice}
  A quality implementation enforces fairness in communication
  that is, no sender should see its communication request
  delayed indedinitely. The passive keyword means the communication calls shall
  avoid busy-waiting and consume no CPU cycles, freeing the system for
  computation.
\end{implementoradvice}


\subsection{Passive communication utilities}

\subsubsection{\gaspifunction{passive\_queue\_size}}

The \gaspifunction{passive\_queue\_size} procedure is a
\gaspisemantic{synchronous} \gaspisemantic{local}
\gaspisemantic{blocking} procedure which determines the number of
communication requests posted to the passive queue.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_passive_queue_size (gaspi_number_t queue_size)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{queue\_size}{Number of requests posted to the passive communication queue}
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}

After successful procedure completion, i.\,e.\ return value \GASPISUCC{}, the parameter
\parameter{queue\_size} contains the number of posted requests.
In a threaded program this result is uncertain, since another thread may have
posted an additional request or a wait call in the meantime.

The queue is reset after a call to \gaspifunction{passive\_wait}.

In case of error, the return value is \GASPIGERR{}. The value of \parameter{passive\_queue\_size}
is undefined.

\subsubsection{\gaspifunction{passive\_queue\_purge}}

The \gaspifunction{passive\_queue\_purge} procedure is a
\gaspisemantic{synchronous} \gaspisemantic{local}
\gaspisemantic{time-based blocking} procedure which purges the passive
queue.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_passive_queue_purge (gaspi_timeout_t timeout)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\executionphasework
\FStdRetDesc
\end{FDef}

This procedure should only be invoked in the situation in which a node failure is detected
by inspecting the global health state with \gaspifunction{state\_vec\_get}.

After successful procedure completion, i.\,e.\ return value \GASPISUCC{}, the passive communication
queue is purged. All communication requests posted to the passive queue are
eliminated. The local \GASPI{} process has no information about the
completion of communication requests posted to the passive queue since the last invocation
of \gaspifunction{passive\_wait}.

If the procedure returns with \GASPITIME{}, the purge request could not be completed
during the given timeout. This might happen if there is another thread in a \gaspifunction{passive\_wait}.
A subsequent call of \gaspifunction{passive\_queue\_purge} has to be
invoked in order to complete the call.

If the procedure returns with \GASPIGERR{}, the purge request aborted abnormally.

\section{Global atomics}

\subsection{Introduction and Overview}

Atomic counters are globally accessible variables to which atomic access
is atomic through two operations: fetch-and-add and compare-and-swap.

An atomic operation is an operation which is guaranteed to be executed
without fear of interference from other processes during the procedure
call. Only one \GASPI{} process at a time has access to the global
variable and can modify it.

Atomic operations are also guaranteed to be fair. That means no \GASPI{}
process should see its atomic operation request
delayed indefinitely.

The number of atomic counters available can be defined by the user
through the configuration structure at start-up and cannot be changed
during run-time. The maximum number of available atomic counters is
implementation dependent.

\begin{implementoradvice}
  The distribution of the counters should be divided evenly over the
  available nodes to avoid too much contention on a single node holding
  the atomic counters.
\end{implementoradvice}

\subsection{Atomic operation calls}

\subsubsection{\gaspifunction{counter\_set}}

The \gaspifunction{counter\_set} procedure is a \gaspisemantic{synchronous}
\gaspisemantic{non-local} \gaspisemantic{time-based} \gaspisemantic{blocking} procedure
which atomically set the value of a global counter.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_counter_set ( gaspi_counter_id_t counter_id
                  , gaspi_counter_value_t value
                  , gaspi_timeout_t timeout
                  )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{counter\_id}{the counter to set}
\parameterlistitem{in}{value}{the value to which the global atomic counter is set}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\executionphasework
\FStdRetDesc
\end{FDef}

\gaspifunction{counter\_set} atomically sets the value of the counter \parameter{counter\_id}
to the value given by \parameter{value}.

After successful procedure completion, i.\,e.\ return value
\GASPISUCC{}, the value of the atomic counter was set
to \parameter{value}.

If the procedure returns with \GASPITIME{}, the reset request could not be completed
during the given timeout. A subsequent call of \gaspifunction{counter\_set} needs
to be invoked in order to complete the operation.

If the procedure returns with \GASPIGERR{}, the reset request aborted abnormally
and the counter has an undefined value.

In both cases, \GASPITIME{} and \GASPIGERR{}, the \GASPI{} state vector
should be checked in order to deal with possibile failures.

\subsubsection{\gaspifunction{counter\_fetch\_add}}

The \gaspifunction{counter\_fetch\_add} procedure is a \gaspisemantic{synchronous}
\gaspisemantic{non-local} \gaspisemantic{time-based blocking} procedure
which atomically adds a given value to a global counter.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_counter_fetch_add ( gaspi_counter_id_t counter_id
                        , gaspi_counter_value_t value_add
                        , gaspi_counter_value_t value_old
                        , gaspi_timeout_t timeout
                        )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{counter\_id}{the global atomic counter to be used for the operation}
\parameterlistitem{in}{value\_add}{the value which is to be added to the global atomic counter}
\parameterlistitem{out}{value\_old}{the value of the counter before the operation}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}

\gaspifunction{counter\_fetch\_add} atomically adds the value of \parameter{value\_add} to
the value of the counter \parameter{counter\_id}.

After successful procedure completion, i.\,e.\ return value \GASPISUCC{}, the parameter
\parameter{value\_old} contains the value of the atomic counter before the operation
has been applied.

If the procedure returns with \GASPITIME{}, the fetch and add request could not be completed
during the given timeout. The parameter \parameter{value\_old} has an undefined value.
A subsequent call of \gaspifunction{counter\_fetch\_add} needs
to be invoked in order to complete the operation.

If the procedure returns with \GASPIGERR{}, the fetch and add request aborted abnormally.
The parameter \parameter{value\_old} as well as the counter have undefined values.

In both cases, \GASPITIME{} and \GASPIGERR{}, the \GASPI{} state vector
should be checked in order to deal with possible failures.

\subsubsection{\gaspifunction{counter\_compare\_swap}}

The \gaspifunction{counter\_compare\_swap} procedure is a \gaspisemantic{synchronous}
\gaspisemantic{non-local} \gaspisemantic{time-based blocking} procedure
which atomically compares the value of a global counter against some
user given value and in case these values are equal replaces the old
counter value by a new value.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_counter_compare_swap ( gaspi_counter_id_t counter_id
                           , gaspi_counter_value_t comparator
                           , gaspi_counter_value_t value_new
                           , gaspi_counter_value_t value_old
                           , gaspi_timeout_t timeout
                           )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{counter\_id}{the global atomic counter to be used for the operation}
\parameterlistitem{in}{comparator}{the value which is compared to the value of the counter}
\parameterlistitem{in}{value\_new}{the new value to which the counter is set if the result of the comparison is true}
\parameterlistitem{out}{value\_old}{the value of the counter before the operation}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}

\gaspifunction{counter\_compare\_swap} atomically compares the value of the
counter \parameter{counter\_id} to the value of \parameter{comparator}. If the
comparison is true, the counter is set to \parameter{value\_new}. If the comparison
is false, the counter keeps its value.

After successful procedure completion, i.\,e.\ return value \GASPISUCC{}, the parameter
\parameter{value\_old} contains the value of the atomic counter before the operation
has been applied.

If the procedure returns with \GASPITIME{}, the compare and swap request could not be completed
during the given timeout. The parameter \parameter{value\_old} has an undefined value.
A subsequent call of \gaspifunction{counter\_compare\_swap} needs
to be invoked in order to complete the operation.

If the procedure returns with \GASPIGERR{}, the compare and swap request aborted abnormally.
The parameter \parameter{value\_old} as well as the counter have an undefined value.

In both cases, \GASPITIME{} and \GASPIGERR{}, the \GASPI{} state vector
should be checked in order to deal with possible failures.

\subsubsection{Examples}

The example in \listref{lst:rsrclock} illustrates the usage of global atomic counters
for implementing a global resource lock. The example is implemented with
timeout.

\insertlisting{../examples/resource_lock/resource_lock.c}
        { \GASPI{} global resource lock implemented with atomic counters \label{lst:rsrclock} }


\section{Collective communication}
\label{sec:collectives}

\subsection{Introduction and overview}

Collective operations are collective with respect to a given group.
A becessary condition for successful collective procedure completion is that all
\GASPI{} processes forming the given group have invoked the operation.

Collective operations support both synchronous and asynchronous implementations as
well as time-based blocking. That means, progress towards successful procedure
completion can be achieved either inside a call (for a synchronous implementation)
or outside of the call (for an asynchronous implementation) before the procedure exits.
In the case of a timeout (which is indicated
by return value \GASPITIME{}) the operation is then continued in the
next call of the procedure. This implies that a collective operation
may involve several procedure calls until completion. Completion is
indicated by return value \GASPISUCC{}.

Collective operations are exclusive per group, i.\,e.\ only one collective
operation of a specific type on a given group can run at a given time. Starting a
specific collective operation before another one of the same kind is not
finished on all processes of the group
(and marked as such) is not allowed and yields undefined behavior.
For example, two allreduce operations for one group can not run at the same time; however,
an allreduce and a barrier operation can run at the same time.

The timeout is a necessary condition in order to be able to write
failure tolerant code. Timeout $=0$ makes an atomic portion of
progress in the operation if possible. If progress is possible, the
procedure returns as soon as the atomic portion of progress is
achieved. Otherwise, the procedure returns immediately. Here, an
atomic portion of progress is defined as the smallest set of
non-dividable instructions in the current state of the collective
operation.

Reduction operations can be defined by the application via callback
functions.

\begin{useradvice}
  Not every collective operation will be implementable in an
  asynchronous fashion -- for example if a user-defined callback
  function is used within a global reduction. Progress in this case
  can only be achieved inside of the call. Especially for large
  systems this implies that a collective potentially has to be called
  a substantial number of times in order to complete -- especially if
  used in combination with \GASPITEST{}. In this combination the
  called collective immediately returns (after completing local work)
  and never waits for data from remote processes. A corresponding
  code fragment in this case would assume the form:

\begin{listing}{1}
while (GASPI_allreduce_user ( buffer_send
                            , buffer_receive
                            , char num
                            , size_element
                            , reduce_operation
                            , reduce_state
                            , group
                            , GASPI_TEST
                            ) != GASPI_SUCCESS
     )
{
     work();
}
\end{listing}
\end{useradvice}

% The collectives have time-based blocking and single calls
% where the return code defines the state of the operation. The
% timeout mechanism is used to modify the operations behavior (blocking,
% non-blocking or time-based blocking).
%
% The collective operations
% are also allowed between groups of nodes. The timeout mechanism
% allows for synchronous collective operations.
%
% The single call means that we still have non-blocking operations (the
% function returns immediately unless we modify its behavior through
% the timeout behavior) and has to be called again ($n$ times, with $n >=
% 1$) to make sure the collective operation is finished. The
% implementation needs to make sure this is maintained correctly.

\subsection{Barrier synchronization}

\subsubsection{\gaspifunction{barrier}}

The \gaspifunction{barrier} procedure is a \gaspisemantic{synchronous}
\gaspisemantic{collective} \gaspisemantic{time-based blocking} procedure.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_barrier ( gaspi_group_t group
              , gaspi_timeout_t timeout
              )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{group}{the group of ranks which should participate in the barrier}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\executionphasework
\FStdRetDesc
\end{FDef}

\gaspifunction{barrier} blocks the caller until all group members
of \parameter{group} have invoked the procedure or
if \parameter{timeout} milliseconds have been reached since procedure
invocation. After successful procedure completion, i.\,e.\ return
value \GASPISUCC{}, all group members have invoked the procedure. In
case of \GASPITIME{} it is unknown whether or not all \GASPI{}
processes forming the given group have invoked the call

Progress towards successful \gaspifunction{barrier} completion is achieved even if the procedure
exits due to timeout. The barrier is then continued in the next call of the procedure. This implies that a
barrier operation may involve several \gaspifunction{barrier} calls until
completion.

Barrier operations are exclusive per group, i.\,e.\ only one barrier
operation on a given group can run at a time. Starting a
barrier operation in another thread before a previously invoked barrier is finished
on all processes of the group
is not allowed and yields undefined behavior.

In case of error, the return value is \GASPIGERR{}. The error vector should be
investigated.

\begin{useradvice}
The barrier is supposed to synchronize processes and not threads.
\end{useradvice}

\subsubsection{Examples}
In the following example a \gaspifunction{barrier} is interrupted
after \numprint[ms]{100} in order to check for errors.
\begin{listing}{1}
gaspi_return_t err;

do
  {
    err = gaspi_barrier (g, 100);

    if (err == GASPI_TIMEOUT && error vector indicates error)
      {
        goto ERROR_HANDLING;
      }
  }
while (err != GASPI_SUCCESS);
\end{listing}

The following example shows a non-blocking barrier. Some local work
(in this case: cleanup) is performed, overlapping it with the barrier
and only then is a full synchronization applied by calling the
barrier again with a blocking semantics (if needed).

\begin{listing}{1}
const gaspi_return_t err = GASPI_barrier (g, GASPI_TEST);

do_local_cleanup();

if (err != GASPI_ERROR)
{
    err = GASPI_barrier (g, GASPI_BLOCK);
}
\end{listing}

\subsection{Predefined global reduction operations}

\subsubsection{\gaspifunction{allreduce}}
\label{SubSec:allreduce}

The \gaspifunction{allreduce} procedure is a \gaspisemantic{synchronous}
\gaspisemantic{collective} \gaspisemantic{time-based blocking} procedure.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_allreduce ( gaspi_pointer_t buffer_send
                , gaspi_pointer_t buffer_receive
                , unsigned char num
                , gaspi_operation_t operation
                , gaspi_datatype_t datatype
                , gaspi_group_t group
                , gaspi_timeout_t timeout
                )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{buffer\_send}{pointer to the buffer where the input is placed}
\parameterlistitem{in}{buffer\_receive}{pointer to the buffer where the result is placed}
\parameterlistitem{in}{num}{the number of elements to be reduced on each process}
\parameterlistitem{in}{operation}{the \GASPI{} reduction operation type}
\parameterlistitem{in}{datatype}{the \GASPI{} element type}
\parameterlistitem{in}{group}{the group of ranks which participate in the reduction operation}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\executionphasework
\FStdRetDesc
\end{FDef}

\gaspifunction{allreduce} combines the \parameter{num} elements of
type \parameter{datatype} residing in \parameter{buffer\_send} on each
process in accordance with the given \parameter{operation}.  The
reduction operation is on a per element basis, i.\,e.\ the operation
is applied to each of the elements. \gaspifunction{allreduce} blocks
the caller until all data is available that is needed to calculate the
result or if \parameter{timeout} milliseconds have been reached since
procedure invocation. After successful procedure completion, i.\,e.\
return value \GASPISUCC{}, all group members have invoked the
procedure and \parameter{buffer\_receive} contains the result of the
reduction operation on every \GASPI{} process of \parameter{group}.
In case of \GASPITIME{} not all data is available that is needed to
calculate the result.

Progress towards successful \gaspifunction{allreduce} completion is achieved even if the procedure
exits due to timeout. The reduction operation is then continued in the next call of the procedure. This implies that a
reduction operation may involve several \gaspifunction{allreduce} calls until
completion.

Reduction operations are exclusive per group, i.\,e.\ only one reduction
operation on a given group can run at a time. Starting a
reduction operation for the same group in a separate thread before previously innvoked operation
is finished on all processes of the group
is not allowed and yields undefined behavior.

The \parameter{buffer\_send} as well as the \parameter{buffer\_receive} do not need
to reside in the global address space. \gaspifunction{allreduce} copies the send
buffer into an internal buffer at the first invocation. The result is copied from
an internal buffer into the receive buffer immediatley before the procedure returns
successfully.
The buffers need to have the appropriate
size to host all of the \parameter{num} elements. Otherwise the reduction operation yields
undefined behavior.
The maximum permissible number of elements
is implementation dependent and can be retrieved by \gaspifunction{allreduce\_elem\_max}.

%As soon as a \GASPI{} process invokes the reduction operation, all possible
%partial reduction operations are performed.

% Two simultaneous collective operations based for the same group are not allowed
% and result in undefined behavior.

In case of error, the return value is \GASPIGERR{}. The error vector should be
examined. \parameter{buffer\_receive} has an undefined value.

% Write and read accesses to \parameter{buffer\_send} as long as the \gaspifunction{allreduce}
% has not successfully completed are allowed.

In case of \GASPITIME{}, the reduction operation is not finished yet,
i.\,e.\ not all data is available that is needed to calculate the
result. The \parameter{buffer\_receive} has an undefined value.

\subsubsection{Predefined reduction operations}

There are three predefined reduction operations:

\begin{listing}[99]{2}
typedef enum { GASPI_OP_MIN
             , GASPI_OP_MAX
             , GASPI_OP_SUM
             } gaspi_operation_t;
\end{listing}

\begin{description}
\item[GASPI\_OP\_MIN] determines the minimum of the elements of each column of the input vector.
\item[GASPI\_OP\_MAX] determines the maximum of the elements of each column of the input vector.
\item[GASPI\_OP\_SUM] sums up all elements of each column of the input vector.
\end{description}


\subsubsection{Predefined types}

And the types are:
\begin{listing}[99]{2}
typedef enum { GASPI_TYPE_INT
             , GASPI_TYPE_UINT
             , GASPI_TYPE_LONG
             , GASPI_TYPE_ULONG
             , GASPI_TYPE_FLOAT
             , GASPI_TYPE_DOUBLE
             } gaspi_datatype_t;
\end{listing}

\begin{description}
\item[GASPI\_TYPE\_INT] integer
\item[GASPI\_TYPE\_UINT] unsigned integer
\item[GASPI\_TYPE\_LONG] long
\item[GASPI\_TYPE\_ULONG] unsigned long
\item[GASPI\_TYPE\_FLOAT] float
\item[GASPI\_TYPE\_DOUBLE] double
\end{description}


\subsection{User-defined global reduction operations}

\subsubsection{\gaspifunction{allreduce\_user}}

The procedure \gaspifunction{allreduce\_user} allows the user to specify its
own reduction operation. Only operations are supported which are
commutative and associative. It is a \gaspisemantic{synchronous}
\gaspisemantic{collective} \gaspisemantic{time-based blocking} procedure.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_allreduce_user ( gaspi_pointer_t buffer_send
                     , gaspi_pointer_t buffer_receive
                     , unsigned char num
                     , gaspi_size_t size_element
                     , gaspi_reduce_operation_t reduce_operation
                     , gaspi_reduce_state_t reduce_state
                     , gaspi_group_t group
                     , gaspi_timeout_t timeout
                     )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{buffer\_send}{pointer to the buffer where the input is placed}
\parameterlistitem{in}{buffer\_receive}{pointer to the buffer where the result is placed}
\parameterlistitem{in}{num}{the number of elements to be reduced on each process}
\parameterlistitem{in}{size\_element}{Size in bytes of one element to be reduced}
\parameterlistitem{in}{reduce\_operation}{pointer to the user defined reduction operation procedure}
\parameterlistitem{in,out}{reduce\_state}{reduction state vector}
\parameterlistitem{in}{group}{the group of ranks which participate in the reduction operation}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\executionphasework
\FStdRetDesc
\end{FDef}

\gaspifunction{allreduce\_user} has the same semantics as the predefined reduction operation
\gaspifunction{allreduce} described in the last section.

A user defined reduction operation \parameter{reduce\_operation} and a user
defined state \parameter{reduce\_state} are passed.

The elements on which the user defined reduction operation is applied
are described by their byte size \parameter{size\_element}. The entire
size of the data to be reduced, i.\,e.\ \parameter{num} times \parameter{size\_element},
must not be larger than the internal buffer size of \gaspifunction{allreduce\_user}.
The internal buffer size can be inquired by \gaspifunction{allreduce\_buf\_size}.

% In addition to the situation described in \secref{SubSec:allreduce}, the
% following state is given in accordance to the procedure return value.

% After successful procedure completion, i.\,e.\ return value \GASPISUCC{}, the
% \parameter{reduce\_state} contains the reduction state.
%
% In case of \GASPIGERR{}, \parameter{reduce\_state} has an undefined value.
% The same is true in case of \GASPITIME{}.

\subsubsection{User defined reduction operations}

The user defined reduction operation need to have the
following signature

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_reduce_operation ( gaspi_pointer_t operand_one
                       , gaspi_pointer_t operand_two
                       , gaspi_pointer_t result
                       , gaspi_state_t state
                       , gaspi_timeout_t timeout
                       )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{operand\_one}{pointer to the first operand}
\parameterlistitem{in}{operand\_two}{pointer to the second operand}
\parameterlistitem{in}{result}{pointer to the result}
\parameterlistitem{in}{state}{pointer to the state}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\FStdRetDesc
\end{FDef}

A pointer to the first operand and a pointer to the second operand
are passed. The result is stored in the memory represented by the
pointer \parameter{result}. In addition
to the actual data, also a state can be passed to the operator
which might be required in order to compute the result. In order to meet
real time system specifications, a timeout can
be passed to the user defined reduction operator. The reduction operator
should return \GASPI{} return value type with the same semantics, i.\,e.\
\GASPISUCC{} for successful procedure completion. \GASPITIME{}
in case of timeout and \GASPIGERR{} in case of error.

The user defined reduction operator needs to be commutative and associative.

The reduce operator type passed to \gaspifunction{allreduce\_user} is
a pointer to a function with the signature described above.

\begin{TDef}
\TDefDefn{\gaspifunction{reduce\_operation}*}{\gaspitype{reduce\_operation}}
\TDefDesc{The \GASPI{} reduction operation type}
\end{TDef}


\subsubsection{allreduce state}

The allreduce state type

\begin{TDef}
\TDefDefn{void*}{\gaspitype{state}}
\TDefDesc{The \GASPI{} reduction operation state type}
\end{TDef}

is a pointer to a state which may be passed to the user defined reduction
operation. A state may contain additional information  beside the actual
data to be reduced needed to perform the reduction operation.


%\subsubsection{Example}


\section{\GASPI{} getter functions}
\label{sec:getterfn}

The \GASPI{} specification provides getter functions for all entries in the \GASPI{} configuration.
These getter functions are \gaspisemantic{synchronous}
\gaspisemantic{local} \gaspisemantic{blocking} procedures which, after successful procedure completion (i.\,e.\ return value \GASPISUCC{}),
 return the corresponding value of the current configuration setting.

The values of the parameters in  the \GASPI{} configuration are determined in \gaspifunction{proc\_init} at
startup. If the value of one of these parameters is compliant with the system capabilities,
the parameter is set to the requested/preferred value. Otherwise, the parameter is set to the maximum value compliant
with the system capabilities. The values of the parameters realised in the \GASPI{} configuration are implementation specific.

In case of error, the return value is \GASPIGERR{} and the corresponding parameter in the getter function has an undefined value.

\subsection{Getter functions for group management}

\subsubsection{\gaspifunction{group\_max}}

% The \gaspifunction{group\_max} procedure
% is a \gaspisemantic{synchronous} \gaspisemantic{local}
% \gaspisemantic{blocking} procedure which returns
% the maximum number of allowed groups.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_group_max (gaspi_number_t group_max)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
  \parameterlistitem{out}{group\_max}{the total number of groups}
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}

\subsection{Getter functions for segment management}

\subsubsection{\gaspifunction{segment\_max}}

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_segment_max (gaspi_segment_id_t segment_max)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
  \parameterlistitem{out}{segment\_max}{the total number of permissible segments}
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}


\subsection{Getter functions for communication management}


\subsubsection{\gaspifunction{queue\_num}}

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_queue_num (gaspi_queue_id_t queue_max)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{queue\_max}{the maximum number of available queues}
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}

\subsubsection{\gaspifunction{queue\_size\_max}}

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_queue_size_max ( gaspi_queue_id_t queue
                     , gaspi_number_t queue_size
                     )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{queue}{the queue to probe}
\parameterlistitem{out}{queue\_size}{the number of simultaneous requests allowed}
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}

\subsubsection{\gaspifunction{transfer\_size\_max}}

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_transfer_size_max (gaspi_size_t transfer_size)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{transfer\_size}{the maximum transfer size allowed for a single request}
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}

\subsubsection{\gaspifunction{notification\_num}}

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_notification_num (gaspi_notification_id_t notification_max)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{notification\_max}{Maximum number of available notifications available}
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}

\subsection{Getter functions for passive communication}


\subsubsection{\gaspifunction{passive\_queue\_size\_max}}

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_passive_queue_size_max (gaspi_number_t queue_size)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{queue\_size}{Maximum number of requests allowed in the passive communication queue}
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}

\subsubsection{\gaspifunction{passive\_transfer\_size\_max}}

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_passive_transfer_size_max (gaspi_size_t transfer_size)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{transfer\_size}{maximal transfer size per single passive communication request}
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}

\subsection{Getter functions for atomic operations}

\subsubsection{\gaspifunction{counter\_num}}

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_counter_num (gaspi_number_t counter_max)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{counter\_max}{The number of global atomic counters available}
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}

\subsection{Getter functions for collective communication}

\subsubsection{\gaspifunction{allreduce\_elem\_max}}

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_allreduce_elem_max (gaspi_number_t elem_max)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{elem\_max}{the maximum number of elements allowed in \gaspifunction{allreduce}}
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}

\subsubsection{\gaspifunction{allreduce\_buf\_size}}

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_allreduce_buf_size (gaspi_number_t buf_size)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{buf\_size}{the size of the internal buffer in \gaspifunction{allreduce\_user}}
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}

\subsection{Getter functions related to infrastructure}

\subsubsection{\gaspifunction{network\_type}}

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_network_type (gaspi_network_t network_type)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{network\_type}{the chosen network type}
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}

\subsubsection{\gaspifunction{build\_infrastructure}}

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_build_infrastructure (gaspi_bool_t build_infrastructure)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{build\_infrastructure}{the current value of \parameter{build\_infrastructure}}
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}

\section{\GASPI{} Environmental Management}
\label{sec:envcheck}
\subsection{Implementation Information}

\subsubsection{\gaspifunction{version}}

The \gaspifunction{version} procedure is a \gaspisemantic{synchronous}
\gaspisemantic{local} \gaspisemantic{blocking}
procedure which determines the version of the running \GASPI{}
installation.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_version (float version)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{version}{The version of the running \GASPI{} installation}
\parameterlistend
\executionphaseany
\FStdRetDescNOTimeout
\end{FDef}

After successful procedure completion, i.\,e.\ return value \GASPISUCC{}
\parameter{version} contains the version of the running \GASPI{} installation.

In case of error, the return value is \GASPIGERR{}. The output parameter
\parameter{version} has an undefined value.

\subsection{Timing information}

\subsubsection{\gaspifunction{time\_get}}

The \gaspifunction{time\_get} procedure
is a \gaspisemantic{synchronous}
\gaspisemantic{local} \gaspisemantic{blocking}
procedure which determines the time elapsed since an arbitrary point of time in the past.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_time_get (gaspi_time_t wtime)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{wtime}{time elapsed in milliseconds}
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}

After successful procedure completion, i.\,e.\ return value \GASPISUCC{}, the parameter
\parameter{wtime} contains elapsed time in milliseconds since an arbitrary point in
the past. The parameter \parameter{wtime} is not synchronized among the different \GASPI{} processes.

In case of error, the return value is \GASPIGERR{}. The value of the output parameter
\parameter{wtime} is undefined.

\subsubsection{\gaspifunction{time\_ticks}}

The \gaspifunction{time\_ticks} procedure
is a \gaspisemantic{synchronous}
\gaspisemantic{local} \gaspisemantic{blocking}
procedure which returns the resolution of the internal timer in terms of milliseconds.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_time_ticks (gaspi_time_t resolution)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{resolution}{the resolution of the internal timer in milliseconds}
\parameterlistend
\executionphaseany
\FStdRetDescNOTimeout
\end{FDef}

After successful procedure completion, i.\,e.\ return value \GASPISUCC{}, the parameter
\parameter{resolution} contains the resolution of the internal timer in units of milliseconds.

In case of error, the return value is \GASPIGERR{}. The value of the output parameter
\parameter{resolution} is undefined.

\subsection{Error Codes and Classes}

\subsubsection{\GASPI{} error codes}

In principle all return values less than zero are error.
Every implementation is free to define specific error
codes.

\subsubsection{\gaspifunction{error\_message}}

The \gaspifunction{error\_message} procedure is a \gaspisemantic{synchronous}
\gaspisemantic{local} \gaspisemantic{blocking}
procedure which translates an error code to a text message.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_error_message ( gaspi_return_t error_code
                    , gaspi_string_t error_message
                    )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{error\_code}{the error code to be translated}
\parameterlistitem{out}{error\_message}{the error message}
\parameterlistend
\executionphaseany
\FStdRetDescNOTimeout
\end{FDef}

After successful procedure completion, i.\,e.\ return value \GASPISUCC{}
\parameter{error\_message} contains the error message corresponding to
the error code parameter{error\_code}.

In case of error, the return value is \GASPIGERR{}.

The procedure can be invoked in any of the \GASPI{} execution phases.

\section{Profiling Interface}


The profiling interface of \GASPI{} consists of two parts.
The statistics part provides the means to allow the user to collect basic profiling data about a program run.

\subsection{Statistics}

\subsubsection{\gaspifunction{statistic\_counter\_get}}

The \gaspifunction{statistic\_counter\_get} procedure is a \gaspisemantic{synchronous}
\gaspisemantic{local} \gaspisemantic{blocking}
procedure which retrieves a statistical counter from the local \GASPI{} process.

\GASPI{} provides a typed enumeration to determine a particular statistical counter.

\begin{listing}[99]{2}
typedef enum { GASPI_STATISTIC_BYTES_WRITTEN
             , GASPI_STATISTIC_BYTES_READ
             , GASPI_STATISTIC_BYTES_SEND
             , GASPI_STATISTIC_BYTES_RECEIVED
             } gaspi_statistic_counter_t;
\end{listing}

A \GASPI{} implementation is free to extend the above enumeration.


\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_statistic_counter_get ( gaspi_statistic_counter_t counter
                            , gaspi_statistic_value_t value
                            )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{counter}{the counter to be retrieved}
\parameterlistitem{out}{value}{the current value of the counter}
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}

After successful procedure completion, i.\,e.\ return value \GASPISUCC{}
\parameter{value} contains the current value of the corresponding counter.

\subsubsection{\gaspifunction{statistic\_counter\_reset}}

The \gaspifunction{statistic\_counter\_reset} procedure is a \gaspisemantic{synchronous}
\gaspisemantic{local} \gaspisemantic{blocking}
procedure which sets a statistical counter to 0.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_statistic_counter_reset (gaspi_statistic_counter_t counter)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{counter}{the counter to be reset}
\parameterlistend
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}

\subsubsection{\gaspifunction{statistic\_counter\_collect}}


The \gaspifunction{statistic\_counter\_collect} procedure is a \gaspisemantic{synchronous}
\gaspisemantic{collective} \gaspisemantic{time-based blocking} procedure.

\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_statistic_counter_collect ( gaspi_statistic_counter_t counter
                                , gaspi_statistic_value_t value
                                , gaspi_group_t group
                                , gaspi_timeout_t timeout
                                )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{counter}{the counter to be retrieved}
\parameterlistitem{out}{value}{the current value of the counter}
\parameterlistitem{in}{group}{the group of ranks which participate in the collect operation}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\executionphasework
\FStdRetDesc
\end{FDef}

The behavior of \gaspifunction{statistic\_counter\_collect} is equivalent to a call to \gaspifunction{allreduce} (see \ref{SubSec:allreduce})
with num = 1, operation = GASPI\_OP\_SUM and datatype = GASPI\_TYPE\_ULONG.

After successful procedure completion, i.\,e.\
return value \GASPISUCC{}, \parameter{value} contains the sum of the values of the corresponding \parameter{counter} of all ranks being a member of \parameter{group}.
The counter values delivered by every participating rank are equivalent to the values which would be returned by local calls to \gaspifunction{statistic\_counter\_get}.
That is, local calls to \gaspifunction{statistic\_counter\_reset} are respected.

Calls to \gaspifunction{statistic\_counter\_collect} do not contribute to the values of the collected counters at every rank.

In case of \GASPITIME{}, the reduction operation is not finished yet,
i.\,e.\ not all data is available that is needed to calculate the
result. \parameter{value} has an undefined value.

In case of error, the return value is \GASPIGERR{}. The error vector should be
examined. \parameter{value} has an undefined value.

%\subsection{Requirements}

%\subsection{Discussion}

%\subsection{Logic of the Design}

%\subsection{examples}

%\section{Language bindings}

%\subsection{C}

%\subsection{Fortran support}

\appendix

\section{Listings}

\subsection{success\_or\_die}
\insertlisting{../examples/success_or_die.h}{success\_or\_die.h\label{lst:success_or_die_h}}
\insertlisting{../examples/success_or_die.c}{success\_or\_die.c\label{lst:success_or_die_c}}

\subsection{wait\_if\_queue\_full}
\insertlisting{../examples/wait_if_queue_full.h}{wait\_if\_queue\_full.h\label{lst:wait_if_queue_full_h}}
\insertlisting{../examples/wait_if_queue_full.c}{wait\_if\_queue\_full.c\label{lst:wait_if_queue_full_c}}

%\todooverview

\end{document}

