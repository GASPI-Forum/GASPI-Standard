\documentclass[a4paper]{article}
\usepackage{doxygen}
\usepackage{framed}
\usepackage{color}
\usepackage{xcolor}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{colorkeyword}{rgb}{0.1,0.1,0.6}
\definecolor{colorassert}{rgb}{0.5,0.5,0.5}
\usepackage{tikz}\usetikzlibrary{automata,arrows,snakes,shapes}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{fixltx2e}
\usepackage{numprint}
\usepackage{booktabs}
\usepackage{xspace}
\usepackage{mparhack}
\usepackage{moreverb}
\usepackage{listings}
\usepackage{ifthen}
\setlength{\tabcolsep}{5pt}
\setlength{\arraycolsep}{5pt}
\setlength{\cmidrulekern}{4pt}
\newcommand{\secref}[1]{section\xspace\ref{#1}}
\newcommand{\figref}[1]{figure\xspace\ref{#1}}
\newcommand{\listref}[1]{listing\xspace\ref{#1}}
\newsavebox{\riddlebox}
\newlength{\lw}\setlength{\lw}{0.4pt}
\newlength{\st}\setlength{\st}{0pt}
\tikzstyle{every picture}+=[>=latex']
\tikzstyle{every picture}+=[bend angle=10]
\tikzstyle{every picture}+=[auto]
\tikzstyle{every picture}+=[join=round]
\tikzstyle{every picture}+=[cap=butt]
\tikzstyle{every picture}+=[line width=\lw]
\tikzstyle{every picture}+=[double distance=2\lw]
\tikzstyle{every picture}+=[shorten >=\st]
\tikzstyle{every picture}+=[node distance=4em]
\tikzstyle{every loop}=[->,shorten >=\st]
\tikzstyle{tight}=[inner sep=0pt,outer sep=0pt]
\tikzstyle{zero}=[draw=none,coordinate]
\newcommand{\zerowsep}{\hskip 0pt plus 0.1pt minus 0.1pt}
\makeatletter
\newcommand{\ZSEP}[1]{\ifx#1\@@@EOZ@@@\let\next\relax\else\ifx#1_#1\zerowsep\else#1\fi\let\next\ZSEP\fi\next}
\newcommand{\zsep}[1]{\ZSEP{}#1\@@@EOZ@@@}
\makeatother
\newcommand{\sol}[1]{\emph{\zsep{#1}}}
\newcommand{\gaspiprefix}{gaspi}
\newcommand{\GASPI}{{\sc Gaspi}}
\newcommand{\type}[1]{{\tt #1}}
\newcommand{\function}[1]{{\tt #1}}
\newcommand{\parameter}[1]{{\it #1}}
\newcommand{\gaspitype}[1]{\type{\protect\zsep{\gaspiprefix_#1_t}}}
\newcommand{\gaspifunction}[1]{\function{\protect\zsep{\gaspiprefix_#1}}}
\newcommand{\eg}{e.\,g.\ }
\newcommand{\ie}{i.\,e.\ }
\newcommand{\finalsymb}[1]{\leavevmode\unskip\penalty9999\hbox{}\nobreak\hfill\hskip 1em minus 0.5em\hbox{#1}}
\newenvironment{cbox}[1]
{\newcommand\colboxcolor{#1}\begin{lrbox}{\riddlebox}\begin{minipage}{\dimexpr\columnwidth-2\fboxsep\relax}}
{\end{minipage}\end{lrbox}\begin{center}\colorbox[HTML]{\colboxcolor}{\usebox{\riddlebox}}\end{center}}
\newcounter{counttodo}
\newlength{\savetabcolsep}
\newlength{\savearrayrulewidth}
\newenvironment{todo}
{\stepcounter{counttodo}
 \typeout{Environment TODO call \thecounttodo}
 \setlength{\savetabcolsep}{\tabcolsep}
 \setlength{\savearrayrulewidth}{\arrayrulewidth}
 \renewcommand{\tabcolsep}{0pt}
 \renewcommand{\arrayrulewidth}{2pt}
 \begin{center}
 \begin{tabular}{c|l@{\hspace*{2em}}|@{\hspace*{2em}}c}
 &
 \begin{minipage}{0.66\textwidth}
 \begin{itemize}
}
{\end{itemize}
 \end{minipage}
 &  todo \#\thecounttodo
 \end{tabular} \marginpar{\Longleftarrow}
 \end{center}
 \renewcommand{\tabcolsep}{\savetabcolsep}
 \renewcommand{\arrayrulewidth}{\savearrayrulewidth}
}
\newcommand{\todooverviewtext}
{***
 Counted {\thecounttodo} calls to environment TODO.
 EDIT THIS!
 ***
}
\newcommand{\todooverview}
{\newpage
 {\Large\bf \todooverviewtext}
 \typeout{\todooverviewtext}
}
\newcommand{\shortlistbegin}[1]{\begin{trivlist}\setlength{\itemsep}{0pt}\item[]\emph{#1:}}
\newcommand{\shortlistitem}[1]{\item[]#1}
\newcommand{\shortlistend}{\end{trivlist}}
\newenvironment{FDef}{\begin{trivlist}\item[]}{\end{trivlist}}
\newenvironment{FDefSign}{\begin{cbox}{EEEEEE}}{\end{cbox}}
\newcommand{\parameterlistbegin}{\shortlistbegin{Parameter}}
\newcommand{\parameterlistend}{\shortlistend}
\newcommand{\parameterlistitem}[3]{\shortlistitem{(#1) #2: {#3}}}
\newcommand{\fparameterbegin}{\begin{trivlist}\setlength{\itemsep}{0pt}}
\newcommand{\fparameterend}{\end{trivlist}}
\newcommand{\fparameteritem}[1]{\item[]{#1}}
\newcommand{\executionphase}[1]{\shortlistbegin{Execution phase}\shortlistitem{#1}\shortlistend}
\newcommand{\executionphasesetup}{\executionphase{Setup}}
\newcommand{\executionphaseinit}{\executionphase{Initialization}}
\newcommand{\executionphasework}{\executionphase{Working}}
\newcommand{\executionphaseshutdown}{\executionphase{Shutdown}}
\newcommand{\executionphaseany}{\executionphase{Any}}
\newcommand{\returnlistbegin}{\shortlistbegin{Return values}}
\newcommand{\returnlistend}{\shortlistend}
\newcommand{\returnlistitem}[2]{\item[]#1: #2}
\newcommand{\fdeffinal}{\finalsymb{\lrcorner}}
\newcommand{\GASPISUCC}{{\tt\protect\zsep{GASPI_SUCCESS}}}
\newcommand{\GASPISUCCTXT}{operation has returned successfully}
\newcommand{\GASPITIME}{{\tt\protect\zsep{GASPI_TIMEOUT}}}
\newcommand{\GASPITIMETXT}{operation has run into a timeout}
\newcommand{\GASPIGERR}{{\tt\protect\zsep{GASPI_ERROR}}}
\newcommand{\GASPIGERRTXT}{operation has finished with an error}
\newcommand{\GASPIGROUPALL}{{\tt\protect\zsep{GASPI_GROUP_ALL}}}
\newcommand{\GASPIALLOCDEF}{{\tt\protect\zsep{GASPI_ALLOC_DEFAULT}}}
\newcommand{\GASPITEST}{{\tt\protect\zsep{GASPI_TEST}}}
\newcommand{\GASPIBLOCK}{{\tt\protect\zsep{GASPI_BLOCK}}}
\newcommand{\FStdRetDesc}
{
  \returnlistbegin
  \returnlistitem{\GASPISUCC}{\GASPISUCCTXT}
  \returnlistitem{\GASPITIME}{\GASPITIMETXT}
  \returnlistitem{\GASPIGERR}{\GASPIGERRTXT}
  \fdeffinal\returnlistend
}
\newcommand{\FStdRetDescNOTimeout}
{
  \returnlistbegin
  \returnlistitem{\GASPISUCC}{\GASPISUCCTXT}
  \returnlistitem{\GASPIGERR}{\GASPIGERRTXT}
  \fdeffinal\returnlistend
}
\newcommand{\gaspisemantic}[1]{{\emph{#1}}}
\newenvironment{TDef}{\begin{trivlist}\item[]}{\finalsymb{\lrcorner}\end{trivlist}}
\newcommand{\TDefDefn}[2]{\begin{cbox}{EEEEEE}typedef {#1} {#2}\end{cbox}}
\newcommand{\TDefDef}[1]{\begin{cbox}{EEEEEE}{#1}\end{cbox}}
\newcommand{\TDefDesc}[1]{\item[]{\itshape{#1}}}
\newenvironment{implementoradvice}{\begin{flushright}\begin{minipage}[t]{0.9\linewidth}\emph{Implementor advice:}}{\finalsymb{\lrcorner}\end{minipage}\end{flushright}}
\newenvironment{useradvice}{\begin{flushright}\begin{minipage}[t]{0.9\linewidth}\emph{User advice:}}{\finalsymb{\lrcorner}\end{minipage}\end{flushright}}
\newenvironment{libadvice}{\begin{flushright}\begin{minipage}[t]{0.9\linewidth}\emph{Library implementor advice:}}{\finalsymb{\lrcorner}\end{minipage}\end{flushright}}
\newcommand{\enum}[1]{ {\it #1}}
\newcommand{\insertlisting}[2]{\lstset{
basicstyle=\ttfamily
, caption={#2}
, frame=single
, numbers=left
, numberstyle=\tiny
, stepnumber=1
, showstringspaces=true
, keepspaces=true
, columns=fullflexible
, classoffset=0
, morekeywords={gaspi_rank_t,gaspi_barrier,gaspi_timeout_t,gaspi_return_t,gaspi_config_t,gaspi_proc_init,gaspi_proc_term,gaspi_proc_kill
  ,gaspi_group_commit,gaspi_group_create,gaspi_group_add,gaspi_group_size,gaspi_group_ranks
  ,gaspi_segment_id_t,gaspi_segment_alloc,gaspi_segment_register,gaspi_segment_create
  ,gaspi_segment_ptr,gaspi_queue_id_t,gaspi_offset_t,gaspi_socket_id_t,gaspi_size_t,gaspi_pointer_t
  ,gaspi_write,gaspi_read,gaspi_wait
  ,gaspi_notify,gaspi_notify_reset,gaspi_notify_wait ,gaspi_atomic_value_t
  ,gaspi_proc_num,gaspi_proc_rank
  ,gaspi_number_t,gaspi_notification_t,gaspi_notification_id_t, gaspi_time_t
  ,gaspi_atomic_compare_swap,gaspi_atomic_set
  ,GASPI_SUCCESS,GASPI_TIMEOUT,GASPI_ERROR,GASPI_GROUP_ALL
  ,GASPI_BLOCK,GASPI_TEST,GASPI_CONFIGURATION_DEFAULT,GASPI_NORANK,GASPI_NOSTRING
  ,gaspi_notify_waitsome,gaspi_notify_size,gaspi_error_message
  ,gaspi_queue_size_max,gaspi_queue_size,gaspi_time_get
  ,gaspi_network_t, gaspi_number_t
  }
, commentstyle=\color{dkgreen}
, keywordstyle=\color{colorkeyword}
, classoffset=1
, morekeywords={ASSERT}
, keywordstyle=\color{colorassert}
, classoffset=0
}\lstinputlisting{#1}}
\title{GASPI: Global Address Space Programming Interface\\
~\\
Specification of a PGAS API for communication\\
~\\
Version 16.6
}
\begin{document}
\begin{titlepage}
\maketitle
\end{titlepage}
\tableofcontents
\newpage
\section{Introduction to GASPI}
\subsection{Overview and Goals}
GASPI stands for Global Address Space Programming Interface and
is a Partitioned Global Address Space (PGAS) API. It aims at
extreme scalability, high flexibility and failure tolerance for parallel
computing environments.  GASPI aims
to initiate a paradigm shift from bulk-synchronous two-sided
communication patterns towards an asynchronous communication and
execution model. To that end GASPI leverages remote completion and 
one-sided RDMA driven communication in a Partitioned Global Address Space.
GASPI is neither a new language (like Chapel from Cray), nor an
extension to a language (like Co-Array Fortran or UPC). Instead---very
much in the spirit of MPI---it complements existing languages like
C/C++ or Fortran with a PGAS API which enables the application to
leverage the concept of the Partitioned Global Adress Space. GASPI
is not limited to a single memory model, but rather provides
configurable RDMA PGAS memory segments. GASPI allows application
developers to map the memory heterogeneity of a modern supercomputer
node to these PGAS segments. As an example GASPI allows users to map
the main memory of a GPGPU or Xeon Phi to a specific segment, to
configure a GASPI segment per memory controller in a CC-NUMA system or
to map non-volatile RAM to a specific segment. All these segments can
directly read and write from/to each other - within the node and
across all nodes.  GASPI is failure tolerant in the sense that it
provides timeout mechanisms for all non-local procedures, failure
detection and the possibility to adapt to shrinking or growing node
sets.
\subsection{History}
The GASPI specification originates from the PGAS API of the Fraunhofer
ITWM (Fraunhofer Virtual Machine, FVM), which has been developed since
2005. Starting from 2007 this PGAS API has evolved into a robust
commercial product (called GPI) which is used in the industry projects
of the Fraunhofer ITWM. GPI offers a highly efficient and scalable
programming model for Partitioned Global Address Spaces and has
replaced MPI completely at Fraunhofer ITWM. In 2011 the partners of
Fraunhofer ITWM, Fraunhofer SCAI, TUD, T-Systems SfR, DLR, KIT, FZJ,
DWD and Scapos have initiated and launched the GASPI project to
define a novel specification for a PGAS API (GASPI, based on GPI) and to
make this novel GASPI specification a reliable, scalable and universal
tool for the HPC community.
\subsection{Design goals}
GASPI has been designed with the following goals in mind:
\begin{itemize}
\item Extreme scalability.
\item Efficient one sided asynchronous remote read/write operations based on remote completion.
\item Multi-segment support to support \eg heterogeneous systems and NUMA-pinning.
\item Dynamic allocation of segments.
\item Timeout mechanisms to allow failure tolerant programming.
\item Asynchronous collective operations for groups of processes.
\item Flexibility in the number of message queues, the queue sizes, atomic
  operations etc.
\item A maximum freedom to implementors, where details are left to the
  implementation.
\item A strong standard library which takes care of convenience
  procedures and cosmetics. The specification should be simple and solid.
\end{itemize}
\section{GASPI terms and conventions}
This section describes notational terms and conventions used
throughout the GASPI document.
\subsection{Naming Conventions}
All procedures are named in accordance with the following convention.
The procedures have \gaspifunction{} as a prefix. The prefix is
followed by the operation name.
\subsection{Procedure specification}
GASPI has adopted the procedure specification of MPI. Similar to the
MPI standard, procedures in GASPI hence are first specified using a
language independent notation.  Immediately below this, the arguments
of the procedure are given and marked as \textit{in} or
\textit{out}. The meanings of 
these are:
\begin{itemize}
\item the call uses but does not update an argument marked \textit{in}. For the C procedures these arguments are const-correct.
\item the call may update an argument marked \textit{out}.
\end{itemize}
Similar to MPI, in GASPI the passing of aliased procedure parameters
results in undefined behavior.
Below the procedure arguments the ANSI C version of the function is
shown, and below this, a version of the same function is shown for
Fortran 2003. For the latter the corresponding definitions and derived
types have to be include via
\begin{FDefSign}
\begin{verbatim}
use GASPI_C_BINDING
\end{verbatim}
\end{FDefSign}
\subsection{Semantic terms}
The following semantic terms are used throughout the document:
\newcommand{\septext}{0.5em}
\newcommand{\gentextwithline}[6]{
\draw (#2,#3) node[left] {#1};
\draw[#6] (#2+\septext+#4,#3) -- +(#5,0);
}
\newcommand{\timeline}[1]{\gentextwithline{Time}{0}{#1}{0}{25em}{->,dashed}}
\newcommand{\operation}[2]{\gentextwithline{Operation}{0}{#1}{1em}{#2}{|-|}}
\newcommand{\gencall}[3]{\gentextwithline{#1}{0}{#2}{0}{#3}{|-|}}
\newcommand{\call}[2]{\gencall{Call}{#1}{#2}}
\newcommand{\calls}[2]{\gencall{Calls}{#1}{#2-10em};
\draw[|-|] (#2-8em,#1) -- +(8em,0);
}
\newcommand{\wait}[3]{\gentextwithline{Wait}{#1}{#2}{0}{#3}{|-|}}
\newcommand{\progress}[2]{\gentextwithline{Progress}{0}{#1}{1em}{#2}{|-|}}
\begin{description}
\item[non-blocking] A procedure is non-blocking if the procedure may
  return before the operation completes.
\begin{center}
\begin{tikzpicture}
\timeline{\baselineskip};
\call{-\baselineskip}{10em};
\wait{15em}{-\baselineskip}{6em};
\operation{0}{19em};
\draw[->,dotted] (\septext,-\baselineskip) -- (\septext+1em,0em);
\draw[->,dotted] (19em+\septext+1em,0) -- (\septext+21em,-\baselineskip);
\end{tikzpicture}
\end{center}
\item[blocking] A procedure is blocking if the procedure only returns
  after the operation has completed.
\begin{center}
\begin{tikzpicture}
\timeline{\baselineskip};
\call{-\baselineskip}{21em};
\operation{0}{19em};
\draw[->,dotted] (\septext,-\baselineskip) -- (\septext+1em,0em);
\draw[->,dotted] (19em+\septext+1em,0) -- (\septext+21em,-\baselineskip);
\end{tikzpicture}
\end{center}
\item[time-based blocking] A procedure is time-based blocking if the
  procedure may return after the operation completes or after a given
  timeout has been reached. A corresponding return value is used to
  distinguish between the two cases.
\begin{center}
\begin{tikzpicture}
\timeline{\baselineskip};
\call{-\baselineskip}{16em};
\call{-2\baselineskip}{21em};
\operation{0}{19em};
\draw[->,dotted] (\septext,-\baselineskip) -- (\septext+1em,0em);
\draw[->,dotted] (19em+\septext+1em,0) -- (\septext+21em,-2\baselineskip);
\draw[->,dotted] (16em+\septext,\baselineskip) -- (16em+\septext,-\baselineskip);
\end{tikzpicture}
\end{center}
\item[local] A procedure is local if completion of the procedure depends
  only on the local executing GASPI process.
\item[non-local] A procedure is non-local if completion of the
  operation may depend on the existence (and execution) of a remote GASPI process
\item[collective] A procedure is collective if all processes in a
  process group need to invoke the procedure. A collective call may or
  may not be synchronising.
\item[predefined] A predefined type is a datatype with a predefined
  constant name.
\item[timeout] A timeout is a mechanism required by procedures that
  might block (see blocking above). Timeout here is defined as the
  maximum time (in milliseconds) a called procedure will wait for
  outstanding communication from other processes. The special value
  \numprint{0} (defined as \GASPITEST{}) indicates that the procedure
  will complete a portion of its work, if possible. The procedure subsequently
  returns the current status without waiting for data from other
  processes (non-blocking). On the other hand the special value
  \numprint{-1} (defined as \GASPIBLOCK{}) instructs the procedure to
  wait indefinitely (blocking).  A number greater than \numprint{0}
  indicates the maximum time the procedure will wait for data from
  other ranks (time-based blocking).  The timeouts hence are soft: The
  timeout value n does not imply that the called procedure will
  return after n milliseconds. It just means that the procedure
  should wait for at most n milliseconds for data from other
  processes.
\item[synchronous] A procedure is called synchronous if progress
  towards completion only is achieved as long as the application is
  inside (executing) the procedure.
\begin{center}
\begin{tikzpicture}
\timeline{\baselineskip};
\progress{0}{10em};
\draw[|-|] (14em,0) -- (19em,0);
\calls{-\baselineskip}{21em};
\draw[->,dotted] (\septext,-\baselineskip) -- (\septext+1em,0em);
\draw[->,dotted] (19em,0) -- (21em,-\baselineskip);
\draw[->,dotted] (\septext+11em,\baselineskip) -- (\septext+11em,-\baselineskip);
\draw[<-,dotted] (14em,0) -- (13em,-\baselineskip);
\end{tikzpicture}
\end{center}
\item[asynchronous]
  A procedure is called asynchronous if progress towards
  completion may be achieved after the procedure exits.
\begin{center}
\begin{tikzpicture}
\timeline{\baselineskip};
\progress{0}{15em};
\calls{-\baselineskip}{21em};
\draw[->,dotted] (\septext,-\baselineskip) -- (\septext+1em,0em);
\draw[->,dotted] (15em+\septext+1em,0) -- (21em,-\baselineskip);
\draw[->,dotted] (\septext+11em,\baselineskip) -- (\septext+11em,-\baselineskip);
\draw[<-,dotted] (14em,0) -- (13em,-\baselineskip);
\end{tikzpicture}
\end{center}
\end{description}
Please note that some of the semantic terms are not exclusive. Some of
them do overlap. According to the definition, a collective procedure
may also be a local procedure. Furthermore, a blocking procedure is
per definition also a synchronous procedure; the reverse statement is
not true.
\subsection{Examples}
The examples in this document are for illustration purposes only. They
are not intended to specify the semantics.
\section{GASPI concepts}
\subsection{Introduction and overview}
In this section, the basic GASPI concepts are introduced. A more detailed
description with the corresponding procedure specifications can be found
in the subsequent topic-specific sections.
GASPI is a communication API that implements a Partitioned Global
Address Space (\emph{PGAS}) model. Each GASPI process may host 
parts (called segments) of the global address space. A local segment 
can be accessed with standard load/store operations and remote segments
can be accessed by every thread of every GASPI process using the
GASPI read and write operations.
GASPI was designed with remote direct memory access (RDMA) in mind.
A network infrastructure that supports RDMA guarantees asynchronous and
one-sided communication operations without involving the CPU. This is
one of the main requirements for high scalability which results from
interference free communication, e.\,g.\ from overlapping communication
with computation.
\subsection{GASPI processes}
GASPI preserves the concept of ranks. Each GASPI process receives
a unique rank that identifies it during its runtime.
\subsection{GASPI groups}
A group is a subset of all processes. The group members
have common collective operations. A collective operation is then
restricted to the processes forming the group.
\subsection{GASPI segments}
Modern hardware typically involves a hierarchy of memory with respect
to the bandwidth and latencies of read and write accesses. Within that
hierarchy are non-uniform memory access (\emph{NUMA}) partitions,
solid state devices (\emph{SSD}s), graphical processing unit
(\emph{GPU}) memory or many integrated cores (\emph{MIC}) memory.  The
GASPI memory segments are supposed to map this variety of hardware
layers to the software layer. In the spirit of the PGAS approach,
these GASPI segments may be globally accessible from every thread
of every GASPI process.  GASPI segments can also be used to
leverage different memory models within a single application or to
even run different applications in a single Partitioned Global Address
Space.
\subsection{GASPI one-sided communication}
One-sided asynchronous communication is the basic communication
mechanism provided by GASPI. The one-sided communication comes in
two flavors.  There are read and write operations from and into the
Partitioned Global Address Space. For the write operations GASPI makes
use of the concept of remote completion in the form of so-called
notifications.  One-sided operations are non-blocking and
asynchronous, allowing the program to continue its execution along the
data transfer. The actual data transfer is managed by the underlying
network infrastructure.
\subsection{GASPI queues}
GASPI offers the possibility to use different queues to handle the
communication requests.  The requests can be submitted to one of the
supported queues. These queues allow more scalability and can be used
as channels for different types of requests where similar types of
requests are queued and then get synchronised together but
independently from the other ones (separation of concerns).  The
specification guarantees fairness of transfers posted to different
queues, i.\,e.\ no queue should see its communication requests delayed
indefinitely.
\insertlisting{ex.one_sided.pseudo}{Allgather with one-sided writes.}
\subsection{GASPI passive communication}
Passive communication has a two-sided semantic, where there is a
matching receive operation to a send request. Passive communication aims at
communication patterns where the sender is unknown (i.\,e.\ it can be any
process from the receiver perspective) but there is potentially the
need for synchronisation between different processes.
The receive operation is a blocking call that has as low interference
as possible (e.\,g.\ consumes no CPU cycles) and is ideally woken up
by the network layer. This passive communication allows for
fair distributed updates of globally shared parts of data.
\subsection{GASPI global atomics}
GASPI provides atomic operations for integral types, i.\,e. such
variables can be manipulated atomically without fear of preemption
causing corruption.  There are two basic atomic operations:
\function{fetch_and_add} and \function{compare_and_swap}. The
values can be used as global shared variables and to synchronise
processes or events.
The specification guarantees fairness, i.\,e.\ no process should see
its atomic operation delayed indefinitely.
\insertlisting{ex.atomic1.pseudo}{Dynamic work distribution: Clients
  atomically fetch a packet id and increment the value.}
\subsection{GASPI timeouts}
Failure tolerant parallel programs necessitate non-blocking
communication calls.  Hence, GASPI provides a timeout mechanism for
all potentially blocking procedures.
Timeouts for procedures are specified in milliseconds.
\GASPIBLOCK{} is a predefined timeout value which blocks the
procedure call until completion. This value
should not be used in failure tolerant programs, as it can block
for an indefinitely amount of time in case of an error.
\GASPITEST{} is another predefined timeout value which
blocks the procedure for the shortest time possible, \ie the time
in which the procedure call processes a portion of its work, if possible.
Examples:
\begin{lstlisting}[numbers=none,caption=Blocks until the communication queue is empty and may block indefinitely in case of a failure.]
WAIT (..., GASPI_BLOCK);
\end{lstlisting}
\begin{lstlisting}[numbers=none,caption=Just check if the operation has completed and return as soon as possible.]
WAIT (..., GASPI_TEST);
\end{lstlisting}
\begin{lstlisting}[numbers=none,caption=Blocks until the queue is empty or more than 10 milliseconds have passed since wait has been called.]
WAIT (..., 10);
\end{lstlisting}
\subsection{GASPI collective communication}
Collective communication is communication which involves a group of
GASPI processes. It is collective only for that group.
Collective operations can be either synchronous or asnychronous.
Synchronous implies that progress is achieved only as long as
the application is inside of the call. The call itself, however, may
be interrupted by a timeout. The operation is then continued in the
next call of the procedure. This implies that a collective operation
may involve several procedure calls until completion.
Collective operations are exclusive per group, i.\,e.\ only one collective operation 
of a specific type can run at a given time for a given group. For example,
two allreduce for one group cannot run at the same time; however, an
allreduce operation and a barrier can run at the same time.
\begin{implementoradvice}
  GASPI does not regulate whether individual collective operations
  should internally be handled synchronously or asynchronously,
  however: GASPI aims at an efficient, low-overhead programming
  model.  If asynchronous operation is supported, it should leverage
  external network-resources, rather than consuming CPU cycles.
\end{implementoradvice}
GASPI supports the following collective operations: barriers, reductions with predefined operations,
reductions with user defined operations.
Collective operations are/will be synchronized independently from the
operations on the communication queues.
\subsection{GASPI return values}
GASPI procedures have three general return values:
\begin{description}
 \item[\GASPISUCC{}] implies that the procedure has completed successfully.
 \item[\GASPITIME{}] implies that the procedure could not complete in the
  given period of time. This does not necessitate an error. The
  procedure has to be invoked subsequently in order to fully complete
  the operation.
 \item[\GASPIGERR{}] implies that the procedure has terminated due to an error.
  There are no predefined error values specifying the detailed cause of an error.
  \gaspifunction{error_message} translates the error code into a human
  readable format.
\end{description}
\begin{implementoradvice}
An implementation may provide specific error values. All error codes
in the range [-1,\ldots,-999] are reserved and must not be used.
If there are predefined error codes, each of the return codes must have
a corresponding error message.
\end{implementoradvice}
Additionally, each process has a state vector that contains the health state for
all processes. The state vector is set after non-local operations
and can be used to detect failures on remote processes.
\section{GASPI definitions}
\subsection{Types}
\begin{TDef}
\TDefDef{rank}
\TDefDesc{The GASPI rank type.}
\end{TDef}
\begin{TDef}
\TDefDef{segment_id}
\TDefDesc{The GASPI memory segment ID type.}
\end{TDef}
\begin{TDef}
\TDefDef{offset}
\TDefDesc{The GASPI offset type. Offsets are measured relative to
  the beginning of a memory segment in units of bytes.}
\end{TDef}
\begin{TDef}
\TDefDef{size}
\TDefDesc{The GASPI size type. Sizes are measured in units of bytes.}
\end{TDef}
\begin{TDef}
\TDefDef{queue_id}
\TDefDesc{The GASPI queue ID type.}
\end{TDef}
\begin{TDef}
\TDefDef{notification}
\TDefDesc{The GASPI notification type.}
\end{TDef}
\begin{implementoradvice} The sum of the sizes of notification and
tag should be at most 8 bytes in order to allow for Infiniband specific
optimizations.
\end{implementoradvice}
\begin{TDef}
\TDefDef{notification_id}
\TDefDesc{The GASPI notification ID type.}
\end{TDef}
\begin{implementoradvice} The sum of the sizes of
  notification should be at most 8 bytes in order to allow
  for Infiniband specific optimizations.
\end{implementoradvice}
\begin{TDef}
  \TDefDef{atomic_value} \TDefDesc{The GASPI global
    atomic value type. An atomic value is unsigned and its maximum
    value can be queried using \gaspifunction{atomic_max}.}
\end{TDef}
\begin{TDef}
\TDefDef{return}
\TDefDesc{The GASPI return value type.}
\end{TDef}
\begin{TDef}
\TDefDef{{\tt vector<return>}}{returns}
\TDefDesc{The vector type with return codes for individual processes. The
  length of the vector equals the number of processes in the GASPI
  program.}
\end{TDef}
\begin{TDef}
\TDefDef{timeout}
\TDefDesc{The GASPI timeout type.}
\end{TDef}
\begin{TDef}
\TDefDef{number}
\TDefDesc{A type that is used to count elements. That could be numbers
  of queues as well as the size of individual queues.}
\end{TDef}
\begin{TDef}
\TDefDef{group}
\TDefDesc{The GASPI group type.}
\end{TDef}
\begin{TDef}
\TDefDef{pointer}
\TDefDesc{A type that can point to some (area of) memory.}
\end{TDef}
\begin{TDef}
\TDefDef{const_pointer}
\TDefDesc{A type that can point to some (area of) memory that cannot be modified using this pointer.}
\end{TDef}
\begin{TDef}
\begin{FDefSign}
  memory_description
\end{FDefSign}
\TDefDesc{The GASPI memory description type used to describe
  properties of user provided memory.}
\end{TDef}
\begin{implementoradvice}
  The intention of memory_description is to describe
  properties of memory that is provided by the application,
  e.g. {\tt MEMORY_GPU} or {\tt MEMORY_HOST} might be relevant to an
  implementation.
\end{implementoradvice}
\begin{TDef}
\TDefDef{alloc}
\TDefDesc{The GASPI allocation policy type.}
\end{TDef}
\begin{TDef}
\TDefDef{network}
\TDefDesc{The GASPI network infrastructure type.}
\end{TDef}
\begin{TDef}
\TDefDef{string}
\TDefDesc{The GASPI constant string type.}
\end{TDef}
\begin{TDef}
\TDefDef{statistic_counter}
\TDefDesc{The GASPI statistic counter type.}
\end{TDef}
\subsection{Constants}
\subsubsection{Timeout values}
\begin{TDef}
\TDefDef{\GASPIBLOCK{}} 
\TDefDesc{\GASPIBLOCK{} is a timeout value which blocks a procedure call until completion.}
\end{TDef}
\begin{TDef}
\TDefDef{\GASPITEST{}} 
\TDefDesc{\GASPITEST{} is a timeout value which blocks a procedure call for the shortest time possible.}
\end{TDef}
\subsubsection{Function return values}
\begin{TDef}
\TDefDef{\GASPISUCC{}}
\TDefDesc{GASPI_SUCCESS is returned if a procedure call is completed successfully.}
\end{TDef}
\begin{TDef}
\TDefDef{\GASPITIME{}} 
\TDefDesc{GASPI_TIMEOUT is returned if a procedure call ran into a timeout.}
\end{TDef}
\begin{TDef}
\TDefDef{\GASPIGERR{}} 
\TDefDesc{GASPI_ERROR is returned if a procedure call finished with an error.}
\end{TDef}
\subsubsection{State vector states}
\begin{TDef}
\TDefDef{GASPI_STATE_HEALTHY} 
\TDefDesc{GASPI_STATE_HEALTHY implies that a remote GASPI process is healthy and communication is possible.}
\end{TDef}
\begin{TDef}
\TDefDef{GASPI_STATE_CORRUPT}
\TDefDesc{GASPI_STATE_CORRUPT implies that the remote GASPI process is corrupted and communication is impossible.}
\end{TDef}
\subsubsection{Allocation policies}
\begin{TDef}
\TDefDef{\GASPIALLOCDEF{}} 
\TDefDesc{The \GASPIALLOCDEF{} policy uses the operating systems default memory allocation policy.}
\end{TDef}
\begin{implementoradvice}
A GASPI implementation is free to provide additional allocation policies.
\end{implementoradvice}
\subsubsection{Statistics interface}
A GASPI implementation is free to define constants of the type statistic_counter for specific statistics.
\section{Execution model}
\subsection{Introduction and overview}
GASPI allows both SPMD (Single Program, Multiple Data) and MPMD
(Multiple Program, Multiple Data) style program execution.  Hence,
either a single program or different programs can be started on the
computational units. How a GASPI application is started and
initialized is implementation specific.
A rank is attributed to each created process. Ranks are a
central aspect as they allow applications to identify processes and
therefore allow to distribute work among the processes.
Furthermore, GASPI provides segments. Segments are 
globally accessible memory regions. In general,
the execution of a GASPI process can be considered as split
into several consecutive phases:
\begin{itemize}
\item \textbf{Setup (optional)}
  \begin{description}
  \item Setting up configuration parameters 
  \item Performing environment checks
  \end{description}
\item \textbf{Initialization}
  \begin{description}
  \item Initialization of the runtime environment
   \item Creation of segments or groups (optional)
  \end{description}
\item \textbf{Working (optional)}
  \begin{description}
    \item Communication calls
    \item Collective operations
    \item Atomic operations
  \end{description}
\item \textbf{Shutdown}
  \begin{description}
  \item Cleanup of communication infrastructure
  \end{description}
\end{itemize}
In the \textbf{setup} phase, the application may retrieve and modify
the GASPI configuration structure (see Sect.~\ref{subsubsec:confstruct})
determining the GASPI runtime behavior. Optionally (but
advisable), the application can perform environment checks (see
Sect.~\ref{sec:envcheck}) to make sure the application can be
started safely and correctly.
In the \textbf{initialization} phase, the GASPI runtime environment
is set up in accordance with the parameters of the configuration
structure by invocation of the initialization procedure.  The
initialization procedure is called before any other functionality,
with the exception of pre-initialization routines for environment
checking and declaration and retrieval of configuration parameters.
After the initialization routine has been called, an optional step to
perform is the creation of one or more segments and the creation of
one or more groups.  Segments are contiguous blocks of memory that may
be accessed globally by all processes and where global data should be
placed.
After the initialization, the application can proceed with its
\textbf{working} phase and use the functionalities of GASPI (communication,
collectives, atomic operations, etc.).
The application should call the
\textbf{shutdown} procedure (see Sect.~\ref{sec:shutdown}) before it is terminated
so that all resources and the communication infrastructure is cleaned up.
The entire set of execution phases define the GASPI life cycle.
In principle, several life cycles can be invoked in one GASPI
program.
Calling a routine in an execution phase in which it is not supposed
to be executed in results in undefined behavior.
\subsection{Process configuration}
\subsubsection{GASPI configuration structure}
The GASPI configuration structure describes the configuration parameters which
influence the GASPI runtime behavior.
Please note, that for simplicity of notation this is a C-style
definition. In bindings to other languages corresponding definitions
will be used.
\begin{lstlisting}[caption=GASPI configuration structure.]
typedef struct {
  // maximum number of groups
  gaspi_number_t     group_max;
  // maximum number of segments
  gaspi_number_t     segment_max
  // one-sided comm parameter
  gaspi_number_t     queue_num;
  gaspi_number_t     queue_size_max;
  gaspi_size_t       transfer_size_max;
  // notification parameter
  gaspi_number_t     notification_num;
  // passive comm parameter
  gaspi_number_t     passive_queue_size_max;
  gaspi_size_t       passive_transfer_size_max;
  // collective comm parameter
  gaspi_size_t       allreduce_buf_size;
  gaspi_number_t     allreduce_elem_max;
  // network selection parameter
  gaspi_network_t    network;
  // communication infrastructure build up notification
  gaspi_number_t       build_infrastructure;
  void *             user_defined;
} gaspi_config_t;
\end{lstlisting}
The definition of each of the configuration structure fields is as follows:
\begin{description}
\item[group_max] the desired maximum number of permissible groups per process. There is a hardware/implementation dependent maximum.
\item[segment_max] the desired number of maximally permissible segments per GASPI process.
There is a hardware/implementation dependent maximum.
\item[queue_num] the desired number of one-sided communication queues to be created. There is a hardware/implementation
dependent maximum.
\item[queue_size_max] the desired number of simultaneously allowed on-going requests on a one-sided communication queue.
There is a hardware/implementation dependent maximum.
\item[transfer_size_max] the desired maximum size of a single data
  transfer in the one-sided communication channel.
There is a hardware/implementation dependent maximum.
\item[notification_num] the desired number of internal notification buffers for weak synchronisation to be created.
There is a hardware/implementation dependent maximum.
\item[passive_queue_size_max] the desired number of simultaneously allowed on-going requests on the
passive communication queue. There is a hardware/implementation dependent maximum.
\item[passive_transfer_size_max] the desired maximum size of a
  single data transfer in the passive communication channel.
There is a hardware/implementation dependent maximum.
\item[allreduce_elem_max] the maximum number of elements in \gaspifunction{allreduce}.
There is a hardware/implementation dependent maximum.
\item[allreduce_buf_size] the size of the internal buffer of \gaspifunction{allreduce_user}.
There is a hardware/implementation dependent maximum.
\item[network] the network type to be used.
\item[build_infrastructure] indicates whether the communication infrastructure should
be built up at startup time. The default value is true.
\item[user_defined] some user defined information that is application / implementation dependent.
\end{description}
The default configuration structure can be retrieved by
\gaspifunction{config_get}.
Its default values are implementation dependent. If some of the
parameters are set by the program and assigned with
\gaspifunction{config_set}, the requested values are just proposals.
Depending on the underlying hardware capabilities, the implementation
is allowed to overrule these proposals.  \gaspifunction{config_set}
has to be used in order to commit modifications of the configuration
structure before the initialization routine is invoked.  The actual
values of the parameters can be retrieved by the corresponding
GASPI getter routines (see Sect.~\ref{sec:getterfn}) after the
successful program initialization. The values of the configuration
structure parameters need to be the same on all GASPI processes.
The user has the possibility to set the values on her own or leave the
default values. Each field (where applicable) also has a maximum value
to avoid user errors that might lead to too much instability or
scalability problems (for example, the number of queues).
\subsubsection{\gaspifunction{config_get}}
The \gaspifunction{config_get} procedure
is a synchronous local
blocking procedure which retrieves the
default configuration structure.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_CONFIG_GET ( config )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{config}{the default configuration}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_config_get ( gaspi_config_t *config )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_config_get(config) &
&   result( res ) bind(C, name="gaspi_config_get")
  type(gaspi_config_t) :: config
  integer(gaspi_return_t) :: res
end function gaspi_config_get
\end{verbatim}
\end{FDefSign}
\executionphasesetup
\FStdRetDescNOTimeout
\end{FDef}
After successful procedure completion, i.\,e.\ return value \GASPISUCC{},
config represents the default configuration.
In case of error, the return value is \GASPIGERR{}.
\subsubsection{\gaspifunction{config_set}}
The \gaspifunction{config_set} procedure
is a synchronous local
blocking procedure which sets the configuration
structure for process initialization.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_CONFIG_SET ( config )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{config}{the configuration structure to be set}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_config_set ( gaspi_config_t const config )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_config_set(new_config) &
&   result( res ) bind(C, name="gaspi_config_set")
  type(gaspi_config_t), value :: new_config
  integer(gaspi_return_t) :: res
end function gaspi_config_set
\end{verbatim}
\end{FDefSign}
\executionphasesetup
\FStdRetDescNOTimeout
\end{FDef}
After successful procedure completion, i.\,e.\ return value \GASPISUCC{},
the runtime parameters for the GASPI process initialization are set
in accordance with parameters of config.
In case of error, the return value is \GASPIGERR{}.
\subsection{Process management calls}
\subsubsection{\gaspifunction{proc_init}}
\gaspifunction{proc_init} implements the GASPI initialization
of the application. It is a non-local synchronous
time-based blocking procedure.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_PROC_INIT ( timeout )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_proc_init ( gaspi_timeout_t const timeout )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_proc_init(timeout_ms) &
&         result( res ) bind(C, name="gaspi_proc_init")
  integer(gaspi_timeout_t), value :: timeout_ms
  integer(gaspi_return_t) :: res
end function gaspi_proc_init
\end{verbatim}
\end{FDefSign}
\executionphaseinit
\FStdRetDesc
\end{FDef}
The explicit start of a GASPI process or launch from command line is
not specified. This is implementation dependent.
However, it is anticipated that \gaspifunction{proc_init} has information about the
list of hosts on which the entire GASPI application is running either by environment
variables, a command line argument, a daemon or some other mechanism.
The actual transfer of knowledge is implementation dependent.
\gaspifunction{proc_init} registers a given process at the other
remote GASPI processes and sets the corresponding entries in the
state vector to a healthy state.
If the parameter build_infrastructure in the configuration structure is set,
also the communication infrastructure for passive and one-sided communication to all
of the other processes is setup. Otherwise, there is no set up of communication infrastructure
during the initialization.
A rank is assigned to the given GASPI process in accordance with the position of the host
in the list. The GASPI process running on the first host in the list has rank zero. The
GASPI process running on the second host in the list has rank one and so on.
In case of a node failure, a GASPI process can be started on a new host, freshly allocated
or selected from a set of pre-allocated spare hosts,
by providing the list of machines in which the failed node is substituted by the new host.
The new GASPI process then has the rank of the GASPI process which
has been running on the failed node.
In case of the subsequent start of additional GASPI processes, the newly started
GASPI process registers with the other remote GASPI processes.
Note, that a subsequent change of the number of running
GASPI processes invalidates \GASPIGROUPALL{} for the old running processes.
Also the return value of \gaspifunction{proc_num} is changed.
The configuration structure should be created and modified by the
application before calling the \gaspifunction{proc_init} procedure.
After successful procedure completion, \gaspifunction{proc_init}
returns \GASPISUCC{} and it guarantees that the application has been
started on all hosts. In case that
the build_infrastructure is set, return value
\GASPISUCC{} also implies that the communication infrastructure is up
and ready to be used.
In case the application could not be initialized in line with the timeout
pa\-ra\-me\-ter, the return value is \GASPITIME{}. The application has not been initialized
yet. A subsequent invocation is required to completely initialize the application.
In case of error, the return value is \GASPIGERR{}. The application is not initialized.
\begin{implementoradvice}
Calling \gaspifunction{proc_init} with an enabled parameter build_infrastructure is semantically equivalent to
calling \gaspifunction{proc_init} with a disabled parameter build_infrastructure and subsequent calls to
\gaspifunction{connect} in which an all-to-all connection is established.
\end{implementoradvice}
\begin{useradvice}
For resource critical applications, it is recommended
to disable the parameter build_infrastructure in the configuration structure.
\end{useradvice}
\begin{useradvice}
A successful procedure completion does not mean that any communication or collective
operation can already be used. Connections might need to be established.
A segment has to be allocated for passive communication
capabilities. If one-sided communication is supposed to be used, than the segment has to be
registered in addition. If collective operations are needed, a group has to be created and
committed. 
\end{useradvice}
\subsubsection{\gaspifunction{proc_num}}
The total number of GASPI processes started, can be retrieved by
\gaspifunction{proc_num}.  This is a local
synchronous blocking procedure.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_PROC_NUM ( proc_num )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{proc_num}{the total number of GASPI processes}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_proc_num ( gaspi_rank_t *proc_num )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_proc_num(proc_num) &
&         result( res ) bind(C, name="gaspi_proc_num")
  integer(gaspi_rank_t) :: proc_num
  integer(gaspi_return_t) :: res
end function gaspi_proc_num
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}
If successful, the return value is \GASPISUCC{} and
\gaspifunction{proc_num} retrieves the total number of processes that
have been initialized and places this number in
the proc_num.
In case of error, the return value is \GASPIGERR{} and the value of
proc_num is undefined.
\subsubsection{\gaspifunction{proc_rank}}
A rank identifies a GASPI process. The rank of a process lies in the
interval [0,P) where P can be retrieved through
\gaspifunction{proc_num}. Each process has a unique rank associated with it.
The rank of the invoking GASPI process can be
retrieved by \gaspifunction{proc_rank}. It is a local synchronous
blocking procedure.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_PROC_RANK ( rank )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{rank}{the rank of the calling GASPI process.}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_proc_rank ( gaspi_rank_t *rank )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_proc_rank(rank) &
&         result( res ) bind(C, name="gaspi_proc_rank")
  integer(gaspi_rank_t) :: rank
  integer(gaspi_return_t) :: res
end function gaspi_proc_rank
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}
\gaspifunction{proc_rank} retrieves, if successful, the rank of the calling
process, placing it in the parameter rank and
returning \GASPISUCC{}.
In case of error, the return value is \GASPIGERR{} and the value of
the rank is undefined.
\subsubsection{\gaspifunction{proc_term}}
The shutdown procedure \gaspifunction{proc_term} is a
synchronous non-local
time-based blocking operation that releases resources
and performs the required clean\-up. There is no definition in the
specification of a verification of a healthy global state (i.\,e.\ all
processes terminated correctly).
After a shutdown call on a given GASPI process, it is undefined
behavior if another GASPI process tries to use any non-local GASPI
functionality involving that process{}.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_PROC_TERM ( timeout )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_proc_term ( gaspi_timeout_t timeout )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_proc_term(timeout_ms) &
&         result( res ) bind(C, name="gaspi_proc_term")
  integer(gaspi_timeout_t), value :: timeout_ms
  integer(gaspi_return_t) :: res
end function gaspi_proc_term
\end{verbatim}
\end{FDefSign}
\executionphaseshutdown
\FStdRetDesc
\end{FDef}
In case of successful procedure completion, i.\,e.\ return value
\GASPISUCC{}, the allocated GASPI specific resources of the
invoking GASPI process have been released. That means in particular
that the communication infrastructure is shut down, all committed
groups are released and all allocated segments are freed.
In case of timeout, i.\,e.\ return value \GASPITIME{}, the local resources
of the invoking GASPI process could not be completely released in the
given period of time. A subsequent invocation is required to
completely release all of the resources.
In case of error, i.\,e.\ return value \GASPIGERR{}, the resources of the
local GASPI process could not be released. The process is in
an undefined state.
\subsubsection{\gaspifunction{proc_kill}}
\gaspifunction{proc_kill} sends an interrupt signal to a given
GASPI process.  It is a synchronous
non-local time-based blocking
procedure.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_PROC_KILL ( rank
                , timeout )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{rank}{the rank of the process to be killed}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_proc_kill ( gaspi_rank_t rank
                , gaspi_timeout_t timeout )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_proc_kill(rank,timeout_ms) &
&         result( res ) bind(C, name="gaspi_proc_kill")
  integer(gaspi_rank_t), value :: rank
  integer(gaspi_timeout_t), value :: timeout_ms
  integer(gaspi_return_t) :: res
end function gaspi_proc_kill
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDesc
\end{FDef}
\gaspifunction{proc_kill} sends an interrupt signal to the GASPI process
incorporating the rank given by parameter rank. This can be
used, for example, to realise the registration of a user defined signal handler
function which ensures the controlled shut down of an entire GASPI application
at the global level
if the application receives an interrupt signal (\emph{STRG + C}) in the interactive master
process. Every GASPI application should register such or a
similar signal handler (c.\,f.\ \listref{lst:signal}).
In case of successful procedure completion, i.\,e.\ return value \GASPISUCC,
the remote GASPI process has been terminated.
In case of timeout, i.\,e.\ return value \GASPITIME, the remote GASPI
process could not be terminated in the given time. A subsequent invocation
of the procedure is needed in order to complete the operation.
In case of error, i.\,e.\ return value \GASPIGERR, the state of the remote
GASPI process is undefined.
\begin{useradvice}
The kill signal terminates a GASPI process in an uncontrolled way.
In this case, in order to provide a clean shutdown, it is advisable
to register a user defined signal callback function which guarantees
a clean shutdown.
\end{useradvice}
\subsubsection{Example}
The \listref{lst:hello_world} shows a GASPI "Hello world"
example. Please note that this example does not deal with failures.
\insertlisting{../examples/hello_world.c}{GASPI hello world example. }
Correspondingly the fortran version of  GASPI  "Hello world" assumes the form  \listref{lst:hello_world_f90}
\insertlisting{../examples/hello_world.f90}{GASPI hello world example in f90. }
The \listref{lst:signal} shows the registration of a user defined signal handler
function which ensures the controlled shut down of an entire GASPI application
at the global level
if the application receives an interrupt signal (\emph{STRG + C}) in the interactive master
process. Every GASPI application should register such or a
similar signal handler.
\insertlisting{../examples/signal_handler/signal.c}{Signal handling.}
\subsection{Connection management utilities}
\subsubsection{\gaspifunction{connect}}
In order to be able to communicate between two GASPI processes, the communication
infrastructure has to be established. This is
achieved with the synchronous non-local
time-based blocking procedure \gaspifunction{connect}.
It is bound to the working phase of the GASPI life cycle.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_CONNECT ( rank
              , timeout )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{rank}{ the remote rank with which the communication infrastructure is established}
\parameterlistitem{in}{timeout}{The timeout for the operation}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_connect ( gaspi_rank_t rank
              , gaspi_timeout_t timeout )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_connect(rank,timeout_ms) &
&         result( res ) bind(C, name="gaspi_connect")
  integer(gaspi_rank_t), value :: rank
  integer(gaspi_timeout_t), value :: timeout_ms
  integer(gaspi_return_t) :: res
end function gaspi_connect
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDesc
\end{FDef}
\gaspifunction{connect} builds up the communication infrastructure,
passive as well as one-sided and atomic operations, between the local
and the remote GASPI process representing rank
rank. The connection is bi-directional, i.\,e.\ it is sufficient
that \gaspifunction{connect} is invoked by only one of the connection partners.
In case of successful procedure completion, i.\,e.\ return value \GASPISUCC,
the communication infrastructure is established. If there is
an allocated segment, the segment can be used as a destination for passive
communication between the two nodes. In case the connection has already been established,
e.\,g.\ by the connection partner, the return value is \GASPISUCC{}.
In case of return value \GASPITIME, the communication infrastructure could not
be established between the local GASPI process and the remote GASPI process
in the given period of time.
In case of return value \GASPIGERR, the communication infrastructure could not
be established between the local GASPI process and the remote GASPI process.
In case of the latter two return values, a check of the state vector
by invocation of \gaspifunction{state_vec_get} gives information on
whether the remote GASPI process is still healthy.
\begin{useradvice}
Under the assumption that the GASPI process is initialized with parameter
build_infrastructure set to \emph{true}, all the
connections are set up at initialization time. Hence, a subsequent
call to \gaspifunction{connect} is superfluous in this case.
\end{useradvice}
\subsubsection{\gaspifunction{disconnect}}
The \gaspifunction{disconnect} procedure
is a synchronous local
blocking procedure which disconnects a given
process, identified by its rank, and frees all associated resources.
It is bound to the working phase of the GASPI life cycle.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_DISCONNECT ( rank
                 , timeout )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{rank}{ the remote rank from which the communication infrastructure is disconnected}
\parameterlistitem{in}{timeout}{The timeout for the operation}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_disconnect ( gaspi_rank_t rank
                 , gaspi_timeout_t timeout )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_disconnect(rank,timeout_ms) &
&         result( res ) bind(C, name="gaspi_disconnect")
  integer(gaspi_rank_t), value :: rank
  integer(gaspi_timeout_t), value :: timeout_ms
  integer(gaspi_return_t) :: res
end function gaspi_disconnect
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDesc
\end{FDef}
\gaspifunction{disconnect} disconnects the communication
infrastructure, passive as well as one-sided and atomic operations,
between the local and the remote GASPI process representing rank
rank. The connection is bi-directional, i.\,e.\ it is sufficient
if \gaspifunction{disconnect} is invoked by only one of the connection partners.
In case of successful procedure completion, i.\,e.\ return value \GASPISUCC,
the communication infrastructure is disconnected. Associated resources
are freed on the local as well as on the remote side.
In case the connection has already been disconnected,
e.\,g.\ by the connection partner, the return value is \GASPISUCC{}.
In case of error the return value is \GASPIGERR{}.
In case of return value \GASPITIME, the connection between the local
GASPI process and the remote GASPI process could not be
disconnected in the given period of time.
In case of the latter two return values local resources are freed and
a check of the state vector by invocation of
\gaspifunction{state_vec_get} gives information whether the remote
GASPI process is still healthy.
After successful procedure completion, i.\,e.\ return value \GASPISUCC{},
the connection is disconnected and can no longer be used.
\subsection{State vector for individual processes}
\subsubsection{Introduction}
A necessary pre-condition for realising a failure tolerant code is a
detailed know\-ledge about the state of the communication partners of
each local GASPI process.
GASPI provides a predefined type to describe the state of a remote
GASPI process, which is the state
type. state can have one of two values:
\begin{description}
 \item[GASPI_STATE_HEALTHY] implies that the remote GASPI process is healthy, i.\,e.\
communication is possible.
 \item[GASPI_STATE_CORRUPT] means that the remote GASPI
process is corrupted, i.\,e.\ there is no communication possible.
\end{description}
\begin{TDef}
\TDefDefn{{\tt vector<state>}}{state_vector}
\TDefDesc{state_vector is a vector with state information for individual processes. The
  length of the vector equals the number of processes in the GASPI
  program and the entries are ordered based on the process ranks, i.\,e.\ entry~0
  of the vector represents the state of process with the rank~0.}
\end{TDef}
There are procedures to query the state of the communication partners
after a given communication request and also to reset the state after
successful recovery. These are described in the following subsections.
The state vector does not provide a global view, instead each process has its own
state vector that may be different to the state vector of another process.
\subsubsection{\gaspifunction{state_vec_get}}
The state vector is obtained by the local synchronous
blocking function \gaspifunction{state_vec_get}.
The state vector represents the states of all GASPI processes.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_STATE_VEC_GET ( state_vector )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{returns}{the vector with individual return codes}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_state_vec_get ( gaspi_state_vector_t *state_vector )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_state_vec_get(state_vector) &
&         result( res ) bind(C, name="gaspi_state_vec_get")
  type(c_ptr), value :: state_vector
  integer(gaspi_return_t) :: res
end function gaspi_state_vec_get
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}
The state vector has one entry for each rank. It is created and
initialized during \gaspifunction{proc_init}. It is updated, case
required, in each of the following operations:
\begin{itemize}
\item group commitment
  \begin{itemize}
    \item \gaspifunction{group_commit}
  \end{itemize}
\item segment registration
  \begin{itemize}
    \item \gaspifunction{segment_register}
  \end{itemize}
\item one-sided communication
  \begin{itemize}
    \item \gaspifunction{wait}
    \item \gaspifunction{write}
    \item \gaspifunction{read}
    \item \gaspifunction{write_list}
    \item \gaspifunction{read_list}
    \item \gaspifunction{notify}
    \item \gaspifunction{write_notify}
    \item \gaspifunction{write_list_notify}
  \end{itemize}
\item passive communication
  \begin{itemize}
    \item \gaspifunction{passive_send}
    \item \gaspifunction{passive_receive}
  \end{itemize}
\item collective operations
  \begin{itemize}
    \item \gaspifunction{barrier}
    \item \gaspifunction{allreduce}
    \item \gaspifunction{allreduce_user}
  \end{itemize}
\item global atomic operations
  \begin{itemize}
    \item \gaspifunction{atomic_fetch_and_add}
    \item \gaspifunction{atomic_compare_swap}
  \end{itemize}
\end{itemize}
An update is not guaranteed to update all entries in the state vector,
but may only update the entries of the direct communication partners.
\gaspifunction{state_vec_get} retrieves in case of successful
completion, i.\,e.\ return value \GASPISUCC, the state vector.  It
contains the states of the GASPI processes with which the local
process has been communicating. All other entries are unmodified.
In case of error, the return value is \GASPIGERR{} and the value of
the state vector is undefined.
\begin{useradvice}
  For failure tolerant code, the state vector should be checked after
  each of the above procedure calls in case they return with either
  return value \GASPIGERR{} or \GASPITIME{}.
\end{useradvice}
\subsection{MPI Interoperability}
GASPI aims at providing interoperability with MPI in order to allow
for incremental porting of such applications.
The startup of mixed MPI and GASPI code is achieved by invoking
\gaspifunction{proc_init} in an existing MPI program.
This way, MPI takes care of distributing and starting the binary and
GASPI just takes care of setting up its internal infrastructure.
GASPI and MPI communication should not occur at the same time,
i.\,e.\ only the program layout given in
Listing~\ref{lst:embedded_gaspi} is supported
\insertlisting{../examples/mpi.interop.c}{Embedded GASPI program}
\subsection{Argument checks and performance}
GASPI aims at high performance and does not provide any argument checks
at procedure invocation per default.
\begin{implementoradvice}
The implementation should provide a specific library which includes
argument checks. The GASPI procedures should include out of bounds
checks, there.
\end{implementoradvice}
\section{Groups}
\subsection{Introduction}
Groups are subsets of the total number of GASPI processes. The group members
have common collective operations.  Each GASPI process may participate in more
than one group.
The use-cases are the collective operations provided in \secref{sec:collectives}
that make sense to be performed only for a subset of GASPI processes
in order to avoid a complete (all processes) collective synchronisation
point.
A group has to be defined and declared in each of the participating
GASPI processes. Defining a group is a three step procedure.  An
empty group has to be created first. Then the participating GASPI
processes, represented by their ranks, have to be attached. The group
definition is a local operation.  In order to activate the group, the
group has to be committed by each of the participating GASPI
processes. This is a collective operation for the group. Only after a
successful group commit, can the group be used for collective
operations.
The maximum number of groups allowed per GASPI process is
restricted by the implementation. A user defined value can be set with
\gaspifunction{config_set} before initialization
(\gaspifunction{proc_init}).
In case one group desintegrates due to some failure, the group has to
be re-established. If there is a new process replacing the failed one,
the group has to be defined and declared on the newly started GASPI
process(es).  Re-establishment of the group is then achieved by
recommitment of the group by the GASPI processes which were still
'alive' (functioning) and by the newly started GASPI process.
\subsection{GASPI group generics}
\subsubsection{GASPI group type}
Groups are specified with a special group type \verb|gaspi_group_t|.
\subsubsection{\GASPIGROUPALL{}}
\GASPIGROUPALL{} is a predefined default group that corresponds
to the whole set of GASPI processes. This is to be used for collective
operations that work for the whole system.
\begin{listing}[99]{2}
gaspi_group_t GASPI_GROUP_ALL;
\end{listing}
\begin{useradvice}
Note that \GASPIGROUPALL{} is a group definition like any other
sub group. In order to be used, \GASPIGROUPALL{} also has to be committed
by \gaspifunction{group_commit}.
\end{useradvice}
\subsection{Group creation}
\subsubsection{\gaspifunction{group_create}}
The \gaspifunction{group_create} procedure is a
synchronous local
blocking procedure which creates an empty group.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_GROUP_CREATE ( group )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{group}{the created empty group}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_group_create ( gaspi_group_t *group )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_group_create(group) &
&         result( res ) bind(C, name="gaspi_group_create")
  integer(gaspi_group_t) :: group
  integer(gaspi_return_t) :: res
end function gaspi_group_create
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}
After successful procedure completion, i.\,e.\ return value \GASPISUCC{},
group represents an empty group without any members.
In case of error, the return value is \GASPIGERR{}.
\subsubsection{\gaspifunction{group_add}}
The \gaspifunction{group_add} procedure is a
synchronous local
blocking procedure which adds a given rank to an
existing group.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_GROUP_ADD ( group
                , rank )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{inout}{group}{the group to which the rank is added}
\parameterlistitem{in}{rank}{the rank to add to the group}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_group_add ( gaspi_group_t group
                , gaspi_rank_t rank )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_group_add(group,rank) &
&         result( res ) bind(C, name="gaspi_group_add")
  integer(gaspi_group_t), value :: group
  integer(gaspi_rank_t), value :: rank
  integer(gaspi_return_t) :: res
end function gaspi_group_add
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}
After successful procedure completion, i.\,e.\ return value \GASPISUCC{},
the GASPI process with rank is added to group.
Whenever you add a rank the list of ranks is sorted in ascending order.
In case of error, the return value is \GASPIGERR{}.
\subsubsection{\gaspifunction{group_commit}}
The \gaspifunction{group_commit} procedure is a
synchronous collective
time-based blocking procedure which establishes a
group.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_GROUP_COMMIT ( group
                   , timeout )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{group}{the group to commit}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_group_commit ( gaspi_group_t group
                   , gaspi_timeout_t timeout )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_group_commit(group,timeout_ms) &
&         result( res ) bind(C, name="gaspi_group_commit")
  integer(gaspi_group_t), value :: group
  integer(gaspi_timeout_t), value :: timeout_ms
  integer(gaspi_return_t) :: res
end function gaspi_group_commit
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDesc
\end{FDef}
The group committed by all participating processes must contain all ranks and
must identical for all processes, otherwise the result is undefined.
After successful procedure completion, i.\,e.\ return value \GASPISUCC{},
the group given by the parameter group is
established. Collective operations invoked by the members of the group
are allowed from this moment on.
In case of timeout, i.\,e.\ return value \GASPITIME{}, the group could not be
established on all ranks forming the group in the given period of time.
The group is in an undefined state and collective operations  on
the group yield undefined behavior. A subsequent invocation is
required in order to completely establish the group.
In case of error, i.\,e.\ return value \GASPIGERR{}, the group could not be
established. The group is in an undefined state and collective operations
defined on the given group yield undefined behavior.
In both cases, \GASPITIME{} and \GASPIGERR{}, the GASPI state vector
should be checked in order to eliminate the possibility of a failure.
\begin{useradvice}
Any group commit should be performed only by a single thread of a process.
If two GASPI processes are members of two groups, then the
order of the group commits should be the same on both processes in
order to avoid deadlocks.
\end{useradvice}
\begin{implementoradvice}
If the parameter  build_infrastructure is not set, the procedure \gaspifunction{group_commit} must set up
the infrastructure for all possible operations of the group.
\end{implementoradvice}
\subsection{Group deletion}
\subsubsection{\gaspifunction{group_delete}}
The \gaspifunction{group_delete} procedure
is a synchronous local
blocking procedure which deletes
a given group.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_GROUP_DELETE ( group )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{group}{the group to be deleted}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_group_delete ( gaspi_group_t group )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_group_delete(group) &
&         result( res ) bind(C, name="gaspi_group_delete")
  integer(gaspi_group_t), value :: group
  integer(gaspi_return_t) :: res
end function gaspi_group_delete
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}
After successful procedure completion, i.\,e.\ return value \GASPISUCC{},
group is deleted and cannot be used further.
In case of error, the return value is \GASPIGERR{}.
\begin{implementoradvice}
If the parameter build_infrastructure is not set to true, the procedure \gaspifunction{group_delete} must disconnect
all connections which have been set up in the call to \gaspifunction{group_commit} and free all
associated resources.
\end{implementoradvice}
\subsection{Group utilities}
\subsubsection{\gaspifunction{group_num}}
The \gaspifunction{group_num} procedure
is a synchronous local
blocking procedure which returns
the current number of allocated groups.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_GROUP_NUM ( group_num )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{group_num}{the current number of groups}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_group_num ( gaspi_number_t *group_num )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_group_num(group_num) &
&         result( res ) bind(C, name="gaspi_group_num")
  integer(gaspi_number_t) :: group_num
  integer(gaspi_return_t) :: res
end function gaspi_group_num
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}
After successful procedure completion, i.\,e.\ return value \GASPISUCC{},
group_num contains the current number of allocated
groups. The value of group_num is related to the
parameter
group_max in the configuration structure and cannot
exceed that value. The value can be implementation specific.
\subsubsection{\gaspifunction{group_size}}
The \gaspifunction{group_size} procedure
is a synchronous local
blocking procedure which returns
the number of ranks of a given group.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_GROUP_SIZE ( group
                 , group_size )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{group}{the group to be examined}
\parameterlistitem{out}{group_size}{the number of ranks in a given group}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_group_size ( gaspi_group_t group
                 , gaspi_number_t *group_size )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_group_size(group,group_size) &
&         result( res ) bind(C, name="gaspi_group_size")
  integer(gaspi_group_t), value :: group
  integer(gaspi_number_t) :: group_size
  integer(gaspi_return_t) :: res
end function gaspi_group_size
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}
After successful procedure completion, i.\,e.\ return value \GASPISUCC{},
group_size contains the number of GASPI processes forming
the group.
In case of error, the return value is \GASPIGERR{}. The parameter
group_size has an undefined value.
\subsubsection{\gaspifunction{group_ranks}}
The \gaspifunction{group_ranks} procedure
is a synchronous local
blocking procedure which returns
a list of ranks of GASPI processes forming the group.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_GROUP_RANKS ( group
                  , group_ranks[group_size] )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{group}{the group to be examined}
\parameterlistitem{out}{group_ranks}{the list of ranks forming the group}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_group_ranks ( gaspi_group_t group
                  , gaspi_rank_t *group_ranks )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_group_ranks(group,group_ranks) &
&         result( res ) bind(C, name="gaspi_group_ranks")
  integer(gaspi_group_t), value :: group
  type(c_ptr), value :: group_ranks
  integer(gaspi_return_t) :: res
end function gaspi_group_ranks
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}
After successful procedure completion, i.\,e.\ return value
\GASPISUCC{}, the list group_ranks contains the ranks of
the processes that belong to the group. The list is not
allocated by the procedure. The list allocation is supposed to be done
outside of the procedure.  The size of the list can be inquired by
\gaspifunction{group_size}.
In case of error, the return value is \GASPIGERR{}. The list
group_ranks has an undefined value.
\section{GASPI segments}
\subsection{Introduction and overview}
Modern hardware has a complex memory hierarchy with different
bandwidth and latencies for read and write accesses. Among them are
non-uniform memory access (\emph{NUMA}) partitions, solid state
devices (\emph{SSD}s), graphical processing unit (\emph{GPU}) memory
or many integrated cores (\emph{MIC}) memory.
The GASPI memory segments are thus an abstraction representing
any kind of memory level, mapping the variety of hardware layers to the
software layer. A segment is a contiguous block of virtual memory.
In the spirit of the PGAS approach, these GASPI
segments may be globally accessible from every thread of every GASPI
process and represent the partitions of the global address space.
By means of the GASPI memory segments it is also possible for multiple
memory models or indeed multiple applications to share a single Partitioned Global
Address Space.
Since segment allocation is expensive and the total number of supported
segments is limited due to hardware constraints, the GASPI memory
management paradigm is the following.
GASPI provides only a few relatively large segments.
Allocations inside of the pre-allocated segment memory are managed
by the application.
Every GASPI process may possess a certain number of segments (not
necessarily equal to the number possessed by the other ranks) that may be accessed as common memory,
whether locally ---with normal memory operations---or remotely---with
the communication routines of GASPI.
In order to use a segment for communication between two processes,
some setup steps are required in general.
A memory segment has to be allocated in each of the processes
by the local procedure \gaspifunction{segment_alloc}.
In order to also use the segments for one-sided communication, the memory segment
has to be registered on the remote process which will
access the memory segment at some point. This is achieved by the
non-local procedure \gaspifunction{segment_register}.
\begin{useradvice}
  If the parameter build_infrastructure is not set, a
  connection has to be established between the processes before the
  segment can be registered at the remote process. This is
  accomplished by calling the procedure \gaspifunction{connect}.
\end{useradvice}
\gaspifunction{segment_create} unites these steps into a single
collective procedure for an entire group. After successful
procedure completion, a common segment is created on each GASPI
process forming the group which can be immediately used for communication
among the group members.
During the lifetime of an application no segment is available
unless it is explicitly created with \gaspifunction{segment_alloc}
or \gaspifunction{segment_create} after the GASPI startup.
\subsection{Segment creation}
\subsubsection{\gaspifunction{segment_alloc}}
The synchronous local
blocking procedure \gaspifunction{segment_alloc}
allocates a memory segment and optionally maps it in accordance with a
given allocation policy.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_SEGMENT_ALLOC ( segment_id
                    , size
                    , alloc_policy )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{segment_id}{ The segment ID to be created. The segment IDs need to be
                                     unique on each GASPI process}
\parameterlistitem{in}{size}{The size of the segment in bytes}
\parameterlistitem{in}{alloc_policy}{allocation policy}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_segment_alloc ( gaspi_segment_id_t segment_id
                    , gaspi_size_t size
                    , gaspi_alloc_t alloc_policy )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_segment_alloc(segment_id,size,alloc_policy) &
&         result( res ) bind(C, name="gaspi_segment_alloc")
  integer(gaspi_segment_id_t), value :: segment_id
  integer(gaspi_size_t), value :: size
  integer(gaspi_alloc_t), value :: alloc_policy
  integer(gaspi_return_t) :: res
end function gaspi_segment_alloc
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}
\gaspifunction{segment_alloc} allocates a segment of
size size that will be referenced by
the segment_id identifier. This identifier parameter has
to be unique in the local GASPI process. Creating a new segment
with an existing segment ID results in undefined behavior. Note that
the total number of segments is restricted by the underlying hardware
capabilities. The maximum number of supported segments can be
retrieved by invoking \gaspifunction{segment_max}. 
Allocation of segments in GASPI allows for various so-called
policies.  The default policy in a cc-numa mode for example might be
an allocation of socket-local memory, a different policy might allow
to map GPU memory into the main memory of the host and yet another
policy might allow for a direct access of external non-volatile RAM.
The alloc_policy is used to pass an allocation
policy. The default allocation policy behavior is left to the
implementation.  The default allocation parameter is
GASPI_ALLOC_DEFAULT.
After successful procedure completion, i.\,e.\ return value \GASPISUCC{},
the segment can be accessed locally.
In case that there is a connection established to a remote GASPI process,
it can also be used for passive communication between the two GASPI processes.
(Note that this is always the case if the process has been initialized
with the parameter build_infrastructure set to \emph{true}),
it can also be used for passive communication between the two GASPI processes;
either as a source segment for \gaspifunction{passive_send} or as a
destination segment for \gaspifunction{passive_receive}.
A return value \GASPIGERR{} indicates that the segment allocation
failed and the segment cannot be used.
\begin{useradvice}
  A GASPI implementation may allocate more memory than requested by the
  application for internal management.
\end{useradvice}
\begin{implementoradvice}
  In case of non-uniform memory access architectures, the memory
  should be allocated close to the calling process. The allocation
  policy of the calling process should not be modified.
\end{implementoradvice}
\subsubsection{\gaspifunction{segment_register}}
In order to be used in a one-sided communication request on an existing connection,
a segment allocated by \gaspifunction{segment_alloc} needs to be made visible and
accessible for the other GASPI processes.
This is accomplished by the procedure \gaspifunction{segment_register}.
It is a synchronous non-local
time-based blocking procedure.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_SEGMENT_REGISTER ( segment_id
                       , rank
                       , timeout )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{segment_id}{ The segment ID to be registered. The segment ID's need to be
                                     unique for each GASPI process}
\parameterlistitem{in}{rank}{The rank of the GASPI process which should register the new segment}
\parameterlistitem{in}{timeout}{The timeout for the operation}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_segment_register ( gaspi_segment_id_t segment_id
                       , gaspi_rank_t rank
                       , gaspi_timeout_t timeout )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_segment_register(segment_id,rank,timeout_ms) &
&         result( res ) bind(C, name="gaspi_segment_register")
  integer(gaspi_segment_id_t), value :: segment_id
  integer(gaspi_rank_t), value :: rank
  integer(gaspi_timeout_t), value :: timeout_ms
  integer(gaspi_return_t) :: res
end function gaspi_segment_register
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDesc
\end{FDef}
\gaspifunction{segment_register} makes the segment referenced by
the segment_id identifier visible and accessible to
the GASPI process with the associated rank.
\begin{useradvice}
  If the parameter build_infrastructure is not set, a
  connection has to be established between the processes before the
  segment can be registered at the remote process. This is
  accomplished calling the procedure \gaspifunction{connect}.
\end{useradvice}
In case of successful procedure completion, i.\,e.\ return value \GASPISUCC,
the local segment can be used for one-sided communication requests which are
invoked by the given remote process.
In case of return value \GASPITIME{}, the segment could not be registered
in the given period of time. The segment cannot be used for one-sided
communication requests which are invoked by the given remote process.
A subsequent call of \gaspifunction{segment_register} has to be
invoked in order to complete the registration request.
In case of return value \GASPIGERR{}, the segment could not be registered
on the remote side. The segment cannot be used for one-sided communication
requests which are invoked by the given remote process.
In case of the latter two return values, a check of the state vector
by invocation of \gaspifunction{state_vec_get} gives information as to
whether or not the remote GASPI process is still healthy.
\begin{useradvice}
  Note that a local return value \GASPISUCC{} does not imply that the
  remote process is informed explicitly that the segment is
  accessible. This can be achieved through an explicit
  synchronisation, either by one of the collective operations or by an
  explicit notification.
\end{useradvice}
\subsubsection{\gaspifunction{segment_create}}
\gaspifunction{segment_create} is a synchronous
collective time-based blocking
procedure. It is semantically equivalent to a collective aggregation
of \gaspifunction{segment_alloc}, \gaspifunction{segment_register}
and \gaspifunction{barrier} involving all of the members of a given
group.  If the communication infrastructure was not established for
all group members beforehand, \gaspifunction{segment_create} will
accomplish this as well.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_SEGMENT_CREATE ( segment_id
                     , size
                     , group
                     , timeout
                     , alloc_policy )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{segment_id}{The ID for the segment to be created. The segment ID's need to be
      unique for each GASPI process}
\parameterlistitem{in}{size}{The size of the segment in bytes}
\parameterlistitem{in}{group}{The group which should create the segment}
\parameterlistitem{in}{timeout}{The timeout for the operation}
\parameterlistitem{in}{alloc_policy}{allocation policy}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_segment_create ( gaspi_segment_id_t segment_id
                     , gaspi_size_t size
                     , gaspi_group_t group
                     , gaspi_timeout_t timeout
                     , gaspi_alloc_t alloc_policy )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_segment_create(segment_id,size,group, &
&         timeout_ms,alloc_policy) &
&         result( res ) bind(C, name="gaspi_segment_create")
  integer(gaspi_segment_id_t), value :: segment_id
  integer(gaspi_size_t), value :: size
  integer(gaspi_group_t), value :: group
  integer(gaspi_timeout_t), value :: timeout_ms
  integer(gaspi_alloc_t), value :: alloc_policy
  integer(gaspi_return_t) :: res
end function gaspi_segment_create
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDesc
\end{FDef}
\gaspifunction{segment_create} allocates a segment of
size size that will be referenced by
the segment_id identifier. This identifier parameter has
to be unique on the local GASPI process. Creating a new segment with
an existing segment ID results in undefined behavior.
\gaspifunction{segment_create} makes the segment
referenced by the segment_id identifier visible and accessible to
all of the GASPI processes forming the group group.
The maximum number of supported segments can be retrieved
by invoking \gaspifunction{segment_max}.
The alloc_policy
is used to pass an allocation policy. The default allocation policy behavior is left to the implementation.
After successful procedure completion, i.\,e.\ \GASPISUCC{}, the
segment can be accessed locally and it can be used as a destination
for the passive communication channel. Either as a source segment for
\gaspifunction{passive_send} or as a destination segment for
\gaspifunction{passive_receive}.  Furthermore, it can be used for
one-sided communication requests, which are invoked by the remote
processes forming the group group or global atomic
operations. The segment segment_id is ready to be used.
For consistency and programs with hard failure tolerance requirements,
the operation must be performed within timeout
milliseconds. In case of return value \GASPITIME{}, progress has been
achieved, however the operation could not be completed in the given
timeout.
The segment cannot be used locally neither remotely. The segment
cannot be used for one-sided or passive communication requests which
are invoked by the other remote processes forming the group. The same
applies to global atomic operations.  A subsequent call of
\gaspifunction{segment_create} has to be invoked in order to complete
the segment creation.
In case of return value \GASPIGERR{}, the segment creation failed in
one of the above progress steps on at least one of the involved
GASPI processes.  The segment cannot be used locally neither
remotely. The segment cannot be used for one-sided or passive
communication requests which are invoked by the other remote processes
forming the group. The same applies to global atomic operations.
In case of the latter two return values, a check of the state vector
by invocation of \gaspifunction{state_vec_get} gives information
whether the involved remote GASPI processes are still healthy.
\begin{useradvice}
  A GASPI implementation may allocate more memory than requested by the
  application for internal management.
\end{useradvice}
\begin{implementoradvice}
In case of non-uniform memory access architectures, the memory should be allocated
close to the calling process. The allocation policy of the calling process should
not be modified.
\end{implementoradvice}
\subsubsection{\gaspifunction{segment_bind}}
The synchronous local
blocking procedure \gaspifunction{segment_bind} binds
a segment id to user provided memory.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_SEGMENT_BIND ( segment_id
                   , pointer
                   , size
                   , memory_description
                   )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{segment_id}{Unique segment ID to bind.}
\parameterlistitem{in}{pointer}{The begin of the memory provided by
  the user.}
\parameterlistitem{in}{size}{The size of the memory provided by
  pointer in bytes.}
\parameterlistitem{in}{memory_description}{The description of the
  memory provided.}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t 
gaspi_segment_bind ( gaspi_segment_id_t const segment_id
                   , gaspi_pointer_t const pointer
                   , gaspi_size_t const size
                   , gaspi_memory_description_t const memory_description
                   )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_segment_bind ( segment_id                  &
&                           , pointer                     &
&                           , size                        &
&                           , memory_description          &
&                           )                             &
&        result (res) bind (C, name="gaspi_segment_bind")
  integer (gaspi_segment_id_t), value :: segment_id
  type (c_ptr), value :: pointer
  integer (gaspi_size_t), value :: size
  integer (gaspi_memory_description_t), value :: memory_description
  integer (gaspi_return_t) :: res
end function gaspi_segment_bind
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}
\gaspifunction{segment_bind} binds the segment identified by the
identifier segment_id to the user provided memory of size
size located at the address pointer. To
provide less than size bytes results in undefined
behavior. The identifier segment_id must be unique in the
local GASPI process. Bind to a segment with an existing segment ID
(regardless of bind or allocated) results in undefined behavior. Note
that the total number of segments is restricted by the underlying
hardware capabilities. The maximum number of supported segments can
be retrieved by invoking \gaspifunction{segment_max}.
To bind successfully the user provided memory must satisfy
implementation specific constraints, e.\,g.\ alignment constraints.
After successful procedure completion, i.\,e.\ return value
\GASPISUCC{}, the segment can be accessed locally and has the same
capabilities like a segment that was allocated by a successful call to
\gaspifunction{segment_alloc}.
If the procedure returns with \GASPIGERR{}, the bind has failed and
the segment can not be used.
\begin{useradvice}
  A GASPI implementation may allocate additional memory for
  internal management. Depending on the implementation it might be
  required that the management memory must reside on the same device
  as the provided memory.
\end{useradvice}
\subsubsection{\gaspifunction{segment_use}}
The synchronous collective
time-based blocking procedure
\gaspifunction{segment_use} is semantically equivalent to a
collective aggregation of \gaspifunction{segment_bind},
\gaspifunction{segment_register} and \gaspifunction{barrier}
involving all members of a given group. If the communication
infrastructure was not established for all group members beforehand,
\gaspifunction{segment_use} will accomplish this as well.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_SEGMENT_USE ( segment_id
                  , pointer
                  , size
                  , group
                  , timeout
                  , memory_description
                  )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{segment_id}{Unique segment ID to bind.}
\parameterlistitem{in}{pointer}{The begin of the memory provided by
  the user.}
\parameterlistitem{in}{size}{The size of the memory provided by
  pointer in bytes.}
\parameterlistitem{in}{group}{The group which should create the segment.}
\parameterlistitem{in}{timeout}{The timeout for the operation.}
\parameterlistitem{in}{memory_description}{The description of the
  memory provided.}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t 
gaspi_segment_use ( gaspi_segment_id_t const segment_id
                  , gaspi_pointer_t const pointer
                  , gaspi_size_t const size
                  , gaspi_group_t const group
                  , gaspi_timeout_t const timeout
                  , gaspi_memory_description_t const memory_description
                  ) 
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_segment_use ( segment_id                  &
&                          , pointer                     &
&                          , size                        &
&                          , group                       &
&                          , timeout                     &
&                          , memory_description          &
&                          )                             &
&        result (res) bind (C, name="gaspi_segment_use")
  integer (gaspi_segment_id_t), value :: segment_id
  type (c_ptr), value :: pointer
  integer (gaspi_size_t), value :: size
  integer (gaspi_group_t), value :: group
  integer (gaspi_timeout_t), value :: timeout
  integer (gaspi_memory_description_t), value :: memory_description
  integer (gaspi_return_t) :: res
end function gaspi_segment_use
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDesc
\end{FDef}
\gaspifunction{segment_use} binds the segment identified by the
identifier segment_id to the user provided memory of size
size located at the address pointer. To
provide a size larger than the actual buffer size pointed
by pointer results in undefined
behavior. \gaspifunction{segment_use} makes the segment referenced by
the
segment_id identifier visible and accessible to all of the
GASPI processes forming the group group.  The
identifier segment_id must be unique in the local
GASPI process. Attempting to use an existing segment ID (regardless
of bind or allocated) results in undefined behavior. Note that the
total number of segments is restricted by the underlying hardware
capabilities. The maximum number of supported segments can be
retrieved by invoking \gaspifunction{segment_max}.
To use successfully the user provided memory must satisfy
implementation specific constraints, e.\,g.\ alignment constraints.
After successful procedure completion, i.\,e.\ return value
\GASPISUCC{}, the segment can be accessed globally and has the same
capabilities like a segment that was created by a successful call to
\gaspifunction{segment_create}.
In case of return value \GASPITIME{} the operation could not be
completed in the given timeout. The segment cannot be used locally
neither remotely. A subsequent call of \gaspifunction{segment_use}
has to be invoked in order to complete the request.
If the procedure returns with \GASPIGERR{}, the procedure has failed
and the segment can not be used.
\begin{implementoradvice}
\gaspifunction{segment_use} can be formulated in pseudo code as
\begin{verbatim}
GASPI_SEGMENT_USE (id, pointer, size, group, timeout, memory)
{
  GASPI_SEGMENT_BIND (id, pointer, size, memory);
  foreach (rank : group)
  {
    timeout -= GASPI_CONNECT (rank, timeout);
    timeout -= GASPI_SEGMENT_REGISTER (id, rank, timeout);
  }
  GASPI_BARRIER (group, timeout);
}
\end{verbatim}
where the call gets executed on all members of group.
\end{implementoradvice}
\subsection{Segment deletion}
\subsubsection{\gaspifunction{segment_delete}}
The synchronous local
blocking procedure \gaspifunction{segment_delete}
releases the resources of a previously allocated memory segment.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_SEGMENT_DELETE ( segment_id )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{segment_id}{ The segment ID to be deleted. }
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_segment_delete ( gaspi_segment_id_t segment_id )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_segment_delete(segment_id) &
&         result( res ) bind(C, name="gaspi_segment_delete")
  integer(gaspi_segment_id_t), value :: segment_id
  integer(gaspi_return_t) :: res
end function gaspi_segment_delete
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}
\gaspifunction{segment_delete} releases the resources of the segment
which is referenced by the segment_id identifier.
After successful procedure completion, i.\,e.\ return value \GASPISUCC{},
the segment is deleted and the resources are released. It would be an
application error to use the segment for communication
between two GASPI processes after \gaspifunction{delete} has been called.
In case of return value \GASPIGERR{}, the segment deletion failed. The
segment is in an undefined state and cannot be used locally neither
remotely. The segment cannot be used for one-sided or passive
communication requests which are invoked by the other remote processes
forming the group. The same applies to global atomic operations.
\subsection{Segment utilities}
\subsubsection{\gaspifunction{segment_num}}
The \gaspifunction{segment_num} procedure
is a synchronous local
blocking procedure which returns
the current number of allocated segments.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_SEGMENT_NUM ( segment_num )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{segment_num}{the current number of allocated segments}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_segment_num ( gaspi_number_t *segment_num )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_segment_num(segment_num) &
&         result( res ) bind(C, name="gaspi_segment_num")
  integer(gaspi_number_t) :: segment_num
  integer(gaspi_return_t) :: res
end function gaspi_segment_num
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}
After successful procedure completion, i.\,e.\ return value \GASPISUCC{},
segment_num contains the current number of locally allocated segments provided
by GASPI. The value of segment_num is related to the parameter
segment_max in the configuration structure which is
retrieved by \gaspifunction{config_get} and cannot exceed that
value. The maximum number of allocatable segments per process might be
implementation specific.
In case of error, the return value is \GASPIGERR{}. The parameter
segment_num has an undefined value.
\subsubsection{\gaspifunction{segment_list}}
The \gaspifunction{segment_list} procedure
is a synchronous local
blocking procedure which returns
a list of locally allocated segment IDs.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_SEGMENT_LIST ( num
                   , segment_id_list[num] )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{num}{number of segment IDs to collect}
\parameterlistitem{out}{segment_list[num]}{list of locally allocated segment IDs}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_segment_list ( gaspi_number_t num
                   , gaspi_segment_id_t *segment_id_list )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_segment_list(num,segment_id_list) &
&         result( res ) bind(C, name="gaspi_segment_list")
  integer(gaspi_number_t), value :: num
  type(c_ptr), value :: segment_id_list
  integer(gaspi_return_t) :: res
end function gaspi_segment_list
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}
After successful procedure completion, i.\,e.\ return value \GASPISUCC{},
segment_id_list[num] contains the IDs of num locally allocated segments. 
The size of segment_id_list[num] needs to be at least num elements
long.
In case of error, the return value is \GASPIGERR{}. The parameter
segment_list[num] has an undefined value.
\subsubsection{\gaspifunction{segment_ptr}}
Segments are identified by a unique ID. This ID can be used to obtain
the virtual address of that local segment of memory. The procedure
\gaspifunction{segment_ptr} returns the pointer to the segment
represented by a given segment ID. It is a synchronous
local blocking procedure.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_SEGMENT_PTR ( segment_id
                  , pointer )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{segment_id}{The segment ID.}
\parameterlistitem{out}{pointer}{The pointer to the memory segment.}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_segment_ptr ( gaspi_segment_id_t segment_id
                  , gaspi_pointer_t *pointer )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_segment_ptr(segment_id,ptr) &
&         result( res ) bind(C, name="gaspi_segment_ptr")
  integer(gaspi_segment_id_t), value :: segment_id
  type(c_ptr) :: ptr
  integer(gaspi_return_t) :: res
end function gaspi_segment_ptr
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}
After successful procedure completion, i.\,e.\ \GASPISUCC{}, the output parameter
pointer contains the virtual address pointer of the memory
identified by segment_id. This pointer can
then be used to reference the segment and perform memory operations.
In case of return value \GASPIGERR{}, the translation of the segment ID
to a pointer to a virtual memory address failed. The pointer contains
an undefined value and cannot be used to reference the segment.
\subsection{Segment memory management}
Each thread of a process may have global read or write access to all of
the segments provided by remote GASPI processes if there
is a connection established between the processes and if the
respective segments have been registered on the local process.
Since a segment is an entire contiguous block of virtual memory,
allocations inside of the pre-allocated segment memory need to be
managed.
GASPI does not provide dedicated memory management functionality
for the local segments. This is left to the application.
Since a default implementation for memory management cannot include knowledge about the specific problem, a 
good problem-related implementation of a memory management will always better
than any predefined implementation.
Local and non-local GASPI procedures
specify in general memory addresses within the Partitioned Global Address Space by
the triple consisting of a rank, a segment identifier and
an offset.  This prevents a global all-to-all distribution of memory
addresses, since memory addresses of memory segments could be and
normally are different on different GASPI processes.
A local buffer is specified by the pair segment_id, offset.
The buffer  is located at address
\begin{equation}
\mbox{buffer_address} = \mbox{base_addr}\left(\, \mbox{segment_id} \,) + \mbox{offset} \nonumber
\end{equation}
where \mbox{base_addr}(\, \mbox{segment_id} \,) is the base address of the segment with identifier
segment_id.
It can be obtained by applying \gaspifunction{segment_ptr} on the local process.
A remote buffer is specified by the triple remote_rank, remote_segment_id,
remote_offset.
The address of the remote  buffer can be calculated analogously to the local buffer. The only
difference is the determination of the base address. Here, it is the address
which would be obtained by invoking \gaspifunction{segment_ptr}
on the remote GASPI process with remote_segment_id as input parameter.
\section{One-sided communication}
\subsection{Introduction and overview}
One-sided asynchronous communication is the basic communication
mechanism provided by GASPI. Hereby, one GASPI process specifies
all communication parameters, both for the local and the remote
side. Due to the asynchronicity, a complete communication
involves two procedure calls. First, one call to initiate the
communication. This call posts a communication request to the
underlying network infrastructure. The second call waits for the
completion of the communication request.
For one-sided communication, GASPI provides the concept of communication
queues.  All operations placed on a certain queue q by one or
several threads are finished after a single wait call on the queue q has
returned successfully. Separation of concerns is possible by using different queues
for different tasks, e.\,g.\ one queue for operations on data and
another queue for operations on meta-data.
The different communication queues guarantee fair communication, i.\,e.\ no queue
should see its communication requests delayed indefinitely. 
One-sided communication calls can basically be divided into two
operation types: read and write.
The read operations transfer data from a remote segment
to a local segment. The write operations transfer data from a local segment
to a remote segment.
The number of communication queues and their size can be configured at initialization
time, otherwise default values will be used. The default values are implementation
dependent. Maximum values are also defined.
For the write operation there are four different variants that allow different
communication patterns:
\begin{itemize}
\item \gaspifunction{write}
\item \gaspifunction{write_notify}
\item \gaspifunction{write_list}
\item \gaspifunction{write_list_notify}
\end{itemize}
The read operations have two different variants that allow different
communication patterns:
\begin{itemize}
\item \gaspifunction{read}
\item \gaspifunction{read_list}
\end{itemize}
The read operations do not support notification calls. This is due to
the fact that a notification can only be transferred after ensuring
that the communication request has been processed. This would imply
that a subsequent wait call has to be invoked directly after invoking
read. However, this can be managed more effectively by the
application.
A valid one-sided communication request requires that the local and
the remote segment are allocated, that there is a connection between
the local and the remote GASPI process and that the remote segment
has been registered on the local GASPI process.
\subsection{Basic communication calls}
\subsubsection{\gaspifunction{write}}
The simplest form of a write operation is \gaspifunction{write} which
is a single communication call to write data to a remote location.
It is an asynchronous non-local
time-based blocking procedure.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_WRITE ( segment_id_local
            , offset_local
            , rank
            , segment_id_remote
            , offset_remote
            , size
            , queue
            , timeout )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{segment_id_local}{the local segment ID to read from}
\parameterlistitem{in}{offset_local}{the local offset in bytes to read from}
\parameterlistitem{in}{rank}{the remote rank to write to}
\parameterlistitem{in}{segment_id_remote}{the remote segment to write to}
\parameterlistitem{in}{offset_remote}{the remote offset to write to}
\parameterlistitem{in}{size}{the size of the data to write}
\parameterlistitem{in}{queue}{the queue to use}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_write ( gaspi_segment_id_t segment_id_local
            , gaspi_offset_t offset_local
            , gaspi_rank_t rank
            , gaspi_segment_id_t segment_id_remote
            , gaspi_offset_t offset_remote
            , gaspi_size_t size
            , gaspi_queue_id_t queue
            , gaspi_timeout_t timeout )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_write(segment_id_local,offset_local,&
&         rank, segment_id_remote,offset_remote,size,&
&         queue,timeout_ms) &
&         result( res ) bind(C, name="gaspi_write")
  integer(gaspi_segment_id_t), value :: segment_id_local
  integer(gaspi_offset_t), value :: offset_local
  integer(gaspi_rank_t), value :: rank
  integer(gaspi_segment_id_t), value :: segment_id_remote
  integer(gaspi_offset_t), value :: offset_remote
  integer(gaspi_size_t), value :: size
  integer(gaspi_queue_id_t), value :: queue
  integer(gaspi_timeout_t), value :: timeout_ms
  integer(gaspi_return_t) :: res
end function gaspi_write
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDesc
\end{FDef}
\gaspifunction{write} posts a communication request which asynchronously transfers a contiguous block
of size bytes from a source location of the local GASPI process to a target location of a
remote GASPI process. This communication request is posted to the communication queue queue.
The source location is specified by the pair segment_id_local, offset_local. The
target location is specified by the triple rank, segment_id_remote,
offset_remote.
A valid \gaspifunction{write} communication request requires that the local and the
remote segment are allocated, that there is a connection between the local
and the remote GASPI process and that the remote segment has been registered
on the local GASPI process. Otherwise, the communication request is invalid
and the procedure returns with \GASPIGERR{}.
After successful procedure completion, i.\,e.\ return value \GASPISUCC{}, the communication request has
been posted to the underlying network infrastructure. One new entry is
inserted into the given queue.
Successive \gaspifunction{write} calls posted to the same queue and
the same destination rank are not guaranteed to be non-overtaking.
However, a subsequent \gaspifunction{notify}, which is posted to the same queue is 
guaranteed to be non-overtaking.   In particular, one can hence assume, that if 
the corresponding notification has arrived on the remote process, the data from the
earlier posted request to the same process has also arrived on the remote
side.
\gaspifunction{write} calls may be posted from every thread of the GASPI process.
If the procedure returns with \GASPITIME{}, the communication request could not be posted
to the hardware during the given timeout. This can happen, if another thread is in a \gaspifunction{wait}
for the same queue. A subsequent call of \gaspifunction{write} has to be
invoked in order to complete the write call.
A communication request posted to a given queue can be considered as completed, if
the correspondent \gaspifunction{wait} returns with \GASPISUCC{}.
If the queue to which the communication request is posted is full, i.\,e.\ if the number of
posted communication requests has already reached the queue size of a given queue, the communication
request fails and the procedure returns with return value \GASPIGERR{}.
If a saturated queue is detected, there are the following two options:
Either one invokes a \gaspifunction{wait} on the given queue in order to wait for all the
posted requests to be finished. Alternatively it is possible to use another queue.
\begin{useradvice}
  Return value \GASPISUCC{} does not mean, that the data has been transferred
  or buffered or that the data has arrived at the remote side.
  It is allowed to write data to the source location while the
  communication is ongoing. However, the result on the remote side
  would be some undefined interleaving of the data that was present
  when the call was issued and the data that was written later.
  It is also allowed to read from the source location while the
  communcation is ongoing and such a read would retrieve the data
  written by the application.
  Use \gaspifunction{notify} to synchronise the communication.
\end{useradvice}
\subsubsection{\gaspifunction{read}}
The simplest form of a read operation is \gaspifunction{read} which
is a single communication call to read data from a remote location.
It is an asynchronous non-local
time-based blocking procedure.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_READ ( segment_id_local
           , offset_local
           , rank
           , segment_id_remote
           , offset_remote
           , size
           , queue
           , timeout )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{segment_id_local}{the local segment ID to write to}
\parameterlistitem{in}{offset_local}{the local offset in bytes to write to}
\parameterlistitem{in}{rank}{the remote rank to read from}
\parameterlistitem{in}{segment_id_remote}{the remote segment to read from}
\parameterlistitem{in}{offset_remote}{the remote offset to read from}
\parameterlistitem{in}{size}{the size of the data to read}
\parameterlistitem{in}{queue}{the queue to use}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_read ( gaspi_segment_id_t segment_id_local
           , gaspi_offset_t offset_local
           , gaspi_rank_t rank
           , gaspi_segment_id_t segment_id_remote
           , gaspi_offset_t offset_remote
           , gaspi_size_t size
           , gaspi_queue_id_t queue
           , gaspi_timeout_t timeout )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_read(segment_id_local,offset_local,&
&         rank,segment_id_remote,offset_remote,size,&
&         queue,timeout_ms) &
&         result( res ) bind(C, name="gaspi_read")
  integer(gaspi_segment_id_t), value :: segment_id_local
  integer(gaspi_offset_t), value :: offset_local
  integer(gaspi_rank_t), value :: rank
  integer(gaspi_segment_id_t), value :: segment_id_remote
  integer(gaspi_offset_t), value :: offset_remote
  integer(gaspi_size_t), value :: size
  integer(gaspi_queue_id_t), value :: queue
  integer(gaspi_timeout_t), value :: timeout_ms
  integer(gaspi_return_t) :: res
end function gaspi_read
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDesc
\end{FDef}
\gaspifunction{read} posts a communication request which asynchronously transfers a contiguous block
of size bytes from a source location of a remote GASPI process to a target location of the
local GASPI process. This communication request is posted to the communication queue queue.
The target location is specified by the pair segment_id_local, offset_local. The
source location is specified by the triple rank, segment_id_remote,
offset_remote.
A valid \gaspifunction{read} communication request requires that the local and the
remote segment are allocated, that there is a connection between the local
and the remote GASPI process and that the remote segment has been registered
on the local GASPI process. Otherwise, the communication request is invalid
and the procedure returns with \GASPIGERR{}.
After successful procedure completion, i.\,e.\ return value \GASPISUCC{}, the communication request has
been posted to the underlying network infrastructure. One new entry is
inserted into the given queue.
\gaspifunction{read} calls may be posted from every thread of the GASPI process.
If the procedure returns with \GASPITIME{}, the communication request could not be posted
to the hardware during the given timeout. This can happen, if another thread is in a \gaspifunction{wait}
for the same queue. A subsequent call of \gaspifunction{read} has to be
invoked in order to complete the read call.
A communication request posted to a given queue can be considered as completed, if the
the correspondent \gaspifunction{wait} returns with \GASPISUCC{}. For completed  \gaspifunction{read}
requests, the data is guaranteed to be locally available.
If the queue to which the communication request is posted is full, i.\,e.\ that the number of
posted communication requests has already reached the queue size of a given queue, the communication
request fails and the procedure returns with return value \GASPIGERR{}. If a saturated queue
is detected, there are the following two options:
Either one invokes a \gaspifunction{wait} on the given queue in order to wait for all the
posted requests to be finished. Or one tries to use another queue.
\begin{useradvice}
  Return value \GASPISUCC{} does not mean, that the data transfer has
  started or that the data has been received at the local
  side.
  It is allowed to write data to the local target location while the
  communication is ongoing. However, the content of the memory would
  be some undefined interleaving of the data transferred from remote
  side and the data written locally.
  Also, it is allowed to read from the local target location while the
  communication is ongoing. Such a read would retrieve some undefined
  interleaving of the data that was present when the call was issued
  and the data that was transferred from the remote side.
\end{useradvice}
\subsubsection{\gaspifunction{wait}}
The \gaspifunction{wait} procedure is a time-based blocking local
procedure which waits until all one-sided communication requests posted
to a given queue are processed by the network infrastructure.
It is an asynchronous non-local
time-based blocking procedure.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_WAIT ( queue
           , timeout )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{queue}{the queue ID to wait for}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_wait ( gaspi_queue_id_t queue
           , gaspi_timeout_t timeout )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_wait(queue,timeout_ms) &
&         result( res ) bind(C, name="gaspi_wait")
  integer(gaspi_queue_id_t), value :: queue
  integer(gaspi_timeout_t), value :: timeout_ms
  integer(gaspi_return_t) :: res
end function gaspi_wait
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDesc
\end{FDef}
After successful procedure completion, i.\,e.\ return value
\GASPISUCC{}, the hitherto posted communication requests have been
processed by the network infrastructure and the queue is cleaned up.
After that, any communication request which has been posted to the
given queue can be considered as completed on the local
side. 
\gaspifunction{wait} procedure calls may be posted from every thread
of the local GASPI process.  However, the wait operation is a
thread exclusive operation and therefore needs privileged access to
the queue which means that if a write/read is done while a wait is in
operation, the write/read operation blocks to ensure
correctness.
Enforcing this provides correctness and safety to the user while being
easier for the implementor and still
allows for a high performance implementation. As a consequence, successive \gaspifunction{wait} calls invoked for the same queue
by different threads are processed in some sequence one after another.
If the procedure returns with \GASPITIME{}, the wait request could not be completed
during the given timeout. This can happen, if there is another thread in a \gaspifunction{wait}
for the same queue. A subsequent call of \gaspifunction{wait} has to be
invoked in order to complete the call.
If the procedure returns with \GASPIGERR{}, the wait request aborted abnormally.
In both cases, \GASPITIME{} and \GASPIGERR{}, the GASPI state
vector should be checked in order to eliminate the possibility of a
failure.  If a failure is detected, all of the communication requests
which have been posted to the given queue since the last
\gaspifunction{wait} are in an undefined state. Here, undefined state
means that the local GASPI process does not know which requests
have been processed and which requests are still outstanding. A call
to \gaspifunction{queue_purge} has to be invoked in order to reset
the queue.
\begin{useradvice}
  Return value \GASPISUCC{} means, that the data of all posted write
  requests in this queue is in transfer to the remote side. It does not mean,
  that the data has arrived at the remote side. However, write
  accesses to the local source location will not affect the data that is
  placed in the remote target location.
\end{useradvice}
\begin{useradvice}
  Return value \GASPISUCC{} means, that the data of all posted read
  requests have arrived at the local side.
\end{useradvice}
\subsubsection{Examples}
Listing \ref{lst:alltoall_write} shows a matrix transpose of a
distributed square matrix implemented with the function \gaspifunction{write}.
\insertlisting{../examples/all_to_all/alltoall_write.c}{GASPI all-to-all communication (matrix transpose) implemented with \gaspifunction{write}}
Listing \ref{lst:alltoall_read} shows a matrix transpose of a
distributed square matrix implemented with the function
\gaspifunction{read}. Please note the differences between the
transpose implemented with write and the transpose implemented with
read: The implementation using write can initialize the matrix
on-the-fly, right before the data is transferred, while the
implementation using read has to synchronise all processes after the
local initialization in order to be sure to read valid data. On the
other hand, in the implementation using write one has to synchronise
after the local wait whereas in the implementation using read one can
directly use the data after the local wait returns.
\insertlisting{../examples/all_to_all/alltoall_read.c}{GASPI all-to-all communication (matrix transpose) implemented with \gaspifunction{read}}
The definition of the macro \verb|ASSERT| is given in the listings
\ref{lst:success_or_die_h} and \ref{lst:success_or_die_c}.
The definition of the function
\verb|wait_if_queue_full| is given in the listings
\ref{lst:wait_if_queue_full_h} and \ref{lst:wait_if_queue_full_c}
starting on page \pageref{lst:wait_if_queue_full_h}.
\subsection{Weak synchronisation primitives}
\subsubsection{Introduction}
The one-sided communication procedures have the characteristics that the
entire communication is managed by the local process only. The
remote process is not involved. This has the advantage that there
is no inherent synchronisation between the local and the remote
process in every communication request. However, at some point,
the remote process needs the information as to whether the data
which has been sent to that process has arrived and is valid.
To this end GASPI provides so-called weak synchronisation primitives
which allows the application to inform the remote side that the data
has been transferred by updating a notification on the remote
side. These notifications must be submitted to the same queue to which
the data payload has been attached. Otherwise, causality is not
guaranteed.
As counterpart, there are
routines which wait for an update of a single or even an entire set of
notifications. There is a thread safe atomic function
to reset the local notification with a given ID which returns the value
of the notification before it is reset.
These notification procedures are also one-sided and
involve only the local process.
\subsubsection{\gaspifunction{notify}}
\gaspifunction{notify} is an asynchronous non-local
time-based blocking procedure.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_NOTIFY ( segment_id
             , rank
             , notification_id
             , notification_value
             , queue
             , timeout )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{segment_id}{the remote segment bound to the notification}
\parameterlistitem{in}{rank}{the remote rank to notify}
\parameterlistitem{in}{notification_id}{the remote notification ID}
\parameterlistitem{in}{notification_value}{the notification value (>0) to write}
\parameterlistitem{in}{queue}{the queue to use}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_notify ( gaspi_segment_id_t segment_id
             , gaspi_rank_t rank
             , gaspi_notification_id_t notification_id
             , gaspi_notification_t notification_value
             , gaspi_queue_id_t queue
             , gaspi_timeout_t timeout )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_notify(segment_id_remote,rank,notification_id, &
&         notification_value,queue,timeout_ms) &
&         result( res ) bind(C, name="gaspi_notify")
  integer(gaspi_segment_id_t), value :: segment_id_remote
  integer(gaspi_rank_t), value :: rank
  integer(gaspi_notification_id_t), value :: notification_id
  integer(gaspi_notification_t), value :: notification_value
  integer(gaspi_queue_id_t), value :: queue
  integer(gaspi_timeout_t), value :: timeout_ms
  integer(gaspi_return_t) :: res
end function gaspi_notify
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDesc
\end{FDef}
\gaspifunction{notify} posts a notification request which asynchronously transfers the notification
notification_value of the local GASPI process to an internal notification buffer of a
remote GASPI process. This notification request is posted to the communication queue queue.
The remote notification buffer is specified by the pair rank, notification_id.
A valid \gaspifunction{notify} communication request requires that there is a
connection between the local and the remote GASPI process. Otherwise, the
communication request is invalid
and the procedure returns with \GASPIGERR{}.
After successful procedure completion, i.\,e.\ return value
\GASPISUCC{}, the notification request has been posted to the
underlying network infrastructure.  
A \gaspifunction{notify} call which is posted subsequent to an arbitrary number of \gaspifunction{write} 
requests and which is posted to the same queue and the same destination rank is guaranteed to be
non-overtaking. Non-overtaking means that the order of communication
requests is preserved on the remote side. In particular, one can
assume, that if the data from the \gaspifunction{notify} request has arrived on the
remote process, also the data from the earlier posted write request(s) to the
same process have arrived on the remote side.
\gaspifunction{notify} calls may be posted from every thread of the GASPI process.
If the procedure returns with \GASPITIME{}, the notification request could not be posted
to the hardware during the given timeout. This can happen if another thread is in a \gaspifunction{wait}
for the same queue. A subsequent call of \gaspifunction{notify} has to be
invoked in order to complete the call.
A notification request posted to a given queue can be considered as completed, if the
the correspondent \gaspifunction{wait} returns with \GASPISUCC{}.
If the queue to which the communication request is posted is full, i.\,e.\ that the number of
posted communication requests has already reached the queue size of a given queue, the communication
request fails.
\begin{useradvice}
  Return value \GASPISUCC{} does not mean, that the notification has
  been transferred or that the notification has arrived at the remote
  side.
\end{useradvice}
\subsubsection{\gaspifunction{notify_waitsome}}
For the procedures with notification, \gaspifunction{notify} and the
extendend functions \gaspifunction{write_notify} and
\gaspifunction{read_notify}, 
\gaspifunction{notify_waitsome} is the correspondent wait procedure
for the notified receiver side (which is remote for the functions
\gaspifunction{notify} and \gaspifunction{write_notify} and local for
the function \gaspifunction{read_notify}).
\gaspifunction{notify_waitsome} is a synchronous,
non-local time-based blocking
procedure.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_NOTIFY_WAITSOME ( segment_id
                      , notification_begin
                      , notification_num
                      , first_id
                      , timeout )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{segment_id}{the segment bound to the notification}
\parameterlistitem{in}{notification_begin}{the local notification ID for the first notification to wait for}
\parameterlistitem{in}{notification_num}{the number of notification ID's to wait for}
\parameterlistitem{out}{first_id}{the id of the first notification that arrived}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_notify_waitsome ( gaspi_segment_id_t segment_id
                      , gaspi_notification_id_t notific_begin
                      , gaspi_number_t notification_num
                      , gaspi_notification_id_t *first_id
                      , gaspi_timeout_t timeout )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_notify_waitsome(segment_id_local,&
&         notification_begin,num,first_id,timeout_ms) &
&         result( res ) bind(C, name="gaspi_notify_waitsome")
  integer(gaspi_segment_id_t), value :: segment_id_local
  integer(gaspi_notification_id_t), value :: notification_begin
  integer(gaspi_number_t), value :: num
  integer(gaspi_notification_id_t) :: first_id
  integer(gaspi_timeout_t), value :: timeout_ms
  integer(gaspi_return_t) :: res
end function gaspi_notify_waitsome
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDesc
\end{FDef}
\gaspifunction{notify_waitsome} waits that at least one of a number
of consecutive notifications residing in the local
internal buffer has a value that is not zero.
The notification buffer is specified by the
pair notification_begin, notification_num.
It contains \mbox{\it notification_num} many consecutive
notifications beginning at the notification with ID \mbox{\it notification_begin}.
If \mbox{\it notification_num}==0 then \gaspifunction{notify_waitsome} returns immediately with \GASPISUCC{}.
After successful procedure completion, i.\,e.\ return value
\GASPISUCC{}, the value of at least one of the notifications in the notification
buffer has changed to a value that is not zero. All threads that are
waiting for the notifications are notified.
If the procedure returns with \GASPITIME{}, no notification has changed during
the given period of time.
In case of an error, i.\,e.\ \GASPIGERR{}, the values of the notifications are
undefined.
\begin{useradvice}
  One scenario for the usage of \gaspifunction{notify_waitsome}
  inspecting only one notification is the following: The remote side
  uses a \gaspifunction{write} call followed by a subsequent call of
  \gaspifunction{notify} posted to the same queue and the same
  destination rank. GASPI guarantees, that if the notification has arrived
  on the remote process, the previously posted request carrying
  the work load has arrived as well.
\end{useradvice}
\begin{useradvice}
One scenario for the usage of \gaspifunction{notify_waitsome}
inspecting only one notification is the following: The 
local side posts a \gaspifunction{read_notify} call. GASPI guarantees, that
if the notification has arrived on the local process, the posted read
request carrying the work load of the function \gaspifunction{read_notify}
has arrived as well.
\end{useradvice}
\begin{useradvice}
  If in a multi-threaded application more than one thread calls
  \gaspifunction{notify_waitsome} for the range of notifications, then all waiting
  threads are notified about the change of at least one of the notifications. By
  inspecting the actual values of each of the notifications with
  \gaspifunction{notify_reset}, only one thread per changed notification receives a value
  different from zero.
\end{useradvice}
\begin{useradvice}
  In a multi-threaded application the code in listing
  \ref{lst:waitsome_select.c} selects one thread to act on the change
  of a single notification. The code waits in a blocking manner and thus
  cannot be used in failure tolerant applications.
\end{useradvice}
\insertlisting{waitsome_select.c}{Blocking waitsome in a multi-threaded application}
\subsubsection{\gaspifunction{notify_reset}}
For the \gaspifunction{notify_waitsome} procedure, there is a notification
initialization procedure which resets the given notification to zero. It is a
synchronous local
blocking procedure.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_NOTIFY_RESET ( segment_id
                   , notification_id
                   , old_notification_val )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{segment_id}{the segment bound to the notification}
\parameterlistitem{in}{notification_id}{the local notification ID to reset}
\parameterlistitem{out}{old_notification_val}{notification value before reset}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_notify_reset ( gaspi_segment_id_t segment_id
                   , gaspi_notification_id_t notification_id
                   , gaspi_notification_t *old_notification_val)
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_notify_reset(segment_id_local, &
&         notification_id,old_notification_val) &
&         result( res ) bind(C, name="gaspi_notify_reset")
  integer(gaspi_segment_id_t), value :: segment_id_local
  integer(gaspi_notification_id_t), value :: notification_id
  integer(gaspi_notification_t) :: old_notification_val
  integer(gaspi_return_t) :: res
end function gaspi_notify_reset
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}
\gaspifunction{notify_reset} resets the notification with ID notification_id to
zero. The function \gaspifunction{notify_reset} is an atomic
operation: Threads can use \gaspifunction{notify_reset} to safely
extract the value of a specific notification.
The notification buffer on the local side is specified by the notification ID notification_id.
After successful procedure completion, i.\,e.\ return value
\GASPISUCC{}, the value of the notification buffer was set to zero and
old_notification_val contains the content of the notification buffer
before it was set to zero. To read the old value and to set the value
to zero is a single atomic operation.
\gaspifunction{notify_reset} calls may be posted from every thread of
the GASPI process.
In case of error, i.\,e.\ return value \GASPIGERR, the value of
old_notification_val is undefined.
\subsection{Extended communication calls}
All restrictions applying to \gaspifunction{write} and
\gaspifunction{notify} also apply here. In case of timeout or error,
no assumptions may be made regarding either the written data or the
notification.
\subsubsection{\gaspifunction{write_notify}}
The \gaspifunction{write_notify} variant extends the simple
\gaspifunction{write} with a notification on the remote
side. This applies to communication patterns that require tighter
synchronisation on data movement. The remote receiver of the data is
notified when the write is finished and can verify this through the
respective wait procedure. It is an asynchronous
non-local time-based blocking
procedure.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_WRITE_NOTIFY ( segment_id_local
                   , offset_local
                   , rank
                   , segment_id_remote
                   , offset_remote
                   , size
                   , notification_id
                   , notification_value
                   , queue
                   , timeout )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{segment_id_local}{the local segment ID to read from}
\parameterlistitem{in}{offset_local}{the local offset in bytes to read from}
\parameterlistitem{in}{rank}{the remote rank to write to}
\parameterlistitem{in}{segment_id_remote}{the remote segment to write to}
\parameterlistitem{in}{offset_remote}{the remote offset to write to}
\parameterlistitem{in}{size}{the size of the data to write}
\parameterlistitem{in}{notification_id}{the remote notification ID}
\parameterlistitem{in}{notification_value}{the value of the notification to write}
\parameterlistitem{in}{queue}{the queue to use}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_write_notify ( gaspi_segment_id_t segment_id_local
                   , gaspi_offset_t offset_local
                   , gaspi_rank_t rank
                   , gaspi_segment_id_t segment_id_remote
                   , gaspi_offset_t offset_remote
                   , gaspi_size_t size
                   , gaspi_notification_id_t notification_id
                   , gaspi_notification_t notification_value
                   , gaspi_queue_id_t queue
                   , gaspi_timeout_t timeout )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_write_notify(segment_id_local,offset_local,&
&         rank,segment_id_remote,offset_remote,size,&
&         notification_id,notification_value,queue,&
&         timeout_ms) &
&         result( res ) bind(C, name="gaspi_write_notify")
  integer(gaspi_segment_id_t), value :: segment_id_local
  integer(gaspi_offset_t), value :: offset_local
  integer(gaspi_rank_t), value :: rank
  integer(gaspi_segment_id_t), value :: segment_id_remote
  integer(gaspi_offset_t), value :: offset_remote
  integer(gaspi_size_t), value :: size
  integer(gaspi_notification_id_t), value :: notification_id
  integer(gaspi_notification_t), value :: notification_value
  integer(gaspi_queue_id_t), value :: queue
  integer(gaspi_timeout_t), value :: timeout_ms
  integer(gaspi_return_t) :: res
end function gaspi_write_notify
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDesc
\end{FDef}
\begin{implementoradvice}
The procedure is not semantically equivalent to a call to \gaspifunction{write}
and a subsequent call of \gaspifunction{notify}. This call does not
enforce an ordering relative to other write operations.
\end{implementoradvice}
\subsubsection{\gaspifunction{write_list}}
The \gaspifunction{write_list} variant allows strided communication
where a list of different data locations are processed at
once. Semantically, it is equivalent to a sequence of calls to
\gaspifunction{write} but it should (if possible) be more efficient.
It is an asynchronous
non-local time-based blocking
procedure.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_WRITE_LIST ( num
                 , segment_id_local[num]
                 , offset_local[num]
                 , rank
                 , segment_id_remote[num]
                 , offset_remote[num]
                 , size[num]
                 , queue
                 , timeout )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{num}{the number of elements to write}
\parameterlistitem{in}{segment_id_local[num]}{list of local segment ID's to read from}
\parameterlistitem{in}{offset_local[num]}{list of local offsets in bytes to read from}
\parameterlistitem{in}{rank}{the remote rank to write to}
\parameterlistitem{in}{segment_id_remote[num]}{list of remote segments to write to}
\parameterlistitem{in}{offset_remote[num]}{list of remote offsets to write to}
\parameterlistitem{in}{size[num]}{list of sizes of the data to write}
\parameterlistitem{in}{queue}{the queue to use}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_write_list ( gaspi_number_t num
                 , gaspi_segment_id_t const *segment_id_local
                 , gaspi_offset_t const *offset_local
                 , gaspi_rank_t rank
                 , gaspi_segment_id_t const *segment_id_remote
                 , gaspi_offset_t const *offset_remote
                 , gaspi_size_t const *size
                 , gaspi_queue_id_t queue
                 , gaspi_timeout_t timeout )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_write_list(num,segment_id_local,offset_local,&
&         rank,segment_id_remote,offset_remote,size,queue,&
&         timeout_ms) &
&         result( res ) bind(C, name="gaspi_write_list")
  integer(gaspi_number_t), value :: num
  type(c_ptr), value :: segment_id_local
  type(c_ptr), value  :: offset_local
  integer(gaspi_rank_t), value :: rank
  type(c_ptr), value :: segment_id_remote
  type(c_ptr), value :: offset_remote
  type(c_ptr), value :: size
  integer(gaspi_queue_id_t), value :: queue
  integer(gaspi_timeout_t), value :: timeout_ms
  integer(gaspi_return_t) :: res
end function gaspi_write_list
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDesc
\end{FDef}
\begin{implementoradvice}
The procedure is semantically equivalent to num subsequent calls
of \gaspifunction{write} with the given local and remote location specification, provided
that the destination rank and the used queue are invariant. However, it should be implemented
more efficiently, if supported by the network infrastructure.
\end{implementoradvice}
\subsubsection{\gaspifunction{write_list_notify}}
The \gaspifunction{write_list_notify} operation performs strided
communication as \gaspifunction{write_list} but also includes a
notification that the remote receiver can use to ensure that the
communication step is completed.
It is an asynchronous
non-local time-based blocking
procedure.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_WRITE_LIST_NOTIFY
                ( num
                , segment_id_local[num]
                , offset_local[num]
                , rank
                , segment_id_remote[num]
                , offset_remote[num]
                , size[num]
                , notification_id
                , notification_value
                , queue
                , timeout )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{num}{the number of elements to write}
\parameterlistitem{in}{segment_id_local[num]}{list of local segment ID's to read from}
\parameterlistitem{in}{offset_local[num]}{list of local offsets in bytes to read from}
\parameterlistitem{in}{rank}{the remote rank to be write to}
\parameterlistitem{in}{segment_id_remote[num]}{list of remote segments to write to}
\parameterlistitem{in}{offset_remote[num]}{list of remote offsets to write to}
\parameterlistitem{in}{size[num]}{list of sizes of the data to write}
\parameterlistitem{in}{notification_id}{the remote notification ID}
\parameterlistitem{in}{notification_value}{the value of the notification to write}
\parameterlistitem{in}{queue}{the queue to use}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_write_list_notify
                ( gaspi_number_t num
                , gaspi_segment_id_t const *segment_id_local
                , gaspi_offset_t const *offset_local
                , gaspi_rank_t rank
                , gaspi_segment_id_t const *segment_id_remote
                , gaspi_offset_t const *offset_remote
                , gaspi_size_t const *size
                , gaspi_notification_id_t notification_id
                , gaspi_notification_t notification_value
                , gaspi_queue_id_t queue
                , gaspi_timeout_t timeout )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_write_list_notify(num,segment_id_local,&
&         offset_local,rank,segment_id_remote,&
&         offset_remote,size,segment_id_notification, &
&         notification_id,notification_value,queue,timeout_ms) &
&         result( res ) bind(C, name="gaspi_write_list_notify")
  integer(gaspi_number_t), value :: num
  type(c_ptr), value :: segment_id_local
  type(c_ptr), value :: offset_local
  integer(gaspi_rank_t), value :: rank
  type(c_ptr), value :: segment_id_remote
  type(c_ptr), value :: offset_remote
  type(c_ptr), value :: size
  integer(gaspi_segment_id_t), value :: segment_id_notification
  integer(gaspi_notification_id_t), value :: notification_id
  integer(gaspi_notification_t), value :: notification_value
  integer(gaspi_queue_id_t), value :: queue
  integer(gaspi_timeout_t), value :: timeout_ms
  integer(gaspi_return_t) :: res
end function gaspi_write_list_notify
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDesc
\end{FDef}
\begin{implementoradvice}
The procedure is not semantically equivalent to a call to \gaspifunction{write_list}
and a subsequent call of \gaspifunction{notify}. This call does not
enforce an ordering relative to other write operations.
\end{implementoradvice}
\subsubsection{\gaspifunction{read_notify}}
The \gaspifunction{read_notify} variant extends the simple
\gaspifunction{read} with a notification on the local
side. This applies to communication patterns that require tighter
synchronisation on data movement. The local receiver of the data is
notified when the read is finished and can verify this through the
procedure \gaspifunction{waitsome}. It is an asynchronous
non-local time-based blocking
procedure.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}                                                                                                                                               
GASPI_READ_NOTIFY (  segment_id_local
                   , offset_local
                   , rank
                   , segment_id_remote
                   , offset_remote
                   , size
                   , notification_id
                   , queue
                   , timeout )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{segment_id_local}{the local segment to write to}
\parameterlistitem{in}{offset_local}{the local offset to write to}
\parameterlistitem{in}{rank}{the remote rank to read from}
\parameterlistitem{in}{segment_id_remote}{the remote segment ID to read from}
\parameterlistitem{in}{offset_remote}{the remote offset in bytes to read from}
\parameterlistitem{in}{size}{the size of the data to read}
\parameterlistitem{in}{notification_id}{the local notification ID}
\parameterlistitem{in}{queue}{the queue to use}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}                                                                                                                                               
gaspi_return_t
gaspi_read_notify (  gaspi_segment_id_t segment_id_local
                   , gaspi_offset_t offset_local
                   , gaspi_rank_t rank
                   , gaspi_segment_id_t segment_id_remote
                   , gaspi_offset_t offset_remote
                   , gaspi_size_t size
                   , gaspi_notification_id_t notification_id
                   , gaspi_queue_id_t queue
                   , gaspi_timeout_t timeout )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}                                                                                                                                               
function gaspi_read_notify(segment_id_local,offset_local,rank,&
&         segment_id_remote, offset_remote,&
&         size,notification_id,queue,&
&         timeout_ms) &
&         result( res ) bind(C, name="gaspi_read_notify")
  integer(gaspi_segment_id_t), value :: segment_id_local
  integer(gaspi_offset_t), value :: offset_local
  integer(gaspi_rank_t), value :: rank
  integer(gaspi_segment_id_t), value :: segment_id_remote
  integer(gaspi_offset_t), value :: offset_remote
  integer(gaspi_size_t), value :: size
  integer(gaspi_notification_id_t), value :: notification_id
  integer(gaspi_queue_id_t), value :: queue
  integer(gaspi_timeout_t), value :: timeout_ms
  integer(gaspi_return_t) :: res
end function gaspi_read_notify
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDesc
\end{FDef}
\begin{useradvice}
In contrast to the procedure \gaspifunction{write_notify}, the notification 
in the procedure \gaspifunction{read_notify} carries the (fixed) notification value of 1.
Similar to the procedure \gaspifunction{write_notify} a call to \gaspifunction{read_notify}
only guarantees ordering with respect to the data bundled in this communication and the given notification. 
Specifically there are no ordering guarantees to other read operations. For this latter functionality
a call to the \gaspifunction{wait} procedure is required.
\end{useradvice}
\begin{useradvice}
The two GASPI functions \gaspifunction{read_notify} and  \gaspifunction{notify_waitsome} establish a logical and thread safe happens-before relation between them.
\end{useradvice}
\begin{useradvice}
The notifcation driven \gaspifunction{read_notify} complements the \gaspifunction{write_notify} functionality.
While a \gaspifunction{read_notify} features a variety of use cases (e.g. in distributed memory management)
one of the more remarkable goals of the function \gaspifunction{read_notify} is to establish latency-tolerant multithreading in distributed memory systems.
To that end we first note that GASPI is able to sustain an extremely high concurrency: the number of messages GASPI can keep in flight at any point in time is 
(in first order) given by the product of the number of available queues and the queue depth (queue_num * queue_size_max).
Following ideas which go back to the first of Cray's MTA machines, we hence can leverage Little's law (bandwidth = concurrency/latency)
and use the high concurrency available in GASPI to effectively hide away latency for remote read access in distributed memory systems.
In doing so we gain, e.g., the ability to perform overhead-free graph traversal for non-partitionable (but distributed) large-scale graphs. We note that the same general principle holds true for all applications, which allow for a high concurrency: whenever we can sustain high concurrency in fetching and evaluating remote data, Little's law will allow us to tolerate the corresponding read latency. This applies to all forms of parallel graph-problems, parallel table lookups, parallel searches in a data-base and many other use cases.   
\end{useradvice}
\insertlisting{readnotifylisting}{\gaspifunction{read_notify} Example usage}
\begin{implementoradvice}
The procedure is not semantically equivalent to a call to \gaspifunction{read}
and a subsequent call of \gaspifunction{notify}, since the latter aims at remote completion
rather than local completion. Also this call does not enforce an ordering relative to other 
read operations. We note that the procedure \gaspifunction{read_notify} 
aims at massive concurrency rather than minimal read latency, hence it should be implemented accordingly. 
\end{implementoradvice}
\subsubsection{\gaspifunction{read_list}}
The \gaspifunction{read_list} variant allows strided communication
where a list of different data locations are processed at
once. Semantically, it is equivalent to a sequence of calls to
\gaspifunction{read} but it should (if possible) be more efficient.
It is an asynchronous
non-local time-based blocking
procedure.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_READ_LIST ( num
                , segment_id_local[num]
                , offset_local[num]
                , rank
                , segment_id_remote[num]
                , offset_remote[num]
                , size[num]
                , queue
                , timeout )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{num}{the number of elements to read}
\parameterlistitem{in}{segment_id_local[num]}{list of local segment ID's to write to}
\parameterlistitem{in}{offset_local[num]}{list of local offsets in bytes to write to}
\parameterlistitem{in}{rank}{the remote rank to read from}
\parameterlistitem{in}{segment_id_remote[num]}{list of remote segments to read from}
\parameterlistitem{in}{offset_remote[num]}{list of remote offsets to read from}
\parameterlistitem{in}{size[num]}{list of sizes of the data to read}
\parameterlistitem{in}{queue}{the queue to use}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_read_list ( gaspi_number_t num
                , gaspi_segment_id_t const *segment_id_local
                , gaspi_offset_t const *offset_local
                , gaspi_rank_t rank
                , gaspi_segment_id_t const *segment_id_remote
                , gaspi_offset_t const *offset_remote
                , gaspi_size_t const *size
                , gaspi_queue_id_t queue
                , gaspi_timeout_t timeout )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_read_list(num,segment_id_local,offset_local,&
&         rank,segment_id_remote,offset_remote,size,queue,&
&         timeout_ms) &
&         result( res ) bind(C, name="gaspi_read_list")
  integer(gaspi_number_t), value :: num
  type(c_ptr), value :: segment_id_local
  type(c_ptr), value :: offset_local
  integer(gaspi_rank_t), value :: rank
  type(c_ptr), value :: segment_id_remote 
  type(c_ptr), value :: offset_remote
  type(c_ptr), value :: size
  integer(gaspi_queue_id_t), value :: queue
  integer(gaspi_timeout_t), value :: timeout_ms
  integer(gaspi_return_t) :: res
end function gaspi_read_list
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDesc
\end{FDef}
\subsection{Communication utilities}
\subsubsection{\gaspifunction{queue_create}}
The \gaspifunction{queue_create} procedure is a
synchronous non-local
time-based blocking procedure which creates a new
queue for communication.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_QUEUE_CREATE ( queue
                   , timeout
                   )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{queue}{the created queue}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_queue_create ( gaspi_queue_id_t queue
                   , gaspi_timeout_t timeout
                   )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_queue_create (queue, timeout) &
&        result(res) bind (C, name="gaspi_queue_create" )
  integer(gaspi_queue_id_t) :: queue
  integer(gaspi_timeout_t), value :: timeout
  integer(gaspi_return_t) :: res
end function gaspi_queue_create
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDesc
\end{FDef}
After successful procedure completion, \ie return value \GASPISUCC{},
the communication
queue is created and available for communication requests
on it.
If the procedure returns with \GASPITIME{}, the creation request could
not be completed during the given timeout. A subsequent call to
\gaspifunction{queue_create} has to be performed in order to complete
the queue creation request.
If the procedure returns with \GASPIGERR{}, the queue creation
failed. Attempts to post requests in the queue result in undefined
behaviour.
\begin{useradvice}
  The lifetime of a created queue should be kept as long as possible,
  avoiding repeated cycles of creation/deletion of a queue.
\end{useradvice}
\begin{implementoradvice}
  The maximum number of allowed queues may be limited in order to keep
  resources requirements low.
\end{implementoradvice}
\begin{implementoradvice}
  The communication infrastructure must be respected \ie previously
  established connections (\eg invoking \gaspifunction{connect}) must
  be able to use the newly created queue.
\end{implementoradvice}
\subsubsection{\gaspifunction{queue_delete}}
The \gaspifunction{queue_delete} procedure is a
synchronous non-local
time-based blocking procedure which deletes a given
queue.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_QUEUE_DELETE ( queue )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{queue}{the queue to delete}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_queue_delete ( gaspi_queue_id_t queue )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_queue_delete ( queue ) &
&        result(res) bind (C, name="gaspi_queue_delete" )
  integer(gaspi_queue_id_t), value :: queue
  integer(gaspi_return_t) :: res
end function gaspi_queue_delete
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}
After successful procedure completion, \ie return value \GASPISUCC{},
the communication
queue is deleted and no longer available for
communication. It is an application error to use the queue after
\gaspifunction{queue_delete} has been invoked.
If the procedure returns with \GASPIGERR{}, the delete request failed.
\begin{useradvice}
  The procedure \gaspifunction{wait} should be invoked before deleting
  a queue in order to ensure that all posted requests (if any) are
  completed.
\end{useradvice}
\subsubsection{\gaspifunction{queue_size}}
The \gaspifunction{queue_size} procedure
is a synchronous
local blocking procedure which determines the number
of open communication requests posted to a given queue.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_QUEUE_SIZE ( queue
                 , queue_size )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{queue}{the queue to probe}
\parameterlistitem{out}{queue_size}{the number of open requests posted to the queue}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_queue_size ( gaspi_queue_id_t queue
                 , gaspi_number_t const *queue_size )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_queue_size(queue,queue_size) &
&         result( res ) bind(C, name="gaspi_queue_size")
  integer(gaspi_queue_id_t), value :: queue
  integer(gaspi_number_t) :: queue_size
  integer(gaspi_return_t) :: res
end function gaspi_queue_size
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}
After successful procedure completion, i.\,e.\ return value \GASPISUCC{}, the parameter
queue_size contains the number of open requests posted to the queue queue.
In a threaded program this result is uncertain, since another thread may have
posted an additional request in the meantime or issued a wait call.
The queue size is set to zero by a successful call to \gaspifunction{wait}.
In case of error, the return value is \GASPIGERR{}. The parameter queue_size
has an undefined value.
 \subsubsection{\gaspifunction{queue_purge}}
 The \gaspifunction{queue_purge} procedure is a
 synchronous local
 time-based blocking procedure which purges a given
 queue.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_QUEUE_PURGE ( queue
                  , timeout )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{queue}{the queue to purge}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_queue_purge ( gaspi_queue_id_t queue
                  , gaspi_timeout_t timeout )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_queue_purge(queue,timeout) &
&         result( res ) bind(C, name="gaspi_queue_purge")
  integer(gaspi_queue_id_t), value :: queue
  integer(gaspi_timeout_t), value :: timeout
  integer(gaspi_return_t) :: res
end function gaspi_queue_purge
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDesc
\end{FDef}
This procedure should only be invoked in the situation in which a node failure is detected
by inspecting the global health state with \gaspifunction{state_vec_get}.
After successful procedure completion, i.\,e.\ return value \GASPISUCC{}, the communication
queue is purged. All communication requests posted to the queue queue are
eliminated from the queue. The local GASPI process has no information about the
completion of communication requests posted to the given queue since the last invocation
of \gaspifunction{wait}.
If the procedure returns with \GASPITIME{}, the purge request could not be completed
during the given timeout. This might happen if there is another thread in a \gaspifunction{wait}
for the same queue. A subsequent call of \gaspifunction{queue_purge} has to be
invoked in order to complete the call.
If the procedure returns with \GASPIGERR{}, the purge request aborted abnormally.
\section{Passive communication}
\subsection{Introduction and overview}
Passive communication has a two-sided semantic, where there is a
matching receiver to a send request. Passive communication aims at
communication patterns where the sender is unknown (i.\,e.\ it can be any
process from the receiver perspective) but there is potentially the need
for synchronisation between processes. Typical example uses cases are:
\begin{itemize}
\item Distributed update where many processes contribute to the data of
  one process.
\item Pass arguments and results.
\item Global error handling.
\end{itemize}
The implementation should try to enforce fairness in communication
that is, no sender should see its communication request delayed
indefinitely.
The passive keyword means that the communication calls should avoid
busy-waiting and consume no CPU cycles, freeing the system for
computation.
Both the send and the matching receive are \gaspisemantic{time-based
  blocking}. A valid passive communication request requires that the
local and the remote segment are allocated and that there is a
connection between the local and the remote GASPI
process. Otherwise, the communication request is invalid and the
procedure returns with \GASPIGERR{}.
\subsection{Passive communication calls}
\subsubsection{\gaspifunction{passive_send}}
\gaspifunction{passive_send} is the routine called by
the sender side to engage in passive communication. It is an
synchronous non-local
time-based blocking procedure.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_PASSIVE_SEND ( segment_id_local
                   , offset_local
                   , rank
                   , size
                   , timeout )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{segment_id_local}{the local segment ID from which the data is sent}
\parameterlistitem{in}{offset_local}{the local offset from which the data is sent}
\parameterlistitem{in}{rank}{the remote rank to which the data is sent}
\parameterlistitem{in}{size}{the size of the data to be sent}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_passive_send ( gaspi_segment_id_t segment_id_local
                   , gaspi_offset_t offset_local
                   , gaspi_rank_t rank
                   , gaspi_size_t size
                   , gaspi_timeout_t timeout )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_passive_send(segment_id_local,offset_local, &
&         rank,size,timeout_ms) &
&         result( res ) bind(C, name="gaspi_passive_send")
  integer(gaspi_segment_id_t), value :: segment_id_local
  integer(gaspi_offset_t), value :: offset_local
  integer(gaspi_rank_t), value :: rank
  integer(gaspi_size_t), value :: size
  integer(gaspi_timeout_t), value :: timeout_ms
  integer(gaspi_return_t) :: res
end function gaspi_passive_send
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDesc
\end{FDef}
\gaspifunction{passive_send} posts a passive communication request
which transfers a contiguous block of size bytes from a
source location of the local GASPI process to the remote GASPI
process with the indicated rank rank.  On the remote side,
a corresponding \gaspifunction{passive_receive} has to be posted. The
source location is specified by the
pair segment_id_local, offset_local.
There is a size limit for the data sent with
\gaspifunction{passive_send}. The maximum size is returned by the
function \gaspifunction{passive_transfer_size_max}.
A valid \gaspifunction{passive_send} communication request requires
that the local and the remote segment are allocated and that there is
a connection between the local and the remote GASPI
process. Otherwise, the communication request is invalid and the
procedure returns with \GASPIGERR{}.
After successful procedure completion, i.\,e.\ return value
\GASPISUCC{}, the passive communication request has been posted to the
underlying network infrastructure and was completed.
\gaspifunction{passive_send} calls may be posted from every thread of
the GASPI process.
If the procedure returns with \GASPITIME{}, the communication request
could not be posted to the hardware during the given timeout. 
If the passive communication queue is full at the time when a new
passive communication request is posted, i.\,e.\ the number of posted
communication requests has already reached the queue size, the
communication request fails and the procedure returns with return
value \GASPIGERR{}.
\begin{useradvice}
  Since the passive receive will try to match every corresponding
  send, the buffer sizes for send/recv need to match for all ranks 
  for the passive communication within one passive send/recv 
  communication step.   
\end{useradvice}
\begin{useradvice}\emph{[see also the advice in \ref{useradvice:gaspi_write} on page \pageref{useradvice:gaspi_write}]}
  It is allowed to write data to the source location while the
  communication is ongoing. However, the result on the remote side
  would be some undefined interleaving of the data that was present
  when the call was issued and the data that was written later.
  It is also allowed to read from the source location while the
  communcation is ongoing and such a read would retrieve the data
  written by the application.
\end{useradvice}
\begin{useradvice}
  If the parameter build_infrastructure is not set, a
  connection has to be established between the processes before the
  \gaspifunction{passive_send} can be be used. This is accomplished
  calling the procedure \gaspifunction{connect}.
\end{useradvice}
\subsubsection{\gaspifunction{passive_receive}}
The synchronous non-local
time-based blocking \gaspifunction{passive_receive}
is one of the routines called by the receiver side to engage in
passive communication.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_PASSIVE_RECEIVE ( segment_id_local
                      , offset_local
                      , rank
                      , size
                      , timeout )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{segment_id_local}{the local segment ID where to write the data}
\parameterlistitem{in}{offset_local}{the local offset where to write the data}
\parameterlistitem{out}{rank}{the remote rank from which the data is transferred}
\parameterlistitem{in}{size}{the size of the data to be received}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_passive_receive ( gaspi_segment_id_t segment_id_local
                      , gaspi_offset_t offset_local
                      , gaspi_rank_t const *rank
                      , gaspi_size_t size
                      , gaspi_timeout_t timeout )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_passive_receive(segment_id_local,offset_local, &
&         rem_rank,size,timeout_ms) &
&         result( res ) bind(C, name="gaspi_passive_receive")
  integer(gaspi_segment_id_t), value :: segment_id_local
  integer(gaspi_offset_t), value :: offset_local
  integer(gaspi_rank_t) :: rem_rank
  integer(gaspi_size_t), value :: size
  integer(gaspi_timeout_t), value :: timeout_ms
  integer(gaspi_return_t) :: res
end function gaspi_passive_receive
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDesc
\end{FDef}
\gaspifunction{passive_receive} receives a contiguous block of data
into a target location from some unspecified remote GASPI
process. The target location is specified by the
pair segment_id_local,
offset_local.
There is no need for the \gaspifunction{passive_receive} procedure to
be active before a corresponding \gaspifunction{passive_send}
procedure is invoked. However, as long as there is no matching
receive, the \gaspifunction{passive_send} cannot achieve any progress
and thus cannot return \GASPISUCC{}.
The target location needs to have enough space to hold the maximum
passive transfer size that could be sent be any other
process. Otherwise, the received data might overwrite memory regions
outside of the allocated memory and the application will be in an
undefined state.
A valid \gaspifunction{passive_receive} communication request
requires that the local destination segment is allocated and that
there is a connection between the local and the remote GASPI
process from which a data transfer originates. Otherwise, the
communication request is invalid and the procedure returns with
\GASPIGERR{}.
After successful procedure completion, i.\,e.\ return value
\GASPISUCC{}, the data has been received and is available at the
target location. Further rank contains the rank of the
sending process and associated to the communication request.
Successive \gaspifunction{passive_receive} calls posted by two
different threads using two different target locations are
allowed. However, the first incoming data is received either by the
first thread or the by the second. That means that the
\gaspifunction{passive_receive} should be posted only from a single
thread of a GASPI process.
If the procedure returns with \GASPITIME{}, there was no pending
communication request in the queue. The output
parameter rank has no defined value.
\begin{useradvice}
  It is allowed to write data to the local target location while the
  passive communication is ongoing. However, the content of the memory
  would be some undefined interleaving of the data transferred from
  remote side and the data written locally.
  Also, it is allowed to read from the local target location while the
  passive communication is ongoing. Such a read would retrieve some
  undefined interleaving of the data that was present when the call
  was issued and the data that was transferred from the remote side.
\end{useradvice}
\begin{implementoradvice}
  A quality implementation enforces fairness in communication that is,
  no sender should see its communication request delayed
  indefinitely. The passive keyword means the communication calls
  shall avoid busy-waiting and consume no CPU cycles, freeing the
  system for computation.
\end{implementoradvice}
\subsection{Passive communication utilities}
\subsubsection{\gaspifunction{passive_queue_purge}}
The \gaspifunction{passive_queue_purge} procedure is a
synchronous local
time-based blocking procedure which purges the passive
queue.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_PASSIVE_QUEUE_PURGE (timeout)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_passive_queue_purge (gaspi_timeout_t timeout)
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_passive_queue_purge(timeout) &
&         result( res ) bind(C, name="gaspi_passive_queue_purge")
  integer(gaspi_timeout_t), value :: timeout
  integer(gaspi_return_t) :: res
end function gaspi_passive_queue_purge
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDesc
\end{FDef}
This procedure should only be invoked in the situation in which a node
failure is detected by inspecting the global health state with
\gaspifunction{state_vec_get}.
After successful procedure completion, i.\,e.\ return value
\GASPISUCC{}, the passive communication queue is purged. 
If the procedure returns with \GASPITIME{}, the purge request could
not be completed during the given timeout. A subsequent call of
\gaspifunction{passive_queue_purge} has to be invoked in order to
complete the call.
If the procedure returns with \GASPIGERR{}, the purge request was not
satisfied and returned abnormally.
\section{Global atomics}
\subsection{Introduction and Overview}
An atomic operation is an operation which is guaranteed to be executed
without fear of interference from other processes during the procedure
call. Only one GASPI process at a time has access to the global
variable and can modify it.
Atomic operations are also guaranteed to be fair. That means no GASPI
process should see its atomic operation request
delayed indefinitely.
\subsection{Atomic operation calls}
\subsubsection{\gaspifunction{atomic_fetch_add}}
The \gaspifunction{atomic_fetch_add} procedure is a
synchronous non-local
time-based blocking procedure which atomically adds a
given value to a globally acessible value.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_ATOMIC_FETCH_ADD ( segment_id
                       , offset
                       , rank
                       , value_add
                       , value_old
                       , timeout )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{segment_id}{the segment ID where the value is located}
\parameterlistitem{in}{offset}{the offset where the value is located}
\parameterlistitem{in}{rank}{the rank where the value is located}
\parameterlistitem{in}{value_add}{the value which is to be added}
\parameterlistitem{out}{value_old}{the old value before the operation}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_atomic_fetch_add ( gaspi_segment_id_t segment_id
                       , gaspi_offset_t offset
                       , gaspi_rank_t rank
                       , gaspi_atomic_value_t value_add
                       , gaspi_atomic_value_t *value_old
                       , gaspi_timeout_t timeout )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_atomic_fetch_add(segment_id,offset,rank, &
&         val_add,val_old,timeout_ms) &
&         result( res ) bind(C, name="gaspi_atomic_fetch_add")
  integer(gaspi_segment_id_t), value :: segment_id
  integer(gaspi_offset_t), value :: offset
  integer(gaspi_rank_t), value :: rank
  integer(gaspi_atomic_value_t), value :: val_add
  integer(gaspi_atomic_value_t) :: val_old
  integer(gaspi_timeout_t), value :: timeout_ms
  integer(gaspi_return_t) :: res
end function gaspi_atomic_fetch_add
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDesc
\end{FDef}
\gaspifunction{atomic_fetch_add} atomically adds the value
of value_add to the value on rank rank,
segment segment_id_remote and
offset offset_remote.
After successful procedure completion, i.\,e.\ return value
\GASPISUCC{}, the parameter
value_old contains the value before the operation has
been applied.
If the procedure returns with \GASPITIME{}, the fetch and add request
could not be completed during the given timeout. The
parameter value_old has an undefined value.  A subsequent
call of \gaspifunction{atomic_fetch_add} needs to be invoked in
order to complete the operation.
If the procedure returns with \GASPIGERR{}, the fetch and add request
aborted abnormally.  The parameter value_old as well as
the global value (segment_id, offset, rank) have undefined values.
In both cases, \GASPITIME{} and \GASPIGERR{}, the GASPI state vector
should be checked in order to deal with possible failures.
\begin{implementoradvice}
  The implementation might require some alignment restrictions that
  is, the
  triple(segment_id, offset, rank)
  might be required to respect some alignment restrictions.
\end{implementoradvice}
\begin{useradvice}
  Concurrent accesses to the location represented by the
  triple(segment_id, offset, rank)
  are possible but consistency must be handled by the application.
\end{useradvice}
\subsubsection{\gaspifunction{atomic_compare_swap}}
The \gaspifunction{atomic_compare_swap} procedure is a
synchronous non-local
time-based blocking procedure which atomically
compares the value of a global value against some user given value and
in case these are equal the old value is replaced by a new value.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_ATOMIC_COMPARE_SWAP ( segment_id
                          , offset
                          , rank
                          , comparator
                          , value_new
                          , value_old
                          , timeout )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{segment_id}{the segment ID where the value is located}
\parameterlistitem{in}{offset}{the offset where the value is located}
\parameterlistitem{in}{rank}{the rank where the value is located}
\parameterlistitem{in}{comparator}{the value which is compared to the remote value}
\parameterlistitem{in}{value_new}{the new value to which the remote location is set if the result of the comparison is true}
\parameterlistitem{out}{value_old}{the value before the operation}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_atomic_compare_swap ( gaspi_segment_id_t segment_id
                          , gaspi_offset_t offset
                          , gaspi_rank_t rank
                          , gaspi_atomic_value_t comparator
                          , gaspi_atomic_value_t value_new
                          , gaspi_atomic_value_t *value_old
                          , gaspi_timeout_t timeout )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_atomic_compare_swap(segment_id,offset,rank,&
&         comparator,val_new,val_old,timeout_ms) &
&         result( res ) bind(C, name="gaspi_atomic_compare_swap")
  integer(gaspi_segment_id_t), value :: segment_id
  integer(gaspi_offset_t), value :: offset
  integer(gaspi_rank_t), value :: rank
  integer(gaspi_atomic_value_t), value :: comparator
  integer(gaspi_atomic_value_t), value :: val_new
  integer(gaspi_atomic_value_t) :: val_old
  integer(gaspi_timeout_t), value :: timeout_ms
  integer(gaspi_return_t) :: res
end function gaspi_atomic_compare_swap
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDesc
\end{FDef}
\gaspifunction{atomic_compare_swap} atomically compares the global
value of the the value on rank rank,
segment segment_id_remote and
offset offset_remote to the value
of comparator. If the comparison is true, this global
value is set to value_new. If the comparison is false, it
keeps its value.
After successful procedure completion, i.\,e.\ return value
\GASPISUCC{}, the parameter
value_old contains the previous value before the
comparison was done.
If the procedure returns with \GASPITIME{}, the compare and swap
request could not be completed during the given timeout. The
parameter value_old has an undefined value.  A subsequent
call of \gaspifunction{atomic_compare_swap} needs to be invoked in
order to complete the operation.
If the procedure returns with \GASPIGERR{}, the compare and swap
request aborted abnormally. The parameter value_old as
well as well as the global value (segment_id, offset, rank) have
undefined values.
In both cases, \GASPITIME{} and \GASPIGERR{}, the GASPI state vector
should be checked in order to deal with possible failures.
\begin{implementoradvice}
  The implementation might require some alignment restrictions that
  is, the
  triple(segment_id, offset, rank)
  might be required to respect some alignment restrictions.
\end{implementoradvice}
\begin{useradvice}
  Concurrent accesses to the location represented by the
  triple(segment_id, offset, rank)
  are possible but consistency must be handled by the application.
\end{useradvice}
\subsubsection{Examples}
The example in \listref{lst:rsrclock} illustrates the usage of global
atomic operations for implementing a global resource lock. The example
is implemented with timeout.
\insertlisting{../examples/resource_lock/resource_lock.c}
        { GASPI global resource lock implemented with atomic counters  }
\section{Collective communication}
\subsection{Introduction and overview}
Collective operations are collective with respect to a given group.
A necessary condition for successful collective procedure completion is that all
GASPI processes forming the given group have invoked the operation.
Collective operations support both synchronous and asynchronous implementations as
well as time-based blocking. That means, progress towards successful procedure
completion can be achieved either inside the call (for a synchronous implementation)
or outside of the call (for an asynchronous implementation) before the procedure exits.
In the case of a timeout (which is indicated
by return value \GASPITIME{}) the operation is then continued in the
next call of the procedure. This implies that a collective operation
may involve several procedure calls until completion. Completion is
indicated by return value \GASPISUCC{}.
Collective operations are exclusive per group, i.\,e.\ only one collective
operation of a specific type on a given group can run at a given time. Starting a
specific collective operation before another one of the same kind is not
finished on all processes of the group
(and marked as such) is not allowed and yields undefined behavior.
For example, two allreduce operations for one group can not run at the same time; however,
an allreduce and a barrier operation can run at the same time.
The timeout is a necessary condition in order to be able to write
failure tolerant code. Timeout =0 makes an atomic portion of
progress in the operation if possible. If progress is possible, the
procedure returns as soon as some progress is
achieved. Otherwise, the procedure returns immediately. Here, an
atomic portion of progress is defined as the smallest set of
non-dividable instructions in the current state of the collective
operation.
Reduction operations can be defined by the application via callback
functions.
\begin{useradvice}
  Not every collective operation will be implementable in an
  asynchronous fashion -- for example if a user-defined callback
  function is used within a global reduction. Progress in this case
  can only be achieved inside of the call. Especially for large
  systems this implies that a collective potentially has to be called
  a substantial number of times in order to complete -- especially if
  used in combination with \GASPITEST{}. In this combination the
  called collective immediately returns (after completing local work)
  and never waits for data from remote processes. A corresponding
  code fragment in this case would assume the form:
\begin{listing}{1}
while ( (ret = gaspi_allreduce_user(buffer_send
                            , buffer_receive
                            , char num
                            , size_element
                            , reduce_operation
                            , reduce_state
                            , group
                            , GASPI_TEST)) == GASPI_TIMEOUT)
{
work_on_something_else();
}
if( ret != GASPI_SUCCESS)
{
     handle_error(ret);
}
\end{listing}
\end{useradvice}
\subsection{Barrier synchronisation}
\subsubsection{\gaspifunction{barrier}}
The \gaspifunction{barrier} procedure is a 
collective time-based blocking
procedure. An implementation is free to provide it as a synchronous or
an asynchronous procedure. 
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_BARRIER ( group
              , timeout )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{group}{the group of ranks which should participate in the barrier}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_barrier ( gaspi_group_t group
              , gaspi_timeout_t timeout )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_barrier(group,timeout_ms) &
&         result( res ) bind(C, name="gaspi_barrier")
  integer(gaspi_group_t), value :: group
  integer(gaspi_timeout_t), value :: timeout_ms
  integer(gaspi_return_t) :: res
end function gaspi_barrier
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDesc
\end{FDef}
\gaspifunction{barrier} blocks the caller until all group members
of group have invoked the procedure or
if timeout milliseconds have been reached since procedure
invocation. After successful procedure completion, i.\,e.\ return
value \GASPISUCC{}, all group members have invoked the procedure. In
case of \GASPITIME{} it is unknown whether or not all GASPI
processes forming the given group have invoked the call.
Progress towards successful \gaspifunction{barrier} completion may be achieved even if the procedure
exits due to timeout. The barrier is continued in the next call of the procedure. This implies that a
barrier operation may involve several \gaspifunction{barrier} calls until
completion.
Barrier operations are exclusive per group, i.\,e.\ only one barrier
operation on a given group can run at a time. Starting a
barrier operation in another thread before a previously invoked barrier is finished
on all processes of the group
is not allowed and yields undefined behavior.
In case of error, the return value is \GASPIGERR{}. The error vector should be
investigated.
\begin{useradvice}
  The barrier is supposed to synchronise processes and not threads.
\end{useradvice}
\subsubsection{Examples}
In the following example a \gaspifunction{barrier} is interrupted
after \numprint[ms]{100} in order to check for errors.
\begin{listing}{1}
gaspi_return_t err;
do
  {
    err = gaspi_barrier (g, 100);
    if (err == GASPI_TIMEOUT && error vector indicates error)
      {
        goto ERROR_HANDLING;
      }
  }
while (err != GASPI_SUCCESS);
\end{listing}
The following example shows a non-blocking barrier. Some local work
(in this case: cleanup) is performed, overlapping it with the barrier
and only then a full synchronisation is achieved by calling the
barrier again with a blocking semantics (if needed).
\begin{listing}{1}
const gaspi_return_t err = gaspi_barrier (g, GASPI_TEST);
do_local_cleanup();
if (err != GASPI_ERROR && err != GASPI_SUCCESS)
{
    gaspi_barrier (g, GASPI_BLOCK);
}
\end{listing}
\subsection{Predefined global reduction operations}
\subsubsection{\gaspifunction{allreduce}}
The \gaspifunction{allreduce} procedure is a 
collective time-based blocking
procedure.  An implementation is free to provide it as a synchronous or
an asynchronous procedure. 
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_ALLREDUCE ( buffer_send
                , buffer_receive
                , num
                , operation
                , datatype
                , group
                , timeout )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{buffer_send}{pointer to the buffer where the input is placed}
\parameterlistitem{in}{buffer_receive}{pointer to the buffer where the result is placed}
\parameterlistitem{in}{num}{the number of elements to be reduced on each process}
\parameterlistitem{in}{operation}{the GASPI reduction operation type}
\parameterlistitem{in}{datatype}{the GASPI element type}
\parameterlistitem{in}{group}{the group of ranks which participate in the reduction operation}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_allreduce ( gaspi_const_pointer_t buffer_send
                , gaspi_pointer_t buffer_receive
                , gaspi_number_t num
                , gaspi_operation_t operation
                , gaspi_datatype_t datatype
                , gaspi_group_t group
                , gaspi_timeout_t timeout )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_allreduce(buffer_send,buffer_receive,num, &
&         operation,datatyp,group,timeout_ms) &
&         result( res ) bind(C, name="gaspi_allreduce")
  type(c_ptr), value :: buffer_send
  type(c_ptr), value :: buffer_receive
  integer(gaspi_number_t), value :: num
  integer(gaspi_operation_t), value :: operation
  integer(gaspi_datatype_t), value :: datatyp
  integer(gaspi_group_t), value :: group
  integer(gaspi_timeout_t), value :: timeout_ms
  integer(gaspi_return_t) :: res
end function gaspi_allreduce
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDesc
\end{FDef}
\gaspifunction{allreduce} combines the num elements of
type datatype residing in buffer_send on each
process in accordance with the given operation.  The
reduction operation is on a per element basis, i.\,e.\ the operation
is applied to each of the elements. \gaspifunction{allreduce} blocks
the caller until all data is available that is needed to calculate the
result or if timeout milliseconds have been reached since
procedure invocation. After successful procedure completion, i.\,e.\
return value \GASPISUCC{}, all group members have invoked the
procedure and buffer_receive contains the result of the
reduction operation on every GASPI process of group.
In case of \GASPITIME{} not all data is available that is needed to
calculate the result.
Progress towards successful \gaspifunction{allreduce} completion may be achieved even if the procedure
exits due to timeout. The reduction operation is continued in the next call of the procedure. This implies that a
reduction operation may involve several \gaspifunction{allreduce} calls until
completion.
Reduction operations are exclusive per group, i.\,e.\ only one reduction
operation on a given group can run at a time. Starting a
reduction operation for the same group in a separate thread before previously invoked operation
is finished on all processes of the group
is not allowed and yields undefined behavior.
The buffer_send as well as the buffer_receive do not need
to reside in the global address space. \gaspifunction{allreduce} copies the send
buffer into an internal buffer at the first invocation. The result is copied from
an internal buffer into the receive buffer immediatley before the procedure returns
successfully.
The buffers need to have the appropriate
size to host all of the num elements. Otherwise the reduction operation yields
undefined behavior.
The maximum permissible number of elements
is implementation dependent and can be retrieved by \gaspifunction{allreduce_elem_max}.
In case of error, the return value is \GASPIGERR{}. The error vector should be
examined. buffer_receive has an undefined value.
In case of \GASPITIME{}, the reduction operation is not finished yet,
i.\,e.\ not all data is available that is needed to calculate the
result. The buffer_receive has an undefined value.
\subsubsection{Predefined reduction operations}
There are three predefined reduction operations:
\begin{listing}[99]{2}
typedef enum { GASPI_OP_MIN
             , GASPI_OP_MAX
             , GASPI_OP_SUM
             } gaspi_operation_t;
\end{listing}
\begin{description}
\item[GASPI_OP_MIN] determines the minimum of the elements of each column of the input vector.
\item[GASPI_OP_MAX] determines the maximum of the elements of each column of the input vector.
\item[GASPI_OP_SUM] sums up all elements of each column of the input vector.
\end{description}
\subsubsection{Predefined types}
And the types are:
\begin{listing}[99]{2}
typedef enum { GASPI_TYPE_INT
             , GASPI_TYPE_UINT
             , GASPI_TYPE_LONG
             , GASPI_TYPE_ULONG
             , GASPI_TYPE_FLOAT
             , GASPI_TYPE_DOUBLE
             } gaspi_datatype_t;
\end{listing}
\begin{description}
\item[GASPI_TYPE_INT] integer
\item[GASPI_TYPE_UINT] unsigned integer
\item[GASPI_TYPE_LONG] long
\item[GASPI_TYPE_ULONG] unsigned long
\item[GASPI_TYPE_FLOAT] float
\item[GASPI_TYPE_DOUBLE] double
\end{description}
\subsection{User-defined global reduction operations}
\subsubsection{\gaspifunction{allreduce_user}}
The procedure \gaspifunction{allreduce_user} allows the user to specify its
own reduction operation. Only operations are supported which are
commutative and associative. It is a collective
time-based blocking procedure.  An implementation is
free to provide it as a synchronous or an asynchronous procedure. 
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_ALLREDUCE_USER ( buffer_send
                     , buffer_receive
                     , num
                     , size_element
                     , reduce_operation
                     , reduce_state
                     , group
                     , timeout )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{buffer_send}{pointer to the buffer where the input is placed}
\parameterlistitem{in}{buffer_receive}{pointer to the buffer where the result is placed}
\parameterlistitem{in}{num}{the number of elements to be reduced on each process}
\parameterlistitem{in}{size_element}{Size in bytes of one element to be reduced}
\parameterlistitem{in}{reduce_operation}{pointer to the user defined reduction operation procedure}
\parameterlistitem{inout}{reduce_state}{reduction state vector}
\parameterlistitem{in}{group}{the group of ranks which participate in the reduction operation}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_allreduce_user ( gaspi_const_pointer_t buffer_send
                     , gaspi_pointer_t buffer_receive
                     , gaspi_number_t num
                     , gaspi_size_t size_element
                     , gaspi_reduce_operation_t reduce_operation
                     , gaspi_reduce_state_t reduce_state
                     , gaspi_group_t group
                     , gaspi_timeout_t timeout )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_allreduce_user(buffer_send,buffer_receive, &
&         num,element_size,reduce_operation,reduce_state,&
&         group,timeout_ms) &
&         result( res ) bind(C, name="gaspi_allreduce_user")
  type(c_ptr), value :: buffer_send
  type(c_ptr), value :: buffer_receive
  integer(gaspi_number_t), value :: num        
  integer(gaspi_size_t), value :: element_size
  type(c_funptr), value :: reduce_operation
  type(c_ptr), value :: reduce_state
  integer(gaspi_group_t), value :: group
  integer(gaspi_timeout_t), value :: timeout_ms
  integer(gaspi_return_t) :: res
end function gaspi_allreduce_user
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDesc
\end{FDef}
\gaspifunction{allreduce_user} has the same semantics as the predefined reduction operation
\gaspifunction{allreduce} described in the last section.
A user defined reduction operation reduce_operation and a user
defined state reduce_state are passed.
The elements on which the user defined reduction operation is applied
are described by their byte size size_element. The entire
size of the data to be reduced, i.\,e.\ num times size_element,
must not be larger than the internal buffer size of \gaspifunction{allreduce_user}.
The internal buffer size can be queried through \gaspifunction{allreduce_buf_size}.
\subsubsection{\gaspifunction{reduce_operation}}
The prototype for the user defined reduction operations is the following:
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_REDUCE_OPERATION ( operand_one
                       , operand_two
                       , result
                       , state
                       , timeout )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{operand_one}{pointer to the first operand}
\parameterlistitem{in}{operand_two}{pointer to the second operand}
\parameterlistitem{in}{result}{pointer to the result}
\parameterlistitem{in}{state}{pointer to the state}
\parameterlistitem{in}{timeout}{the timeout}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_reduce_operation ( gaspi_const_pointer_t operand_one
                       , gaspi_const_pointer_t operand_two
                       , gaspi_pointer_t result
                       , gaspi_reduce_state_t state
                       , gaspi_timeout_t timeout )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_reduce_operation(op_one,op_two,op_res, &
&   op_state,num,element_size,timeout) &
&   result ( res ) bind(C,name="my_reduce_operation")
  implicit none
  integer(gaspi_number_t), intent(in), value :: num        
  integer(c_int), intent(in)  :: op_one(num)
  integer(c_int), intent(in)  :: op_two(num)
  integer(c_int), intent(out) :: op_res(num)
  integer(c_int), intent(out) :: op_state(num)
  integer(gaspi_size_t), value :: element_size
  integer(gaspi_timeout_t), value :: timeout
  integer(gaspi_return_t) :: res
end function gaspi_reduce_operation
\end{verbatim}
\end{FDefSign}
\FStdRetDesc
\end{FDef}
The fortran user defined callback function requires an  explicit type from the iso_c_binding module. in this
example integer(c_int) (op_one,op_two,op_res,op_state).
A pointer to the first operand and a pointer to the second operand
are passed. The result is stored in the memory represented by the
pointer result. In addition
to the actual data, also a state can be passed to the operator
which might be required in order to compute the result. In order to meet
real time system specifications, a timeout can
be passed to the user defined reduction operator. The reduction operator
should return a return with the same semantics, i.\,e.\
\GASPISUCC{} for successful procedure completion. \GASPITIME{}
in case of timeout and \GASPIGERR{} in case of error.
The user defined reduction operator needs to be commutative and associative.
The reduce operator type passed to \gaspifunction{allreduce_user} is
a pointer to a function with the prototype described above.
\begin{TDef}
\TDefDefn{\gaspifunction{reduce_operation}*}{reduce_operation}
\TDefDesc{The GASPI reduction operation type}
\end{TDef}
\subsubsection{allreduce state}
The allreduce state type
\begin{TDef}
\TDefDefn{void*}{reduce_state}
\TDefDesc{The GASPI reduction operation state type}
\end{TDef}
is a pointer to a state which may be passed to the user defined reduction
operation. A state may contain additional information  beside the actual
data to be reduced needed to perform the reduction operation.
\subsubsection{Example}
A fortran version of the user defined allreduce hence might assume the form  \listref{lst:allreduce_user_f90}
\insertlisting{../examples/allreduce_user.f90}{GASPI User defined allreduce, fortran example. }
\section{GASPI getter functions}
The GASPI specification provides getter functions for all entries
in the GASPI configuration.  These getter functions are
synchronous local
blocking procedures which, after successful procedure
completion (i.\,e.\ return value \GASPISUCC{}), read out the
corresponding value of the current configuration setting.
The values of the parameters in  the GASPI configuration are determined in \gaspifunction{proc_init} at
startup. If the value of one of these parameters is compliant with the system capabilities,
the parameter is set to the requested/preferred value. Otherwise, the parameter is set to the maximum value compliant
with the system capabilities. The values of the parameters realised in the GASPI configuration are implementation specific.
In case of error, the return value is \GASPIGERR{} and the corresponding parameter in the getter function has an undefined value.
\subsection{Getter functions for group management}
\subsubsection{\gaspifunction{group_max}}
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_GROUP_MAX (group_max)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
  \parameterlistitem{out}{group_max}{the total number of groups}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_group_max (gaspi_number_t *group_max)
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_group_max(group_max) &
&         result( res ) bind(C, name="gaspi_group_max")
  integer(gaspi_number_t) :: group_max
  integer(gaspi_return_t) :: res
end function gaspi_group_max
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}
\subsection{Getter functions for segment management}
\subsubsection{\gaspifunction{segment_max}}
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_SEGMENT_MAX (segment_max)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
  \parameterlistitem{out}{segment_max}{the total number of permissible segments}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_segment_max (gaspi_number_t *segment_max)
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_segment_max(segment_max) &
&         result( res ) bind(C, name="gaspi_segment_max")
  integer(gaspi_number_t) :: segment_max
  integer(gaspi_return_t) :: res
end function gaspi_segment_max
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}
\subsection{Getter functions for communication management}
\subsubsection{\gaspifunction{queue_num}}
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_QUEUE_NUM (queue_num)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{queue_num}{the number of available queues}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_queue_num (gaspi_number_t *queue_num)
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_queue_num(queue_num) &
&         result( res ) bind(C, name="gaspi_queue_num")
  integer(gaspi_number_t) :: queue_num
  integer(gaspi_return_t) :: res
end function gaspi_queue_num
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}
\subsubsection{\gaspifunction{queue_size_max}}
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_QUEUE_SIZE_MAX ( queue_size_max )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{queue_size_max}{the maximum number of simultaneous requests allowed}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_queue_size_max ( gaspi_number_t* queue_size_max )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_queue_size_max(queue_size_max) &
&         result( res ) bind(C, name="gaspi_queue_size_max")
  integer(gaspi_number_t) :: queue_size_max
  integer(gaspi_return_t) :: res
end function gaspi_queue_size_max
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}
\subsubsection{\gaspifunction{queue_max}}
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_QUEUE_MAX ( queue_max )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{queue_max}{the maximum number of allowed queues}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_queue_max ( gaspi_number_t queue_max )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_queue_max ( queue_max ) &
&        result(res) bind (C, name="gaspi_queue_max" )
  integer(gaspi_number_t), value :: queue_max
  integer(gaspi_return_t) :: res
end function gaspi_queue_max
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}
\subsubsection{\gaspifunction{transfer_size_max}}
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_TRANSFER_SIZE_MAX (transfer_size_max)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{transfer_size_max}{the maximum transfer size allowed for a single request}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_transfer_size_max (gaspi_size_t *transfer_size_max)
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_transfer_size_max(transfer_size_max) &
&         result( res ) &
&         bind(C, name="gaspi_transfer_size_max")
  integer(gaspi_size_t) :: transfer_size_max
  integer(gaspi_return_t) :: res
end function gaspi_transfer_size_max
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}
\subsubsection{\gaspifunction{notification_num}}
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_NOTIFICATION_NUM (notification_num)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{notification_num}{the number of available notifications}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_notification_num (gaspi_number_t *notification_num)
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_notification_num(notification_num) &
&         result( res ) bind(C, name="gaspi_notification_num")
  integer(gaspi_number_t) :: notification_num
  integer(gaspi_return_t) :: res
end function gaspi_notification_num
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}
\subsection{Getter functions for passive communication}
\subsubsection{\gaspifunction{passive_transfer_size_max}}
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_PASSIVE_TRANSFER_SIZE_MAX (transfer_size_max)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{transfer_size_max}{maximal transfer size per single passive communication request}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_passive_transfer_size_max (gaspi_size_t *transfer_size_max)
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_passive_transfer_size_max(transfer_size_max) &
&         result( res ) &
&         bind(C, name="gaspi_passive_transfer_size_max")
  integer(gaspi_size_t) :: transfer_size_max
  integer(gaspi_return_t) :: res
end function gaspi_passive_transfer_size_max
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}
\subsection{Getter functions related to atomic operations}
\subsubsection{\gaspifunction{atomic_max}}
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_ATOMIC_MAX (max_value)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{max_value}{the maximum value an gaspi_atomic_value_t can hold}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_atomic_max (gaspi_atomic_value_t *max_value)
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_atomic_max(max_value) &
&         result( res ) bind(C, name="gaspi_atomic_max")
  integer(gaspi_atomic_value_t) :: max_value
  integer(gaspi_return_t) :: res
end function gaspi_atomic_max
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}
\subsection{Getter functions for collective communication}
\subsubsection{\gaspifunction{allreduce_buf_size}}
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_ALLREDUCE_BUF_SIZE (buf_size)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{buf_size}{the size of the internal buffer in \gaspifunction{allreduce_user}}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_allreduce_buf_size (gaspi_size_t *buf_size)
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_allreduce_buf_size(buf_size) &
&         result( res ) bind(C, name="gaspi_allreduce_buf_size")
  integer(gaspi_size_t) :: buf_size
  integer(gaspi_return_t) :: res
end function gaspi_allreduce_buf_size
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}
\subsubsection{\gaspifunction{allreduce_elem_max}}
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_ALLREDUCE_ELEM_MAX (elem_max)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{elem_max}{the maximum number of elements allowed in \gaspifunction{allreduce}}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_allreduce_elem_max (gaspi_number_t *elem_max)
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_allreduce_elem_max(elem_max) &
&         result( res ) bind(C, name="gaspi_allreduce_elem_max")
  integer(gaspi_number_t) :: elem_max
  integer(gaspi_return_t) :: res
end function gaspi_allreduce_elem_max
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}
\subsection{Getter functions related to infrastructure}
\subsubsection{\gaspifunction{network_type}}
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_NETWORK_TYPE (network_type)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{network_type}{the chosen network type}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_network_type (gaspi_network_t *network_type)
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_network_type(network_type) &
&         result( res ) bind(C, name="gaspi_network_type")
  integer(gaspi_network_t) :: network_type
  integer(gaspi_return_t) :: res
end function gaspi_network_type
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}
\subsubsection{\gaspifunction{build_infrastructure}}
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_BUILD_INFRASTRUCTURE (build_infrastructure)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{build_infrastructure}{the current value of build_infrastructure}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_build_infrastructure (gaspi_number_t *build_infrastructure)
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_build_infrastructure(build_infrastructure) &
&         result( res ) &
&         bind(C, name="gaspi_build_infrastructure")
  integer (gaspi_number_t) :: build_infrastructure
  integer(gaspi_return_t) :: res
end function gaspi_build_infrastructure
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}
\section{GASPI Environmental Management}
\subsection{Implementation Information}
\subsubsection{\gaspifunction{version}}
The \gaspifunction{version} procedure is a synchronous
local blocking
procedure which determines the version of the running GASPI
installation.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_VERSION (version)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{version}{The version of the running GASPI installation}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_version (float *version)
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_version(version) &
&         result( res ) bind(C, name="gaspi_version")
  real(c_float) :: version
  integer(gaspi_return_t) :: res
end function gaspi_version
\end{verbatim}
\end{FDefSign}
\executionphaseany
\FStdRetDescNOTimeout
\end{FDef}
After successful procedure completion, i.\,e.\ return value \GASPISUCC{}
version contains the version of the running GASPI installation.
In case of error, the return value is \GASPIGERR{}. The output parameter
version has an undefined value.
\subsection{Timing information}
\subsubsection{\gaspifunction{time_get}}
The \gaspifunction{time_get} procedure
is a synchronous
local blocking
procedure which determines the time elapsed since an arbitrary point of time in the past.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_TIME_GET (wtime)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{wtime}{time elapsed in milliseconds}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_time_get (gaspi_time_t *wtime)
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_time_get(wtime) &
&         result( res ) bind(C, name="gaspi_time_get")
  integer(gaspi_time_t) :: wtime
  integer(gaspi_return_t) :: res
end function gaspi_time_get
\end{verbatim}
\end{FDefSign}
\executionphasework
\FStdRetDescNOTimeout
\end{FDef}
After successful procedure completion, i.\,e.\ return value \GASPISUCC{}, the parameter
wtime contains elapsed time in milliseconds since an arbitrary point in
the past. The parameter wtime is not synchronised among the different GASPI processes.
In case of error, the return value is \GASPIGERR{}. The value of the output parameter
wtime is undefined.
\subsubsection{\gaspifunction{time_ticks}}
The \gaspifunction{time_ticks} procedure
is a synchronous
local blocking
procedure which returns the resolution of the internal timer in terms of milliseconds.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_TIME_TICKS (resolution)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{resolution}{the resolution of the internal timer in milliseconds}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_time_ticks (gaspi_time_t *resolution)
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_time_ticks(resolution) &
&         result( res ) bind(C, name="gaspi_time_ticks")
  integer(gaspi_time_t) :: resolution
  integer(gaspi_return_t) :: res
end function gaspi_time_ticks
\end{verbatim}
\end{FDefSign}
\executionphaseany
\FStdRetDescNOTimeout
\end{FDef}
After successful procedure completion, i.\,e.\ return value \GASPISUCC{}, the parameter
resolution contains the resolution of the internal timer in units of milliseconds.
In case of error, the return value is \GASPIGERR{}. The value of the output parameter
resolution is undefined.
\subsection{Error Codes and Classes}
\subsubsection{GASPI error codes}
In principle all return values less than zero represent an error.
Every implementation is free to define specific error
codes.
\subsubsection{\gaspifunction{print_error}}
The \gaspifunction{print_error} procedure is a synchronous
local blocking
procedure which translates an error code to a text message.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_PRINT_ERROR( error_code
                 , error_message )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{error_code}{the error code to be translated}
\parameterlistitem{out}{error_message}{the error message}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_print_error( gaspi_return_t error_code
                 , gaspi_string_t *error_message )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_print_error(error_code,error_message) &
&         result( res ) bind(C, name="gaspi_print_error")
  integer(gaspi_return_t), value :: error_code
  character(c_char), dimension(*) :: error_message
  integer(gaspi_return_t) :: res
end function gaspi_print_error
\end{verbatim}
\end{FDefSign}
\executionphaseany
\FStdRetDescNOTimeout
\end{FDef}
After successful procedure completion, i.\,e.\ return value \GASPISUCC{}
error_message contains the error message corresponding to
the error code error_code.
In case of error, the return value is \GASPIGERR{}.
The procedure can be invoked in any of the GASPI execution phases.
\section{Profiling Interface}
The profiling interface of GASPI consists of two parts.
The statistics part provides the means to allow the user to collect basic profiling data about a program run.
The event tracing part describes the requirements for an GASPI implementation in order to support the transparent interception and inspection of function calls.
\subsection{Statistics}
\subsubsection{\gaspifunction{statistic_counter_max}}
The \gaspifunction{statistic_counter_max} procedure is a synchronous local blocking 
procedure, which provides a way to inform the GASPI user dynamically about the number of avialable counters.
An implementation should not provide a compile-time constant maximum for statistic_counter.  
Instead the user can call \gaspifunction{statistic_counter_max} in order to determine the maximum value for statistic_counter.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_STATISTIC_COUNTER_MAX ( counter_max )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{out}{counter_max}{the maximum value for statistic_counter. The allowed value range is 0 <= counter < counter_max }
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_statistic_counter_max ( gaspi_number_t *counter_max )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_statistic_counter_max(counter_max) &
&         result( res ) &
&         bind(C, name="gaspi_statistic_counter_max")
  integer(gaspi_statistic_counter_t) :: counter_max
  integer(gaspi_return_t) :: res
end function gaspi_statistic_counter_max
\end{verbatim}
\end{FDefSign}
\executionphaseany
\FStdRetDescNOTimeout
\end{FDef}
If a GASPI implementation defines symbolic constants for statistic_counter a priori, then \gaspifunction{statistic_counter_max} should set counter_max to the corresponding maximum value.
A high-speed implementation will likely set counter_max to 0 and does not provide any statistics by default.
A dynamically linked wrapper library can provide extra counters by adjusting the return value of \gaspifunction{statistic_counter_max}. 
\begin{libadvice}
A sensible wrapper library will respect the value returned by the native \gaspifunction{statistic_counter_max} and append their own counters accordingly. 
Thus accessses to statistic counters provided by the GASPI implementation itself are not harmed.
\end{libadvice}
\subsubsection{\gaspifunction{statistic_counter_info}}
The \gaspifunction{statistic_counter_info} procedure is a synchronous local blocking 
procedure which provides an implementation independent way to retrieve information for a particular statistic counter.
Beside the name and a description this function also yields the meaning of the argument value for this counter, if any.
The meaning is defined in terms of the statistic_argument enumeration.
\begin{listing}[99]{2}
typedef enum { GASPI_STATISTIC_ARGUMENT_NONE
             , GASPI_STATISTIC_ARGUMENT_RANK
             , ...
             } gaspi_statistic_argument_t;
\end{listing}
A GASPI implementation is free to extend the above enumeration.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_STATISTIC_COUNTER_INFO ( const counter
                             , argument
                             , counter_name
                             , counter_description
                             , verbosity_level )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{counter}{the counter, for which detailed information is requested}
\parameterlistitem{out}{counter_argument}{the meaning of the argument value}
\parameterlistitem{out}{counter_name}{a short name of this counter}
\parameterlistitem{out}{counter_description}{a more verbose description of this counter}
\parameterlistitem{out}{verbosity_level}{minimum verbosity level to activate this counter (at least 1)}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_statistic_counter_info ( gaspi_statistic_counter_t counter
                             , gaspi_statistic_argument_t 
                                     *argument
                             , gaspi_string_t *counter_name
                             , gaspi_string_t 
                                     *counter_description
                             , gaspi_number_t *verbosity_level )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_statistic_counter_info(counter,counter_argument, &
&         counter_name,counter_description,verbosity_level) &
&         result( res ) &
&         bind(C, name="gaspi_statistic_counter_info")
  integer(gaspi_statistic_counter_t), value :: counter
  integer(gaspi_statistic_argument_t) :: counter_argument
  character(c_char), dimension(*) :: counter_name
  character(c_char), dimension(*) :: counter_description
  integer(gaspi_number_t) :: verbosity_level
  integer(gaspi_return_t) :: res
end function gaspi_statistic_counter_info
\end{verbatim}
\end{FDefSign}
\executionphaseany
\FStdRetDescNOTimeout
\end{FDef}
After successful procedure completion, i.\,e.\ return value \GASPISUCC{}, the out variables contain the desired information.
A dynamically linked wrapper library should provide information for added counters by wrapping \gaspifunction{statistic_counter_info}.
The verbosity level for all counters should be at least 1 (see \gaspifunction{statistic_verbosity_level} below). 
If the return value is \GASPIGERR{}, the particular counter issued to \gaspifunction{statistic_counter_info} does not exist.
\subsubsection{\gaspifunction{statistic_verbosity_level}}
The \gaspifunction{statistic_verbosity_level} procedure is a synchronous local blocking 
procedure which sets the process-wide verbosity level of the statistic interface. 
A counter is only active (that is, it is updated), if the process-wide verbosity level is higher or equal to the minimum verbosity level of that counter.
If a call to \gaspifunction{statistic_verbosity_level} activates or deactivates counters and there are asynchronous operations in progress, it is unspecified, whether and how these counters are affected by the operations.
It is furthermore unspecified whether and how counters of higher verbositiy levels are updated.
A verbosity level of 0 deactivates all counting. 
It is not guaranteed, that counters with a minimum verbosity level of 0 are counted properly, if the verbosity level is set to 0.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_STATISTIC_VERBOSITY_LEVEL ( verbosity_level )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{verbosity_level}{the level of desired verbosity}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_statistic_verbosity_level ( gaspi_number_t verbosity_level)
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_statistic_verbosity_level(verbosity_level_) &
&         result( res ) &
&         bind(C, name="gaspi_statistic_verbosity_level")
  integer(gaspi_number_t), value :: verbosity_level_
  integer(gaspi_return_t) :: res
end function gaspi_statistic_verbosity_level
\end{verbatim}
\end{FDefSign}
\executionphaseany
\FStdRetDescNOTimeout
\end{FDef}
\subsubsection{\gaspifunction{statistic_counter_get}}
The \gaspifunction{statistic_counter_get} procedure is a synchronous
local blocking
procedure which retrieves a statistical counter from the local GASPI process.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_STATISTIC_COUNTER_GET ( counter
                            , argument
                            , value )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{counter}{the counter to be retrieved}
\parameterlistitem{in}{argument}{the argument for the counter}
\parameterlistitem{out}{value}{the current value of the counter}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_statistic_counter_get ( gaspi_statistic_counter_t counter
                            , gaspi_statistic_argument_t argument
                            , gaspi_number_t *value )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_statistic_counter_get(counter,argument,&
&         value_arg) &
&         result( res ) &
&         bind(C, name="gaspi_statistic_counter_get")
  integer(gaspi_statistic_counter_t), value :: counter
  integer(gaspi_statistic_argument_t), value :: argument
  integer(gaspi_number_t) :: value_arg
  integer(gaspi_return_t) :: res
end function gaspi_statistic_counter_get
\end{verbatim}
\end{FDefSign}
\executionphaseany
\FStdRetDescNOTimeout
\end{FDef}
The meaning of parameter argument depends on the retrieved counter. 
For instance, if a counter retrieves the bytes sent per target rank, then argument contains the target rank number.
If the retrieved counter has no argument, the value of argument is ignored.
After successful procedure completion, i.\,e.\ return value \GASPISUCC{}
value contains the current value of the corresponding counter.
The return value is \GASPIGERR{}, if counter does not exist, i.e. exceeds \gaspifunction{statistic_counter_max}.
It is allowed to access a counter even, if the process-wide verbosity level is lower than the minimum verbosity level of that counter.
Thus it is possible to profile certain regions of an application by changing the verbosity level and read the counter values at a later point in time independently of the current verbosity level. 
\subsubsection{\gaspifunction{statistic_counter_reset}}
The \gaspifunction{statistic_counter_reset} procedure is a synchronous
local blocking
procedure which sets a statistical counter to 0.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_STATISTIC_COUNTER_RESET (counter)
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{in}{counter}{the counter to be reset}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_statistic_counter_reset (gaspi_statistic_counter_t counter)
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_statistic_counter_reset(counter) &
&         result( res ) &
&         bind(C, name="gaspi_statistic_counter_reset")
  integer(gaspi_statistic_counter_t), value :: counter
  integer(gaspi_return_t) :: res
end function gaspi_statistic_counter_reset
\end{verbatim}
\end{FDefSign}
\executionphaseany
\FStdRetDescNOTimeout
\end{FDef}
The return value is \GASPIGERR{}, if counter does not exist, i.e. exceeds \gaspifunction{statistic_counter_max}.
\subsection{Event Tracing}
The GASPI event tracing interface defines the requirements for an implementation to support the transparent interception and inspection of GASPI calls.
A GASPI implementation must provide a mechanism, through which all GASPI functions may be accessed with a name shift. 
The alternate entry point names have the prefix {\tt pgaspi_} instead of {\tt gaspi_}.
In addition the function \gaspifunction{pcontrol} is provided.
\subsubsection{\gaspifunction{pcontrol}}
The function \gaspifunction{pcontrol} is a no-op. 
A GASPI implementation itself ignores the value of argument and returns immediately.
This routine is provided in order to enable users to communicate with an event trace interface from inside the application.
The meaning of argument is specified by the used event tracer.
\begin{FDef}
\begin{FDefSign}
\begin{verbatim}
GASPI_PCONTROL ( argument )
\end{verbatim}
\end{FDefSign}
\parameterlistbegin
\parameterlistitem{inout}{argument}{}
\parameterlistend
\begin{FDefSign}
\begin{verbatim}
gaspi_return_t
gaspi_pcontrol ( gaspi_pointer_t argument )
\end{verbatim}
\end{FDefSign}
\begin{FDefSign}
\begin{verbatim}
function gaspi_pcontrol(argument) &
&         result( res ) bind(C, name="gaspi_pcontrol")
  type(c_ptr), value :: argument
  integer(gaspi_return_t) :: res
end function gaspi_pcontrol
\end{verbatim}
\end{FDefSign}
\executionphaseany
\FStdRetDescNOTimeout
\end{FDef}
\appendix
\section{Listings}
\subsection{success_or_die}
\insertlisting{../examples/success_or_die.h}{success_or_die.h}
\insertlisting{../examples/success_or_die.c}{success_or_die.c}
\subsection{wait_if_queue_full}
\insertlisting{../examples/wait_if_queue_full.h}{wait_if_queue_full.h}
\insertlisting{../examples/wait_if_queue_full.c}{wait_if_queue_full.c}
\end{document}
